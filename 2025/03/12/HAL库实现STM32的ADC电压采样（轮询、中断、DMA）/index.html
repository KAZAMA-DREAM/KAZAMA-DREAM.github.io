<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>HAL库实现STM32的ADC电压采样（轮询、中断、DMA） | KAZAMAのBlog</title><meta name="author" content="KAZAMA,wyy1778789301@163.com"><meta name="copyright" content="KAZAMA"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="HAL库实现STM32的ADC电压采样（轮询、中断、DMA）">
<meta property="og:type" content="article">
<meta property="og:title" content="HAL库实现STM32的ADC电压采样（轮询、中断、DMA）">
<meta property="og:url" content="http://www.kazama.top/2025/03/12/HAL%E5%BA%93%E5%AE%9E%E7%8E%B0STM32%E7%9A%84ADC%E7%94%B5%E5%8E%8B%E9%87%87%E6%A0%B7%EF%BC%88%E8%BD%AE%E8%AF%A2%E3%80%81%E4%B8%AD%E6%96%AD%E3%80%81DMA%EF%BC%89/index.html">
<meta property="og:site_name" content="KAZAMAのBlog">
<meta property="og:description" content="HAL库实现STM32的ADC电压采样（轮询、中断、DMA）">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://api.r10086.com/樱道随机图片api接口.php?图片系列=风景系列7">
<meta property="article:published_time" content="2025-03-12T12:17:07.000Z">
<meta property="article:modified_time" content="2025-03-12T12:17:07.000Z">
<meta property="article:author" content="KAZAMA">
<meta property="article:tag" content="STM32">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://api.r10086.com/樱道随机图片api接口.php?图片系列=风景系列7"><link rel="shortcut icon" href="https://api.r10086.com/樱道随机图片api接口.php?图片系列=风景系列1"><link rel="canonical" href="http://www.kazama.top/2025/03/12/HAL%E5%BA%93%E5%AE%9E%E7%8E%B0STM32%E7%9A%84ADC%E7%94%B5%E5%8E%8B%E9%87%87%E6%A0%B7%EF%BC%88%E8%BD%AE%E8%AF%A2%E3%80%81%E4%B8%AD%E6%96%AD%E3%80%81DMA%EF%BC%89/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'HAL库实现STM32的ADC电压采样（轮询、中断、DMA）',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-03-12 20:17:07'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = url => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      link.onload = () => resolve()
      link.onerror = () => reject()
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.2"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://api.r10086.com/樱道随机图片api接口.php?图片系列=风景系列3" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">425</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">49</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/share/"><i class="fa-fw fa fa-comments-o"></i><span> 分享</span></a></li><li><a class="site-page child" href="/photos/"><i class="fa-fw fa fa-camera-retro"></i><span> 相册</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 影视</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://api.r10086.com/樱道随机图片api接口.php?图片系列=风景系列7')"><nav id="nav"><span id="blog-info"><a href="/" title="KAZAMAのBlog"><span class="site-name">KAZAMAのBlog</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/share/"><i class="fa-fw fa fa-comments-o"></i><span> 分享</span></a></li><li><a class="site-page child" href="/photos/"><i class="fa-fw fa fa-camera-retro"></i><span> 相册</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 影视</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">HAL库实现STM32的ADC电压采样（轮询、中断、DMA）</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-03-12T12:17:07.000Z" title="发表于 2025-03-12 20:17:07">2025-03-12</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-03-12T12:17:07.000Z" title="更新于 2025-03-12 20:17:07">2025-03-12</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">7.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>25分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="HAL库实现STM32的ADC电压采样（轮询、中断、DMA）"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="HAL库实现STM32的ADC电压采样（轮询、中断、DMA）"><a href="#HAL库实现STM32的ADC电压采样（轮询、中断、DMA）" class="headerlink" title="HAL库实现STM32的ADC电压采样（轮询、中断、DMA）"></a>HAL库实现STM32的ADC电压采样（轮询、中断、DMA）</h1><h2 id="1-ADC功能的基础知识"><a href="#1-ADC功能的基础知识" class="headerlink" title="1    ADC功能的基础知识"></a>1    ADC功能的基础知识</h2><blockquote>
<p>引脚数量大于等于100的封装上通常会有 VREF 引脚，ADC可转换的电压不大于 VREF 上的电压；引脚数量小于100的封装其 VREF 直接就是在芯片内部连接到 VDDA 的。</p>
<p>和其他外设一样ADC工作需要时钟，STM32中ADC的时钟通常由PCLK2（ABP2外设时钟）分频得来，在 STM32F405RG 中最大可以达到36MHz。</p>
<p>STM32的ADC通常最大精度是12位，使用时也可以配置成10位、8位或6位等。精度会影响转换速度和数据计算。</p>
<p>ADC每处理一次数据分为 <code>采样</code> 和 <code>转换</code> 两个过程。 采样时间可以配置，比如 STM32F405RG 中最小为3个ADC时钟周期；转换时间和精度有关，12位精度下为12个ADC时钟周期、10位精度下为10个ADC时钟周期，依此类推。</p>
<p>所以每采样一个数据所需的时间为 <code>(采样周期 + 转换周期) / ADC时钟频率</code>。比如当ADC时钟频率为30MHz，采样周期选最小值3，精度为12位时，每处理一次数据耗时为 (3+12)/30/1000000 (秒) = 0.5微秒。</p>
<p>ADC工作最后得到的数据换算成真实电压的时候主要和 VREF 以及精度有关。比如12位精度下 真实电压 = 数据 * VREF / (4096 - 1) ，10位精度下 真实电压 = 数据 * VREF / (1024 - 1) ，依此类推。但这里还有点争议，比如那个 -1 要不要？</p>
<p>这里主要考虑两个问题：ADC因为工作原理关系本身有1个分辨率的误差；单片机在除以4096、1024等这些数值的时候可以用右移的方式提高效率。所以通常可以不要 <code>-1</code> ，即12位精度下 <code>真实电压 = 数据 * VREF / 4096</code> 。</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/KAZAMA-DREAM/myproductpic/KAZAMABLOG/2025-03-12-HAL%E5%BA%93%E5%AE%9E%E7%8E%B0STM32%E7%9A%84ADC%E7%94%B5%E5%8E%8B%E9%87%87%E6%A0%B7%EF%BC%88%E8%BD%AE%E8%AF%A2%E3%80%81%E4%B8%AD%E6%96%AD%E3%80%81DMA%EF%BC%89/e0a233ae7830cf3811919968c7339579.png"></p>
<p><strong>① 电压输入范围</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/KAZAMA-DREAM/myproductpic/KAZAMABLOG/2025-03-12-HAL%E5%BA%93%E5%AE%9E%E7%8E%B0STM32%E7%9A%84ADC%E7%94%B5%E5%8E%8B%E9%87%87%E6%A0%B7%EF%BC%88%E8%BD%AE%E8%AF%A2%E3%80%81%E4%B8%AD%E6%96%AD%E3%80%81DMA%EF%BC%89/8909454d19dc3e5e538de732f04340c5.png"></p>
<p>ADC一般用于采集小电压，其输入值不能超过VDDA，即ADC输入范围：VREF- ≤ VIN ≤ VREF+。具体的定义见上图。<br>一般把VSSA和VREF- 接地， VREF+ 和 VDDA接3V3，那么ADC的输入范围是0~3.3V。</p>
<p>如果我们想让输入的电压范围变宽，去到可以测试负电压或者更高的正电压，我们可以在外部加一个电压调理电路，把需要转换的电压抬升或者降压到 0~3.3V，这样 ADC 就可以测量了。</p>
<p><strong>② ADC输入通道</strong></p>
<p>从ADCx_INT0-ADCx_INT15对应三个ADC的16个外部通道，进行模拟信号转换。此外，还有2个内部通道：温度检测或者内部电压检测，选择对应通道之后，便会选择对应GPIO引脚，相关的引脚定义和描述可在开发板的数据手册里找。</p>
<p>STM32F10x系列芯片ADC通道和引脚对应关系 ：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/KAZAMA-DREAM/myproductpic/KAZAMABLOG/2025-03-12-HAL%E5%BA%93%E5%AE%9E%E7%8E%B0STM32%E7%9A%84ADC%E7%94%B5%E5%8E%8B%E9%87%87%E6%A0%B7%EF%BC%88%E8%BD%AE%E8%AF%A2%E3%80%81%E4%B8%AD%E6%96%AD%E3%80%81DMA%EF%BC%89/9dac33abd48d811eef53cd5b3afe66c7.png"></p>
<p><strong>16个外部通道</strong>：芯片上有16个引脚是可以接到模拟电压上进行电压值检测的。</p>
<p><strong>2个内部信号源</strong> ： 一个是内部温度传感器，一个是内部参考电压。</p>
<p>一共支持<strong>23个引脚</strong>支持ADC，包括21个外部和2个内部信号源。</p>
<p><strong>③ 注入通道，规则通道</strong></p>
<p>我们看到，在选择了ADC的相关通道引脚之后，在模拟至数字转换器中有两个通道，<strong>注入通道，规则通道</strong>，<br>规则通道至多16个，注入通道至多4个。</p>
<p><strong>规则通道</strong>，相当于你正常运行的程序，看它的名字就可以知道，很规矩，就是正常执行程序。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/KAZAMA-DREAM/myproductpic/KAZAMABLOG/2025-03-12-HAL%E5%BA%93%E5%AE%9E%E7%8E%B0STM32%E7%9A%84ADC%E7%94%B5%E5%8E%8B%E9%87%87%E6%A0%B7%EF%BC%88%E8%BD%AE%E8%AF%A2%E3%80%81%E4%B8%AD%E6%96%AD%E3%80%81DMA%EF%BC%89/9a1a7404009b152a5e2f5d7553eaf31c.png"></p>
<p><strong>规则序列寄存器</strong>有 3 个，分别为 SQR3、SQR2、SQR1。SQR3 控制着规则序列中的第一个到第六个转换，对应的位为：SQ1[4:0]<del>SQ6[4:0]，第一次转换的是位 4:0 SQ1[4:0]，如果通道 16 想第一次转换，那么在 SQ1[4:0]写 16 即可。SQR2 控制着规则序列中的第 7 到第12 个转换，对应的位为：SQ7[4:0]</del>SQ12[4:0]，如果通道 1 想第 8 个转换，则 SQ8[4:0]写 1即可。SQR1 控制着规则序列中的第 13 到第 16 个转换，对应位为：SQ13[4:0]~SQ16[4:0]，如果通道 6 想第 10 个转换，则 SQ10[4:0]写 6 即可。具体使用多少个通道，由 SQR1 的位L[3:0]决定，最多 16 个通道。</p>
<p><strong>注入通道</strong>，可以打断规则通道，听它的名字就知道不安分，如果在规则通道转换过程中，有注入通道进行转换，那么就要先转换完成注入通道，等注入通道转换完成后，再回到规则通道的转换流程。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/KAZAMA-DREAM/myproductpic/KAZAMABLOG/2025-03-12-HAL%E5%BA%93%E5%AE%9E%E7%8E%B0STM32%E7%9A%84ADC%E7%94%B5%E5%8E%8B%E9%87%87%E6%A0%B7%EF%BC%88%E8%BD%AE%E8%AF%A2%E3%80%81%E4%B8%AD%E6%96%AD%E3%80%81DMA%EF%BC%89/c3dc328c5ceb5168a0f4b88bf3904b80.png"></p>
<p>注入序列寄存器 JSQR 只有一个，最多支持 4 个通道，具体多少个由 JSQR 的 JL[2:0]决定。如果 JL 的  值小于 4 的话，则 JSQR 跟 SQR 决定转换顺序的设置不一样，第一次转换的不是 JSQR1[4:0]，而是 JCQRx[4:0] ，x = （4-JL），跟 SQR 刚好相反。如果 JL=00（1个转换），那么转换的顺序是从 JSQR4[4:0]开始，而不是从 JSQR1[4:0]开始，这个要注意，编程的时候不要搞错。当 JL 等于 4 时，跟 SQR 一样。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/KAZAMA-DREAM/myproductpic/KAZAMABLOG/2025-03-12-HAL%E5%BA%93%E5%AE%9E%E7%8E%B0STM32%E7%9A%84ADC%E7%94%B5%E5%8E%8B%E9%87%87%E6%A0%B7%EF%BC%88%E8%BD%AE%E8%AF%A2%E3%80%81%E4%B8%AD%E6%96%AD%E3%80%81DMA%EF%BC%89/c11b74aa8b3d25dada315ae635c6810d.png"></p>
<p>一切准备就绪后，ADC 转换后的数据根据转换组的不同，规则组的数据放在 ADC_DR寄存器，注入组的数据放在 JDRx。</p>
<p><strong>规则数据寄存器</strong>，ADC 规则组数据寄存器 ADC_DR 只有一个，是一个 32 位的寄存器，低 16 位在单 ADC<br>时使用，高 16 位是在 ADC1 中双模式下保存 ADC2 转换的规则数据，双模式就是 ADC1 和ADC2 同时使用。在单模式下，ADC1/2/3 都不使用高 16 位。因为 ADC 的精度是 12 位，无论 ADC_DR 的高 16 或者低 16 位都放不满，只能左对齐或者右对齐，具体是以哪一种方式存放，由 ADC_CR2 的 11 位 ALIGN 设置。</p>
<p>规则通道可以有 16 个这么多，可规则数据寄存器只有一个，如果使用多通道转换，那转换的数据就全部都挤在了 DR 里面，前一个时间点转换的通道数据，就会被下一个时间点的另外一个通道转换的数据覆盖掉，所以当通道转换完成后就应该把数据取走，或者开启 DMA 模式，把数据传输到内存里面，不然就会造成数据的覆盖。最常用的做法就是开<br>启 DMA 传输。</p>
<p><strong>注入数据寄存器</strong>：ADC 注入组最多有 4 个通道，刚好注入数据寄存器也有 4 个，每个通道对应着自己的<br>寄存器，不会跟规则寄存器那样产生数据覆盖的问题。ADC_JDRx 是 32 位的，低 16 位有效，高 16 位保留，数据同样分为左对齐和右对齐，具体是以哪一种方式存放，由ADC_CR2 的 11 位 ALIGN 设置。</p>
<p><strong>④ ADC时钟</strong></p>
<p>图中的ADC预分频器的ADCCLK是ADC模块的时钟来源。通常，由时钟控制器提供的ADCCLK时钟和PCLK2（APB2时钟）同步。RCC控制器为ADC时钟提供一个专用的可编程预分频器。 分频因子由RCC_CFGR的ADCPRE[1:0]配置，可配置2/4/6/8分频。</p>
<p>STM32的ADC最大的转换速率为1MHz，也就是说最快转换时间为1us，为了保证ADC转换结果的准确性，ADC的时钟最好不超过14M。</p>
<p>ADC 使用若干个 ADC_CLK 周期对输入的电压进行采样，采样的周期数可通过 ADC 采样时间寄存器 ADC_SMPR1 和 ADC_SMPR2 中的 SMP[2:0]位设置，ADC_SMPR2 控制的是通道 0<del>9，ADC_SMPR1 控制的是通道 10</del>17。每个通道可以分别用不同的时间采样。其中采样周期最小是 1.5 个，即如果我们要达到最快的采样，那么应该设置采样周期为 1.5<br>个周期，这里说的周期就是 1/ADC_CLK。</p>
<p><code>T = 采样时间 + 12.5个周期，其中1周期为1/ADCCLK</code></p>
<p>例如，当 ADCCLK=14Mhz 的时候，并设置 1.5 个周期的采样时间，则得到： Tcovn=1.5+12.5=14 个周期=1us。</p>
<p><strong>⑤ 外部触发转换</strong></p>
<p>ADC 转换可以由ADC 控制寄存器2: ADC_CR2 的ADON 这个位来控制，写1 的时候开始转换，写0 的时候停止转换</p>
<p>当然，除了ADC_CR2寄存器的ADON位控制转换的开始与停止，还可以支持外部事件触发转换（比如定时器捕捉、EXTI线）包括内部定时器触发和外部IO触发。具体的触发源由ADC_CR2的EXTSEL[2:0]位（规则通道触发源 ）和 JEXTSEL[2:0]位（注入通道触发源）控制。EXTSEL[2:0] 用于 选择 规则 通道 的触发源，JEXTSEL[2:0]用于选择注入通道的触发源。选定好触发源之后，触发源是否要激活，则由ADC 控制寄存器 2:ADC_CR2 的 EXTTRIG 和 JEXTTRIG 这两位来激活。其中 ADC3 的规则转换和注入转换的触发源与 ADC1/2 的有所不同，上图已经给出，具体查看第五部分框图即可理解</p>
<p><strong>⑥ 中断</strong></p>
<p>中断触发条件有三个，规则通道转换结束，注入通道转换结束，或者模拟看门狗状态位被设置时都能产生中断。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/KAZAMA-DREAM/myproductpic/KAZAMABLOG/2025-03-12-HAL%E5%BA%93%E5%AE%9E%E7%8E%B0STM32%E7%9A%84ADC%E7%94%B5%E5%8E%8B%E9%87%87%E6%A0%B7%EF%BC%88%E8%BD%AE%E8%AF%A2%E3%80%81%E4%B8%AD%E6%96%AD%E3%80%81DMA%EF%BC%89/8388aee597f836cf404b4d0ce8da75f4.png"></p>
<p>转换结束中断就是正常的ADC完成一次转换，进入中断，这个很好理解。</p>
<p><strong>模拟看门狗中断</strong>，当被ADC转换的模拟电压值低于低阈值或高于高阈值时，便会产生中断。阈值的高低值由ADC_LTR和ADC_HTR配置。模拟看门狗，听他的名字就知道，在ADC的应用中是为了防止读取到的电压值超量程或者低于量程。例如我们设置高阈值是 2.5V，那么模拟电压超过 2.5V 的时候，就会产生模拟看门狗中断，反之低阈值也一样。</p>
<p><strong>DMA</strong>，同时ADC还支持DMA触发，规则和注入通道转换结束后会产生DMA请求，用于将转换好的数据传输到内存。</p>
<p>注意，只有ADC1和ADC3可以产生DMA请求，因为涉及到DMA传输，所以这里我们不再详细介绍，之后几节会更新DMA,一般我们在使用ADC 的时候都会开启DMA 传输。</p>
<p><strong>电压转换</strong>：模拟电压经过 ADC 转换后，是一个 12 位的数字值，如果通过串口以 16 进制打印出来的话，可读性比较差，那么有时候我们就需要把数字电压转换成模拟电压，也可以跟实际的模拟电压（用万用表测）对比，看看转换是否准确。<br>我们一般在设计原理图的时候会把 ADC 的输入电压范围设定在：0~3.3v，因为 ADC是 12 位的，那么 12 位满量程对应的就是 3.3V，12 位满量程对应的数字值是：2^12。数值0 对应的就是 0V。如果转换后的数值为  X ，X 对应的模拟电压为 Y，那么会有这么一个等式成立：  2^12 / 3.3 = X / Y，=&gt; Y = (3.3 * X ) / 2^12。</p>
<br/>



<h3 id="1-1-ADC的三种工作方式及优缺点"><a href="#1-1-ADC的三种工作方式及优缺点" class="headerlink" title="1.1    ADC的三种工作方式及优缺点"></a>1.1    ADC的三种工作方式及优缺点</h3><blockquote>
<p>STM32的ADC还有规则转换（Regular）和注入转换（Injected），注入就相当于在正常规则转换过程中插入中断，优先进行注入转换，通常挺少用的，这里不进行演示。</p>
</blockquote>
<ol>
<li><strong>查询模式</strong>：查询模式下，占用cpu时间较多，cpu效率较低。</li>
<li><strong>中断模式</strong>：相比查询模式大大释放了cpu，提高了cpu的利用率。</li>
<li><strong>DMA模式</strong>：该模式下基本不占用cpu，能直接将ADC采集的数据存储到存储器。</li>
</ol>
<br/>



<h3 id="1-2-ADC的转换方式"><a href="#1-2-ADC的转换方式" class="headerlink" title="1.2    ADC的转换方式"></a>1.2    ADC的转换方式</h3><p>转换方式需要根据情况搭配使用，分为扫描模式（Scan Conversion mode）、连续转换模式(Continuous Conversion Mode)和间断模式(Discontinuous Conversion Mode)。</p>
<p><strong>ADC单通道转换：</strong></p>
<ul>
<li>单次转换模式，扫描模式关闭：只进行一次转换，不过可以持续使能ADC达到不断采集的的。</li>
<li>连续转换模式，扫描模式关闭：使能一次ADC后，能够连续转换。</li>
</ul>
<p><strong>ADC多通道转换：</strong></p>
<ul>
<li><p>单次转换模式，扫描模式开启：每个通道转换完一次后结束转换，但可以通过持续使能ADC不断进行多通道连续采集。</p>
</li>
<li><p>连续转换模式，扫描模式开启：每个通道转换完之后还能继续循环转换，不需要反复使能ADC。</p>
<p>多通道必须开启扫描模式。</p>
</li>
<li><p>间断模式，触发一次，转换一个通道，再触发，再转换。在所选转换通道循环，由触发信号启动新一轮的转换，直到转换完成为止。</p>
</li>
</ul>
<p>扫描模式简单的说是一次对所有所选中的通道进行转换，比如开了ch0，ch1，ch4，ch5。  ch0转换完以后就会自动转换通道1,4,5直到转换完这个过程不能被打断。如果开启了连续转换模式，则会在转换完ch5之后开始新一轮的转换。</p>
<p>这就引入了间断模式，可以说是对扫描模式的一种补充。它可以把0,1,4,5这四个通道进行分组。可以分成0,1一组，4,5一组。也可以每个通道单独配置为一组。这样每一组转换之前都需要先触发一次。</p>
<br/>



<h2 id="2-ADC单通道-轮询模式-阻塞模式"><a href="#2-ADC单通道-轮询模式-阻塞模式" class="headerlink" title="2    ADC单通道+轮询模式(阻塞模式)"></a>2    ADC单通道+轮询模式(阻塞模式)</h2><h3 id="2-1-操作流程"><a href="#2-1-操作流程" class="headerlink" title="2.1    操作流程"></a>2.1    操作流程</h3><ol>
<li>开启ADC：调用HAL_ADC_Start（），开启ADC。</li>
<li>等待EOC标志位：调用查询函数HAL_ADC_PollForConversion（），等待ADC转化结束，CUP在这段时间内不能干其他事，所以查询方式降低了CUP的使用率。</li>
<li>读取寄存器数据：调用HAL_ADC_GetValue（）。</li>
</ol>
<br/>



<h3 id="2-2-STM32CubeMX配置流程"><a href="#2-2-STM32CubeMX配置流程" class="headerlink" title="2.2    STM32CubeMX配置流程"></a>2.2    STM32CubeMX配置流程</h3><p>使用STM32CubeMX，打开ADC1的通道1（PA1）。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/KAZAMA-DREAM/myproductpic/KAZAMABLOG/2025-03-12-HAL%E5%BA%93%E5%AE%9E%E7%8E%B0STM32%E7%9A%84ADC%E7%94%B5%E5%8E%8B%E9%87%87%E6%A0%B7%EF%BC%88%E8%BD%AE%E8%AF%A2%E3%80%81%E4%B8%AD%E6%96%AD%E3%80%81DMA%EF%BC%89/dd06594270231c98c77f099a0f51a355.png"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/KAZAMA-DREAM/myproductpic/KAZAMABLOG/2025-03-12-HAL%E5%BA%93%E5%AE%9E%E7%8E%B0STM32%E7%9A%84ADC%E7%94%B5%E5%8E%8B%E9%87%87%E6%A0%B7%EF%BC%88%E8%BD%AE%E8%AF%A2%E3%80%81%E4%B8%AD%E6%96%AD%E3%80%81DMA%EF%BC%89/4aabb7cd75da2fcf3037b03a25d3c934.png"></p>
<ul>
<li><p>ADCs_Common_Settings： 所有ADC公共设置<br>  本文只介绍ADC工作于独立模式，所以这里不用调整；</p>
</li>
<li><p>ADC_Settings 当前ADC设置</p>
<p>  ​    Clock Prescaler PCLK2时钟分频系数，分频后就是ADC时钟；<br>  ​    Resolution 分辨率；<br>  ​    Data Alignment 数据对齐方式，通常默认左对齐就行；<br>  ​    Scan Conversion Mode 扫描模式，多通道时强制开启扫描模式；<br>  ​    Continuous Conversion Mode 连续转换模式；<br>  ​    Discontinuous Conversion Mode<br>  ​    DMA Continuous Requests DMA连续请求；<br>  ​    End Of Conversion Selection</p>
</li>
<li><p>ADC_Regular_ConversionMode 规则转换模式<br>  Number Of Conversion 要转换的通道数目<br>  External Trigge rConversion Source 转换触发源</p>
<p>  ​    Regular Conversion launched by software 规则的软件触发 调用函数触发即可</p>
<p>  ​    Timer X Capture Compare X event 外部引脚触发,</p>
<p>  ​    Timer X Trigger Out event 定时器通道输出触发 需要设置相应的定时器设置</p>
<p>  External Trigge rConversion Edge 转换触发规则<br>  Rank 通道转换序号</p>
<pre><code>  Channel 该序号通道编号
  Sampling Time 该序号采样时间
</code></pre>
</li>
<li><p>ADC_Injected_ConversionMode 注入转换模式<br>  挺少使用的，本文不涉及；</p>
</li>
<li><p>WatchDog 模拟看门狗<br>  输入通道上电压超出某个阈值时触发，本文不涉及；</p>
</li>
</ul>
<p><strong>Data Alignment ：</strong> 可选左对齐或右对齐。</p>
<p><strong>Conversion Mode：</strong>由于只使用了一个通道，关闭就行。</p>
<p><strong>Continuous Conversion Mode：</strong>这里关闭，我们使用软件开启ADC。</p>
<p><strong>Discontinuous Conversion Mode：</strong>单通道模式间断模式自动关闭，不可选。</p>
<p><strong>Enable Regular Conversions：</strong>是否使能转换，开启规则转换。</p>
<p><strong>Number Of Conversion：</strong>转换的通道数，单通道当然只能是1。</p>
<p><strong>External Trigger Conversion Source：</strong>选择由软件触发采集。</p>
<p><strong>Rank ：</strong>每个通道的编号，每个Rank有如下参数配置。</p>
<ul>
<li>Channel：所选择的通道</li>
<li>Sampling Time：每次采集ADC所需要的时间（采样周期），T = 采样周期 + 12.5个周期，（其中1周期为1/ADCCLK，设置的ADC时钟频率为12M），这里我设置的ADC的采样周期 为1.5Cycles，所以转化一次总的时间T=（1.5+12.5）/ 12=1.167us。补充：采样周期越长，越准确，这里存在一个竞争冒险的关系。</li>
</ul>
<br/>



<h3 id="2-3-软件代码"><a href="#2-3-软件代码" class="headerlink" title="2.3    软件代码"></a>2.3    软件代码</h3><p>ADC单通道+单次转换模式（只转换一次）+不扫描模式（只有一个通道）</p>
<blockquote>
<p>连续转换(continus conversion mode)下只要启动ADC后就会不停的工作直到使用 <code>HAL_ADC_Stop (ADC_HandleTypeDef *hadc)</code> 函数手动停止ADC。</p>
<p>连续情况下可以不使用 <code>HAL_ADC_PollForConversion</code> ，需要时去读取数据即可。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* USER CODE BEGIN 1 */</span></span><br><span class="line"><span class="type">uint16_t</span> adcValue;</span><br><span class="line"><span class="comment">/* USER CODE END 1 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">/* Configure the system clock */</span></span><br><span class="line">    SystemClock_Config();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* USER CODE BEGIN SysInit */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* USER CODE END SysInit */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Initialize all configured peripherals */</span></span><br><span class="line">    MX_GPIO_Init();</span><br><span class="line">    MX_USART1_UART_Init();</span><br><span class="line">    MX_ADC1_Init();</span><br><span class="line">    <span class="comment">/* USER CODE BEGIN 2 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 开启 ADC自动校准 */</span></span><br><span class="line">    <span class="keyword">if</span> (HAL_ADCEx_Calibration_Start(&amp;hadc1, ADC_CALIB_OFFSET, ADC_SINGLE_ENDED) != HAL_OK) &#123;</span><br><span class="line">        Error_Handler();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 先开启ADC</span></span><br><span class="line">        HAL_ADC_Start(&amp;hadc1);</span><br><span class="line">        <span class="comment">//查询函数，查询EOC标志位。每次采样，CUP在这里都要 </span></span><br><span class="line">        <span class="comment">//等待采样完成才能进行下一步，这段时间CUP没有干其他 </span></span><br><span class="line">        <span class="comment">//事，所以降低了CUP使用率</span></span><br><span class="line">        <span class="keyword">if</span> (HAL_ADC_PollForConversion(&amp;hadc1, <span class="number">10</span>) == HAL_OK) &#123;</span><br><span class="line">            <span class="comment">// 得到ADC的值</span></span><br><span class="line">            adcValue = HAL_ADC_GetValue(&amp;hadc1);</span><br><span class="line">            supercapV = (<span class="type">uint32_t</span>) adcValue * <span class="number">3300</span> / <span class="number">0xFFFF</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        HAL_ADC_Stop(&amp;hadc1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>ADC查询模式小总结：在关闭间断模式的情况下，多通道采集尽量不使用ADC查询模式进行，不然采样值容易出错，如果要用一定要开启间断采样模式。</strong></p>
<br/>



<h2 id="3-多通道查询模式"><a href="#3-多通道查询模式" class="headerlink" title="3    多通道查询模式"></a>3    多通道查询模式</h2><h3 id="3-1-STM32CubeMX配置"><a href="#3-1-STM32CubeMX配置" class="headerlink" title="3.1    STM32CubeMX配置"></a>3.1    STM32CubeMX配置</h3><p>开启ADC1的四个通道</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/KAZAMA-DREAM/myproductpic/KAZAMABLOG/2025-03-12-HAL%E5%BA%93%E5%AE%9E%E7%8E%B0STM32%E7%9A%84ADC%E7%94%B5%E5%8E%8B%E9%87%87%E6%A0%B7%EF%BC%88%E8%BD%AE%E8%AF%A2%E3%80%81%E4%B8%AD%E6%96%AD%E3%80%81DMA%EF%BC%89/1b21488c610954117ead57d4e266bb78.png"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/KAZAMA-DREAM/myproductpic/KAZAMABLOG/2025-03-12-HAL%E5%BA%93%E5%AE%9E%E7%8E%B0STM32%E7%9A%84ADC%E7%94%B5%E5%8E%8B%E9%87%87%E6%A0%B7%EF%BC%88%E8%BD%AE%E8%AF%A2%E3%80%81%E4%B8%AD%E6%96%AD%E3%80%81DMA%EF%BC%89/fabc15a6a85c463a55df4b37e576b5fa.png"></p>
<p>注意的是采样转换顺序是依据 Rank 编号，而不是通道编号。</p>
<br/>



<h3 id="3-2-软件代码"><a href="#3-2-软件代码" class="headerlink" title="3.2    软件代码"></a>3.2    软件代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">/* USER CODE BEGIN 1 */</span></span><br><span class="line">    <span class="type">uint16_t</span> ADC_Value1,i; </span><br><span class="line">    <span class="type">uint16_t</span> adcbuf[<span class="number">4</span>];    <span class="comment">//四个通道采样数据存储的数组</span></span><br><span class="line">    <span class="comment">/* USER CODE END 1 */</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* MCU Configuration--------------------------------------------------------*/</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* Reset of all peripherals, Initializes the Flash interface and the Systick. */</span></span><br><span class="line">    HAL_Init();</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* USER CODE BEGIN Init */</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* USER CODE END Init */</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* Configure the system clock */</span></span><br><span class="line">    SystemClock_Config();</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* USER CODE BEGIN SysInit */</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* USER CODE END SysInit */</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* Initialize all configured peripherals */</span></span><br><span class="line">    MX_GPIO_Init();</span><br><span class="line">    MX_USART1_UART_Init();</span><br><span class="line">    MX_ADC1_Init();</span><br><span class="line">    <span class="comment">/* USER CODE BEGIN 2 */</span></span><br><span class="line">    HAL_ADCEx_Calibration_Start(&amp;hadc1);   <span class="comment">//开启adc前校准一下ADC</span></span><br><span class="line">    <span class="comment">/* USER CODE END 2 */</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* Infinite loop */</span></span><br><span class="line">    <span class="comment">/* USER CODE BEGIN WHILE */</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;<span class="number">5</span>; i++) &#123;</span><br><span class="line">            HAL_ADC_Start(&amp;hadc1);   <span class="comment">//由于没有开启连续转换，每次转换前需要软件开启adc</span></span><br><span class="line">            HAL_ADC_PollForConversion(&amp;hadc1,<span class="number">10</span>);<span class="comment">//轮询等待ADC转换完成</span></span><br><span class="line">            adcbuf[i] = HAL_ADC_GetValue(&amp;hadc1);     <span class="comment">//将四个通道的采样值存在数组里</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;adc_ch%d:  %d  \n\r&quot;</span>, i, adcbuf[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		HAL_ADC_Stop(&amp;hadc1);<span class="comment">//关闭ADC</span></span><br><span class="line">        <span class="comment">/* USER CODE END WHILE */</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">/* USER CODE BEGIN 3 */</span></span><br><span class="line">    &#125;</span><br><span class="line">        <span class="comment">/* USER CODE END 3 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<br/>



<h2 id="4-ADC中断模式（单通道）"><a href="#4-ADC中断模式（单通道）" class="headerlink" title="4    ADC中断模式（单通道）"></a>4    ADC中断模式（单通道）</h2><h3 id="4-1-流程"><a href="#4-1-流程" class="headerlink" title="4.1    流程"></a>4.1    流程</h3><ol>
<li>启动ADC，使能中断。</li>
<li>等待中断触发。</li>
<li>在中断中读取寄存器数据。</li>
</ol>
<br/>



<h3 id="4-2-STM32CubeMX配置"><a href="#4-2-STM32CubeMX配置" class="headerlink" title="4.2    STM32CubeMX配置"></a>4.2    STM32CubeMX配置</h3><p>ADC的中断模式和单通道采样一样，只是多使能了一下adc中断。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/KAZAMA-DREAM/myproductpic/KAZAMABLOG/2025-03-12-HAL%E5%BA%93%E5%AE%9E%E7%8E%B0STM32%E7%9A%84ADC%E7%94%B5%E5%8E%8B%E9%87%87%E6%A0%B7%EF%BC%88%E8%BD%AE%E8%AF%A2%E3%80%81%E4%B8%AD%E6%96%AD%E3%80%81DMA%EF%BC%89/b1c5450ac7a573499286d88c0328a276.png"></p>
<p>上面演示中开启了ADC中断，重写 void HAL_ADC_ConvCpltCallback (ADC_HandleTypeDef <em>hadc) 函数，使用 HAL_ADC_Start_IT(ADC_HandleTypeDef</em> hadc) 函数启动ADC。每次转换完成将触发 HAL_ADC_ConvCpltCallback ，在该函数中读取数据。</p>
<p>中断方式下也可以使用前面的方式改变采样通道。</p>
<br/>



<h3 id="4-3-软件代码"><a href="#4-3-软件代码" class="headerlink" title="4.3    软件代码"></a>4.3    软件代码</h3><p>只需在while()上面校准adc和开启ADC。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint16_t</span> ADC_Values;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 初始化ADC</span></span><br><span class="line">    MX_ADC1_Init();</span><br><span class="line">    <span class="comment">// 开启ADC自动校准</span></span><br><span class="line">    <span class="keyword">if</span> (HAL_ADCEx_Calibration_Start(&amp;hadc1, ADC_CALIB_OFFSET, ADC_SINGLE_ENDED) != HAL_OK) &#123;</span><br><span class="line">        Error_Handler();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//开启ADC使能中断</span></span><br><span class="line">    HAL_ADC_Start_IT(&amp;hadc1);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ADC转换完成后自动调用ADC中断回调函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">HAL_ADC_ConvCpltCallback</span><span class="params">(ADC_HandleTypeDef* hadc)</span> &#123;</span><br><span class="line">    <span class="comment">//获取ADC值并存储</span></span><br><span class="line">    ADC_Values = HAL_ADC_GetValue(hadc);</span><br><span class="line">    HAL_ADC_Start_IT(&amp;hadc1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>中断多通道扫描模式和上面差不多，只不过 Scan Conversion Mode 要设为Enable，基本和下面一致，只不过中断要开启。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/KAZAMA-DREAM/myproductpic/KAZAMABLOG/2025-03-12-HAL%E5%BA%93%E5%AE%9E%E7%8E%B0STM32%E7%9A%84ADC%E7%94%B5%E5%8E%8B%E9%87%87%E6%A0%B7%EF%BC%88%E8%BD%AE%E8%AF%A2%E3%80%81%E4%B8%AD%E6%96%AD%E3%80%81DMA%EF%BC%89/image-20250308014326987.png"></p>
<br/>



<h2 id="4-ADC-DMA采集数据"><a href="#4-ADC-DMA采集数据" class="headerlink" title="4    ADC + DMA采集数据"></a>4    ADC + DMA采集数据</h2><h3 id="4-1-DMA配置的一些知识"><a href="#4-1-DMA配置的一些知识" class="headerlink" title="4.1    DMA配置的一些知识"></a>4.1    DMA配置的一些知识</h3><p><strong>DMA的模式：</strong></p>
<ol>
<li><strong>Normal模式（不循环模式）：</strong>当一次DMA数据传输完后，停止DMA传送 ，也就是只传输一次。</li>
<li><strong>Circular模式（循环模式）：</strong>传输完成后又重新开始继续传输，不断循环永不停止。<strong>一般用于处理循环缓冲区和连续的数据传输（如ADC的扫描模式）。</strong></li>
</ol>
<p>当开启循环模式之后，数据传输的数目变为0时，将会自动地恢复成配置通道时设置的初值，DMA操作将会继续进行。</p>
<p><strong>data width（数据宽度）：</strong></p>
<ol>
<li>byte：字节，通用8位，与u8相同</li>
<li>word：字长，与硬件的位数相同，STM32是32位，所以对应是u32</li>
<li>Half Word：半个字长，所以对应是u16</li>
</ol>
<br/>



<h3 id="4-2-ADC单通道-DMA采集数据"><a href="#4-2-ADC单通道-DMA采集数据" class="headerlink" title="4.2    ADC单通道+DMA采集数据"></a>4.2    ADC单通道+DMA采集数据</h3><p><strong>DMA单通道 单次</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/KAZAMA-DREAM/myproductpic/KAZAMABLOG/2025-03-12-HAL%E5%BA%93%E5%AE%9E%E7%8E%B0STM32%E7%9A%84ADC%E7%94%B5%E5%8E%8B%E9%87%87%E6%A0%B7%EF%BC%88%E8%BD%AE%E8%AF%A2%E3%80%81%E4%B8%AD%E6%96%AD%E3%80%81DMA%EF%BC%89/image-20250308014645860.png"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/KAZAMA-DREAM/myproductpic/KAZAMABLOG/2025-03-12-HAL%E5%BA%93%E5%AE%9E%E7%8E%B0STM32%E7%9A%84ADC%E7%94%B5%E5%8E%8B%E9%87%87%E6%A0%B7%EF%BC%88%E8%BD%AE%E8%AF%A2%E3%80%81%E4%B8%AD%E6%96%AD%E3%80%81DMA%EF%BC%89/image-20250308014640219.png"></p>
<p>ADC的连续转换模式 + ADC的不扫描模式 + DMA的Normal模式。</p>
<p>为什么使用不循环模式呢？因为数据搬运到内存之后，需要先对内存进行一个操作，进行LCD显示结果之后，才进行下一轮采样。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/KAZAMA-DREAM/myproductpic/KAZAMABLOG/2025-03-12-HAL%E5%BA%93%E5%AE%9E%E7%8E%B0STM32%E7%9A%84ADC%E7%94%B5%E5%8E%8B%E9%87%87%E6%A0%B7%EF%BC%88%E8%BD%AE%E8%AF%A2%E3%80%81%E4%B8%AD%E6%96%AD%E3%80%81DMA%EF%BC%89/image-20250308015331781.png"></p>
<p><strong>方法一（只采样1次）</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint32_t</span> adc_value = <span class="number">0</span>;</span><br><span class="line"><span class="type">float</span> supercar_voltage = <span class="number">0.0</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">mian</span><span class="params">()</span> &#123;</span><br><span class="line">    HAL_ADC_Start_DMA(&amp;hadc1, adc_value, <span class="number">1</span>); <span class="comment">// 采样一个值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        HAL_ADC_Start(&amp;hadc1);                 <span class="comment">// 启动ADC转换</span></span><br><span class="line">        HAL_ADC_PollForConversion(&amp;hadc1, <span class="number">10</span>); <span class="comment">// 等待转换完成</span></span><br><span class="line">    </span><br><span class="line">        adc_value = HAL_ADC_GetValue(&amp;hadc1);</span><br><span class="line"></span><br><span class="line">        xsprintf(adcString1, <span class="string">&quot;adc:%u &quot;</span>, adc_value);</span><br><span class="line">        LCD_ShowString(<span class="number">4</span>, <span class="number">22</span>, ST7735Ctx.Width, LCD_FONT_SIZE, LCD_FONT_SIZE, adcString1);                 </span><br><span class="line">        xsprintf(adcString2, <span class="string">&quot;adcV:%.4f &quot;</span>, (<span class="type">float</span>)adc_value * (<span class="number">3.3</span> / <span class="number">4096</span>));              </span><br><span class="line">        LCD_ShowString(<span class="number">4</span>, <span class="number">42</span>, ST7735Ctx.Width, LCD_FONT_SIZE, LCD_FONT_SIZE, adcString2); </span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置的是Normal模式，下一次ADC和DMA采集要重新开启</span></span><br><span class="line">        HAL_ADC_Start_DMA(&amp;hadc1, ADC_Value, <span class="number">1</span>); </span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法二（连续采样10次取平均值）</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">uint32_t</span> sum;</span><br><span class="line">    <span class="type">uint32_t</span> ADC_Value[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> adcString1[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">char</span> adcString2[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 触发ADC转换，使用DMA传输数据，设置源地址、目标地址、传输数量</span></span><br><span class="line">    HAL_ADC_Start_DMA(&amp;hadc1, ADC_Value, <span class="number">10</span>); <span class="comment">// 采样10个值存储在ADC_Value[10]数组中</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (HAL_IS_BIT_SET(HAL_ADC_GetState(&amp;hadc1, HAL_ADC_STATE_REG_EOC))) &#123;</span><br><span class="line">            sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (= <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                sum += ADC_Value[i];</span><br><span class="line">            &#125;</span><br><span class="line">            sum /= <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// LCD显示结果</span></span><br><span class="line">            xsprintf(adcString1, <span class="string">&quot;adc:%u &quot;</span>, sum);</span><br><span class="line">            LCD_ShowString(<span class="number">4</span>, <span class="number">22</span>, ST7735Ctx.Width, LCD_FONT_SIZE, LCD_FONT_SIZE, adcString1);</span><br><span class="line">            xsprintf(adcString2, <span class="string">&quot;adcV:%.4f &quot;</span>, (<span class="type">float</span>)sum * (<span class="number">3.3</span> / <span class="number">4096</span>));</span><br><span class="line">            LCD_ShowString(<span class="number">4</span>, <span class="number">42</span>, ST7735Ctx.Width, LCD_FONT_SIZE, LCD_FONT_SIZE, adcString2);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//设置的是Normal模式，下一次ADC和DMA采集要重新开启</span></span><br><span class="line">            HAL_ADC_Start_DMA(&amp;hadc1, ADC_Value, <span class="number">10</span>); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<br/>



<h3 id="4-3-ADC多通道-DMA采集数据"><a href="#4-3-ADC多通道-DMA采集数据" class="headerlink" title="4.3    ADC多通道+DMA采集数据"></a>4.3    ADC多通道+DMA采集数据</h3><p>ADC的连续转换模式 + ADC的扫描模式（多通道）+ DMA的Normal模式</p>
<p>以下例子是使用6个通道，每个通道采集10次取平均值来减少误差：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">uint32_t</span> ADC_Value[<span class="number">60</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">uint8_t</span> dmaFlag = <span class="number">0</span>; <span class="comment">// 检查中断服务函数里面DMA搬运完成的标志位</span></span><br><span class="line">    <span class="type">char</span> adcString1[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">char</span> adcString2[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 触发ADC转换，使用DMA传输数据，设置源地址、目标地址、传输数量</span></span><br><span class="line">    HAL_ADC_Start_DMA(&amp;hadc1, ADC_Value, <span class="number">60</span>); <span class="comment">// 采样60个值存储在ADC_Value[60]数组中</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">1</span> == dmaFlag) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">6</span>; j++) &#123;</span><br><span class="line">                <span class="comment">// 遍历6个通道，轮流取值+显示</span></span><br><span class="line">                sum = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">60</span>; i++) &#123;</span><br><span class="line">                    sum + = ADC_Value[(<span class="number">6</span> * i) + j]; <span class="comment">// 每个通道采集l0次数据，进行10次累加</span></span><br><span class="line">                &#125;</span><br><span class="line">                sum = sum / <span class="number">10</span>; <span class="comment">// 取平均值</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// LCD显示结果</span></span><br><span class="line">                xsprintf(adcString1, <span class="string">&quot;adc:%u &quot;</span>, sum);</span><br><span class="line">                LCD_ShowString(<span class="number">4</span>, <span class="number">22</span>, ST7735Ctx.Width, LCD_FONT_SIZE, LCD_FONT_SIZE, adcString1);</span><br><span class="line">                xsprintf(adcString2, <span class="string">&quot;adcV:%.4f &quot;</span>, (<span class="type">float</span>)sum * (<span class="number">3.3f</span> / <span class="number">4096</span>)); <span class="comment">// 计算12位分辨率的实际电压值</span></span><br><span class="line">                LCD_ShowString(<span class="number">4</span>, <span class="number">42</span>, ST7735Ctx.Width, LCD_FONT_SIZE, LCD_FONT_SIZE, adcString2);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            dmaFlag = <span class="number">0</span>;                              <span class="comment">// 清除DMA采集完成标志位</span></span><br><span class="line">            HAL_ADC_Start_DMA(&amp;hadc1, ADC_Value, <span class="number">60</span>); <span class="comment">// 开启下一次ADC和DMA采集</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<br/>



<h3 id="4-4-ADC单通道-DMA采集数据（把12位转成16位分辨率）"><a href="#4-4-ADC单通道-DMA采集数据（把12位转成16位分辨率）" class="headerlink" title="4.4    ADC单通道+DMA采集数据（把12位转成16位分辨率）"></a>4.4    ADC单通道+DMA采集数据（把12位转成16位分辨率）</h3><p><strong>使用过采样和求均值的方式提高ADC的分辨率：</strong></p>
<p>例如：F1单片机最高只能采样12位的分辨率数据，但是现在需要采集16位的，为了节省成本而不想更换成H7单片机来采集16位的分辨率数据。此时，可以使用过采样的方法来提高分辨率。</p>
<p>公式：fos=(4^w)*fs  —&gt;fos是过采样频率，w是希望增加的分辨率位数，fs是初始采样频率要求</p>
<p>例如：本来是只有12位的分辨率：</p>
<ul>
<li>若提高1位分辨率，4fs，即采样4次后，把4次结果求和，再右移1位，就能得到13位分辨率的结果。</li>
<li>若提高2位分辨率，4^2fs=16fs，即采样16次后，把16次结果求和，再右移2位，就能得到14位分辨率的结果。</li>
<li>若提高3位分辨率，4^3fs=64fs，即采样64次后，把64次结果求和，再右移3位，就能得到15位分辨率的结果。</li>
<li>若提高4位分辨率，4^4fs=256fs，即采样256次后，把256次结果求和，再右移4位，就能得到16位分辨率的结果。</li>
</ul>
<p>注意：提示n位分辨率，需要右移n位。</p>
<p><strong>ADC单通道+DMA采集数据(把12位转成16位分辨率)：</strong>ADC的连续转换模式 + ADC的不扫描模式 + DMA的Normal模式</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">uint32_t</span> ADC_Value[<span class="number">2560</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">unit32_t</span> sum;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">char</span> adcString1[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">char</span> adcString2[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 触发ADC转换，使用DMA传输数据，设置源地址、目标地址、传输数量</span></span><br><span class="line">    HAL_ADC_Start_DMA(&amp;hadc1, ADC_Value, <span class="number">2560</span>); <span class="comment">// 采样10个值存储在ADC_Value[10]数组中</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">1</span> == dmaFlag) &#123;</span><br><span class="line">            sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">256</span> * <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="comment">// 用12位采集256次相当于16位的1次</span></span><br><span class="line">                sum += ADC_Value[i];</span><br><span class="line">            &#125;</span><br><span class="line">            sum /= <span class="number">10</span>;</span><br><span class="line">            sum &gt;&gt; = <span class="number">4</span>; <span class="comment">// 得到一个16位分辨率的值</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// LCD显示结果</span></span><br><span class="line">            xsprintf(adcString1, <span class="string">&quot;adc:%lu &quot;</span>, sum);</span><br><span class="line">            LCD_ShowString(<span class="number">4</span>, <span class="number">22</span>, ST7735Ctx.Width, LCD_FONT_SIZE, LCD_FONT_SIZE, adcString1);</span><br><span class="line">            xsprintf(adcString2, <span class="string">&quot;adcV:%.4f &quot;</span>, (<span class="type">float</span>)sum * (<span class="number">3.3</span> / <span class="number">65536</span>)); <span class="comment">// 计算16位分辨率的实际电压值</span></span><br><span class="line">            LCD_ShowString(<span class="number">4</span>, <span class="number">42</span>, ST7735Ctx.Width, LCD_FONT_SIZE, LCD_FONT_SIZE, adcString2);</span><br><span class="line"></span><br><span class="line">            dmaFlag = <span class="number">0</span>;                              <span class="comment">// 清除DMA采集完成标志位</span></span><br><span class="line">            HAL_ADC_Start_DMA(&amp;hadc1, ADC_Value, <span class="number">2560</span>); <span class="comment">// 开启下一次ADC和DMA采集</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<br/>



<h3 id="4-5-ADC多通道-DMA循环模式"><a href="#4-5-ADC多通道-DMA循环模式" class="headerlink" title="4.5    ADC多通道+DMA循环模式"></a>4.5    ADC多通道+DMA循环模式</h3><h4 id="4-5-1-流程"><a href="#4-5-1-流程" class="headerlink" title="4.5.1    流程"></a>4.5.1    流程</h4><ol>
<li>启动ADC。</li>
<li>配置DMA缓冲区。</li>
<li>读取缓冲区数据。</li>
</ol>
<br/>



<h4 id="4-5-2-STM32CubeMX配置"><a href="#4-5-2-STM32CubeMX配置" class="headerlink" title="4.5.2    STM32CubeMX配置"></a>4.5.2    STM32CubeMX配置</h4><p>开启ADC1的通道1和2.</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/KAZAMA-DREAM/myproductpic/KAZAMABLOG/2025-03-12-HAL%E5%BA%93%E5%AE%9E%E7%8E%B0STM32%E7%9A%84ADC%E7%94%B5%E5%8E%8B%E9%87%87%E6%A0%B7%EF%BC%88%E8%BD%AE%E8%AF%A2%E3%80%81%E4%B8%AD%E6%96%AD%E3%80%81DMA%EF%BC%89/29149c2b501bccf831113fcfaf982359.png"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/KAZAMA-DREAM/myproductpic/KAZAMABLOG/2025-03-12-HAL%E5%BA%93%E5%AE%9E%E7%8E%B0STM32%E7%9A%84ADC%E7%94%B5%E5%8E%8B%E9%87%87%E6%A0%B7%EF%BC%88%E8%BD%AE%E8%AF%A2%E3%80%81%E4%B8%AD%E6%96%AD%E3%80%81DMA%EF%BC%89/image-20250308015912380.png"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/KAZAMA-DREAM/myproductpic/KAZAMABLOG/2025-03-12-HAL%E5%BA%93%E5%AE%9E%E7%8E%B0STM32%E7%9A%84ADC%E7%94%B5%E5%8E%8B%E9%87%87%E6%A0%B7%EF%BC%88%E8%BD%AE%E8%AF%A2%E3%80%81%E4%B8%AD%E6%96%AD%E3%80%81DMA%EF%BC%89/419017536885605b0339593a5e079910.png"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/KAZAMA-DREAM/myproductpic/KAZAMABLOG/2025-03-12-HAL%E5%BA%93%E5%AE%9E%E7%8E%B0STM32%E7%9A%84ADC%E7%94%B5%E5%8E%8B%E9%87%87%E6%A0%B7%EF%BC%88%E8%BD%AE%E8%AF%A2%E3%80%81%E4%B8%AD%E6%96%AD%E3%80%81DMA%EF%BC%89/0f288b8134c5408e714dec59ffde233e.png"></p>
<br/>



<h4 id="4-5-3-软件代码"><a href="#4-5-3-软件代码" class="headerlink" title="4.5.3    软件代码"></a>4.5.3    软件代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="comment">/* USER CODE BEGIN 1 */</span></span><br><span class="line">  <span class="type">uint16_t</span> ADC_Value1,i;</span><br><span class="line">  <span class="type">uint16_t</span> AD_Buf[<span class="number">2</span>] = &#123;<span class="number">0</span>&#125;;<span class="comment">//两个通道采集数据存在这个数组里面</span></span><br><span class="line">  <span class="comment">/* USER CODE END 1 */</span></span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* MCU Configuration--------------------------------------------------------*/</span></span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* Reset of all peripherals, Initializes the Flash interface and the Systick. */</span></span><br><span class="line">  HAL_Init();</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* USER CODE BEGIN Init */</span></span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* USER CODE END Init */</span></span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* Configure the system clock */</span></span><br><span class="line">  SystemClock_Config();</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* USER CODE BEGIN SysInit */</span></span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* USER CODE END SysInit */</span></span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* Initialize all configured peripherals */</span></span><br><span class="line">  MX_GPIO_Init();</span><br><span class="line">  MX_USART1_UART_Init();</span><br><span class="line">  MX_DMA_Init();</span><br><span class="line">  MX_ADC1_Init();</span><br><span class="line">  <span class="comment">/* USER CODE BEGIN 2 */</span></span><br><span class="line">  HAL_ADCEx_Calibration_Start(&amp;hadc1);</span><br><span class="line">  HAL_ADC_Start_DMA(&amp;hadc1, (<span class="type">uint32_t</span> *)&amp;AD_Buf, <span class="number">2</span>);<span class="comment">//开启ADC的DMA，采集的数据直接放入AD_Buf这个数组里，操作简单。</span></span><br><span class="line">  <span class="comment">/* USER CODE END 2 */</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">HAL_ADC_ConvCpltCallback</span><span class="params">(ADC_HandleTypeDef* hadc)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(hadc-&gt;Instance == ADC1) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;AD1=%d\n\r&quot;</span>, AD_Buf[<span class="number">0</span>]);</span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">&quot;AD2=%d\n\r&quot;</span>, AD_Buf[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>ADC的DMA模式小总结：DMA模式最简单，并且采样过程基本不会影响CPU，一般使用ADC的DMA模式进行采样。</strong></p>
<br/>



<h2 id="5-使用定时器触发的AD转换"><a href="#5-使用定时器触发的AD转换" class="headerlink" title="5    使用定时器触发的AD转换"></a>5    使用定时器触发的AD转换</h2><p>在大多数应用中，并不需要连续的对数据进行采样，更多的场合是在需要进行ADC采样时触发一次采样。接下来，对上述配置进行修改，实现通过定时器触发AD转换。</p>
<p>想要实现通过定时器触发AD转换，只需要在外部触发源里面挑选一个定时器通道，此处选择timer2 compare2，即定时器2的2通道，<strong>想要让触发信号生效，需要在定时器2的2通道产生一个上升沿</strong>，此处把定时器2的2通道配置为pwm模式以实现电平变化。<strong>此时不在需要ADC进行转换，把连续转换模式设为关闭</strong>。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/KAZAMA-DREAM/myproductpic/KAZAMABLOG/2025-03-12-HAL%E5%BA%93%E5%AE%9E%E7%8E%B0STM32%E7%9A%84ADC%E7%94%B5%E5%8E%8B%E9%87%87%E6%A0%B7%EF%BC%88%E8%BD%AE%E8%AF%A2%E3%80%81%E4%B8%AD%E6%96%AD%E3%80%81DMA%EF%BC%89/47497d958605bc48b6f191982708dcbe.png"></p>
<p>tim2配置如下，使能通道2，并配置为pwm模式，根据想要的采样频率配置分频系数psc以及计数周期arr。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/KAZAMA-DREAM/myproductpic/KAZAMABLOG/2025-03-12-HAL%E5%BA%93%E5%AE%9E%E7%8E%B0STM32%E7%9A%84ADC%E7%94%B5%E5%8E%8B%E9%87%87%E6%A0%B7%EF%BC%88%E8%BD%AE%E8%AF%A2%E3%80%81%E4%B8%AD%E6%96%AD%E3%80%81DMA%EF%BC%89/7c930262c58a72337adc1a93b843f02f.png"></p>
<p>其他配置保持不变。根据上述配置，cube生成ADC初始化代码。</p>
<p>需要注意的是，cube生成的定时器初始化代码中不包含使能定时器以及使能pwm输出代码，需要添加使能配置。代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HAL_TIM_Base_Start_IT(&amp;htim2);</span><br><span class="line">HAL_TIM_PWM_Start(&amp;htim2,TIM_CHANNEL_2);</span><br></pre></td></tr></table></figure>



<br/>



<h2 id="6-相关函数"><a href="#6-相关函数" class="headerlink" title="6    相关函数"></a>6    相关函数</h2><h3 id="6-1-回调函数"><a href="#6-1-回调函数" class="headerlink" title="6.1    回调函数"></a>6.1    回调函数</h3><p><code>HAL_ADC_ConvCpltCallback(ADC_HandleTypeDef* hadc)</code>：当 ADC 完成一次转换时，会调用这个回调函数。</p>
<p><code>HAL_ADC_ConvHalfCpltCallback(ADC_HandleTypeDef* hadc)</code>：当 ADC 完成半个转换缓冲区的转换时，会调用这个回调函数。注意这个回调函数只在 DMA 转换模式下有效，且需要启用 DMA 半传输完成中断。</p>
<p><code>HAL_ADC_ErrorCallback(ADC_HandleTypeDef *hadc)</code>：当 ADC 遇到错误时，会调用这个回调函数。</p>
<p><code>HAL_ADC_LevelOutOfWindowCallback(ADC_HandleTypeDef* hadc)</code>：当 ADC 的转换结果超出窗口阈值时，会调用这个回调函数。</p>
<p><code>HAL_ADC_EndOfConversionCallback(ADC_HandleTypeDef* hadc)</code>：当 ADC 完成所有的转换序列时，会调用这个回调函数。</p>
<p><code>HAL_ADC_InjConvCpltCallback(ADC_HandleTypeDef* hadc)</code>：当注入组转换完成时，会调用这个回调函数。</p>
<br/>



<h3 id="6-2-普通函数"><a href="#6-2-普通函数" class="headerlink" title="6.2    普通函数"></a>6.2    普通函数</h3><p><strong>开启ADC 3种模式 ( 轮询模式 中断模式 DMA模式 ）</strong></p>
<p>• HAL_ADC_Start(&amp;hadcx);       //轮询模式开启ADC<br>• HAL_ADC_Start_IT(&amp;hadcx);       //中断轮询模式开启ADC<br>• HAL_ADC_Start_DMA(&amp;hadcx)；       //DMA模式开启ADC</p>
<p><strong>关闭ADC 3种模式 ( 轮询模式 中断模式 DMA模式 ）</strong></p>
<p>• HAL_ADC_Stop()<br>• HAL_ADC_Stop_IT()<br>• HAL_ADC_Stop_DMA()</p>
<p><strong>ADC校准函数 ：</strong></p>
<p>• HAL_ADCEx_Calibration_Start(&amp;hadcx);      //F4系列不支持</p>
<p><strong>读取ADC转换值</strong></p>
<p>• HAL_ADC_GetValue()</p>
<p><strong>等待转换结束函数</strong></p>
<p>• HAL_ADC_PollForConversion(&amp;hadc1, 50);</p>
<p>第一个参数为那个ADC，第二个参数为最大等待时间</p>
<p><strong>ADC中断回调函数</strong></p>
<p>• HAL_ADC_ConvCpltCallback()</p>
<p>转换完成后回调，DMA模式下DMA传输完成后调用。</p>
<p><strong>规则通道及看门狗配置</strong></p>
<p>• HAL_ADC_ConfigChannel() //配置规则组通道<br>• HAL_ADC_AnalogWDGConfig(）</p>
<br/>



<h2 id="7-小细节"><a href="#7-小细节" class="headerlink" title="7    小细节"></a>7    小细节</h2><p>F4系列芯片没有代码校准的方式。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://www.kazama.top">KAZAMA</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://www.kazama.top/2025/03/12/HAL%E5%BA%93%E5%AE%9E%E7%8E%B0STM32%E7%9A%84ADC%E7%94%B5%E5%8E%8B%E9%87%87%E6%A0%B7%EF%BC%88%E8%BD%AE%E8%AF%A2%E3%80%81%E4%B8%AD%E6%96%AD%E3%80%81DMA%EF%BC%89/">http://www.kazama.top/2025/03/12/HAL%E5%BA%93%E5%AE%9E%E7%8E%B0STM32%E7%9A%84ADC%E7%94%B5%E5%8E%8B%E9%87%87%E6%A0%B7%EF%BC%88%E8%BD%AE%E8%AF%A2%E3%80%81%E4%B8%AD%E6%96%AD%E3%80%81DMA%EF%BC%89/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://www.kazama.top" target="_blank">KAZAMAのBlog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/STM32/">STM32</a></div><div class="post_share"><div class="social-share" data-image="https://api.r10086.com/樱道随机图片api接口.php?图片系列=风景系列7" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/wechat.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/alipay.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2024/12/09/%E5%A6%82%E4%BD%95%E5%AF%B9stm32%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%BF%9B%E8%A1%8C%E5%8A%A0%E5%AF%86/" title="如何对stm32的程序进行加密"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://api.r10086.com/樱道随机图片api接口.php?图片系列=风景系列6" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">如何对stm32的程序进行加密</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2024/11/26/Keil5%E8%B0%83%E8%AF%95%E6%97%B6peripherals%E4%B8%8D%E6%98%BE%E7%A4%BA%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/" title="Keil5调试时peripherals不显示的解决方法"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://api.r10086.com/樱道随机图片api接口.php?图片系列=风景系列3" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-11-26</div><div class="title">Keil5调试时peripherals不显示的解决方法</div></div></a></div><div><a href="/2024/11/25/%E3%80%90STM32%20HAL%E5%BA%93%E5%AE%9E%E6%88%98%E3%80%91%E4%B8%B2%E5%8F%A3DMA+%E7%A9%BA%E9%97%B2%E4%B8%AD%E6%96%AD%E5%AE%9E%E7%8E%B0%E4%B8%8D%E5%AE%9A%E9%95%BF%E6%95%B0%E6%8D%AE%E6%8E%A5%E6%94%B6/" title="【STM32 HAL库实战】串口DMA+空闲中断实现不定长数据接收"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://api.r10086.com/樱道随机图片api接口.php?图片系列=风景系列2" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-11-25</div><div class="title">【STM32 HAL库实战】串口DMA+空闲中断实现不定长数据接收</div></div></a></div><div><a href="/2024/12/01/STM32%E8%AF%BB%E5%8F%96%E8%8A%AF%E7%89%87%E5%94%AF%E4%B8%80%E7%A0%81UID/" title="STM32读取芯片唯一码UID"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://api.r10086.com/樱道随机图片api接口.php?图片系列=风景系列8" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-12-01</div><div class="title">STM32读取芯片唯一码UID</div></div></a></div><div><a href="/2024/12/05/STM32F103%20USB%E5%AE%9E%E7%8E%B0%E8%99%9A%E6%8B%9F%E4%B8%B2%E5%8F%A3/" title="STM32F103 USB实现虚拟串口"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://api.r10086.com/樱道随机图片api接口.php?图片系列=风景系列2" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-12-05</div><div class="title">STM32F103 USB实现虚拟串口</div></div></a></div><div><a href="/2024/12/06/Keil%E7%94%9F%E6%88%90%E7%9A%84Map%E6%96%87%E4%BB%B6%E5%88%86%E6%9E%90%E5%8F%8A%E5%AD%98%E5%82%A8%E4%BD%BF%E7%94%A8%E6%83%85%E5%86%B5%E5%88%86%E6%9E%90/" title="Keil生成的Map文件分析及存储使用情况分析"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://api.r10086.com/樱道随机图片api接口.php?图片系列=风景系列3" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-12-06</div><div class="title">Keil生成的Map文件分析及存储使用情况分析</div></div></a></div><div><a href="/2024/12/09/%E5%A6%82%E4%BD%95%E5%AF%B9stm32%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%BF%9B%E8%A1%8C%E5%8A%A0%E5%AF%86/" title="如何对stm32的程序进行加密"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://api.r10086.com/樱道随机图片api接口.php?图片系列=风景系列6" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-12-09</div><div class="title">如何对stm32的程序进行加密</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://api.r10086.com/樱道随机图片api接口.php?图片系列=风景系列3" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">KAZAMA</div><div class="author-info__description">技术记录,个人分享,学习备忘</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">425</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">49</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/KAZAMA-DREAM"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/KAZAMA-DREAM" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="/wyy1778789301@163.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#HAL%E5%BA%93%E5%AE%9E%E7%8E%B0STM32%E7%9A%84ADC%E7%94%B5%E5%8E%8B%E9%87%87%E6%A0%B7%EF%BC%88%E8%BD%AE%E8%AF%A2%E3%80%81%E4%B8%AD%E6%96%AD%E3%80%81DMA%EF%BC%89"><span class="toc-text">HAL库实现STM32的ADC电压采样（轮询、中断、DMA）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-ADC%E5%8A%9F%E8%83%BD%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-text">1    ADC功能的基础知识</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-ADC%E7%9A%84%E4%B8%89%E7%A7%8D%E5%B7%A5%E4%BD%9C%E6%96%B9%E5%BC%8F%E5%8F%8A%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-text">1.1    ADC的三种工作方式及优缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-ADC%E7%9A%84%E8%BD%AC%E6%8D%A2%E6%96%B9%E5%BC%8F"><span class="toc-text">1.2    ADC的转换方式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-ADC%E5%8D%95%E9%80%9A%E9%81%93-%E8%BD%AE%E8%AF%A2%E6%A8%A1%E5%BC%8F-%E9%98%BB%E5%A1%9E%E6%A8%A1%E5%BC%8F"><span class="toc-text">2    ADC单通道+轮询模式(阻塞模式)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E6%93%8D%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-text">2.1    操作流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-STM32CubeMX%E9%85%8D%E7%BD%AE%E6%B5%81%E7%A8%8B"><span class="toc-text">2.2    STM32CubeMX配置流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E8%BD%AF%E4%BB%B6%E4%BB%A3%E7%A0%81"><span class="toc-text">2.3    软件代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%A4%9A%E9%80%9A%E9%81%93%E6%9F%A5%E8%AF%A2%E6%A8%A1%E5%BC%8F"><span class="toc-text">3    多通道查询模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-STM32CubeMX%E9%85%8D%E7%BD%AE"><span class="toc-text">3.1    STM32CubeMX配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E8%BD%AF%E4%BB%B6%E4%BB%A3%E7%A0%81"><span class="toc-text">3.2    软件代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-ADC%E4%B8%AD%E6%96%AD%E6%A8%A1%E5%BC%8F%EF%BC%88%E5%8D%95%E9%80%9A%E9%81%93%EF%BC%89"><span class="toc-text">4    ADC中断模式（单通道）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E6%B5%81%E7%A8%8B"><span class="toc-text">4.1    流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-STM32CubeMX%E9%85%8D%E7%BD%AE"><span class="toc-text">4.2    STM32CubeMX配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-%E8%BD%AF%E4%BB%B6%E4%BB%A3%E7%A0%81"><span class="toc-text">4.3    软件代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-ADC-DMA%E9%87%87%E9%9B%86%E6%95%B0%E6%8D%AE"><span class="toc-text">4    ADC + DMA采集数据</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-DMA%E9%85%8D%E7%BD%AE%E7%9A%84%E4%B8%80%E4%BA%9B%E7%9F%A5%E8%AF%86"><span class="toc-text">4.1    DMA配置的一些知识</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-ADC%E5%8D%95%E9%80%9A%E9%81%93-DMA%E9%87%87%E9%9B%86%E6%95%B0%E6%8D%AE"><span class="toc-text">4.2    ADC单通道+DMA采集数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-ADC%E5%A4%9A%E9%80%9A%E9%81%93-DMA%E9%87%87%E9%9B%86%E6%95%B0%E6%8D%AE"><span class="toc-text">4.3    ADC多通道+DMA采集数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-ADC%E5%8D%95%E9%80%9A%E9%81%93-DMA%E9%87%87%E9%9B%86%E6%95%B0%E6%8D%AE%EF%BC%88%E6%8A%8A12%E4%BD%8D%E8%BD%AC%E6%88%9016%E4%BD%8D%E5%88%86%E8%BE%A8%E7%8E%87%EF%BC%89"><span class="toc-text">4.4    ADC单通道+DMA采集数据（把12位转成16位分辨率）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-ADC%E5%A4%9A%E9%80%9A%E9%81%93-DMA%E5%BE%AA%E7%8E%AF%E6%A8%A1%E5%BC%8F"><span class="toc-text">4.5    ADC多通道+DMA循环模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-5-1-%E6%B5%81%E7%A8%8B"><span class="toc-text">4.5.1    流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-5-2-STM32CubeMX%E9%85%8D%E7%BD%AE"><span class="toc-text">4.5.2    STM32CubeMX配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-5-3-%E8%BD%AF%E4%BB%B6%E4%BB%A3%E7%A0%81"><span class="toc-text">4.5.3    软件代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E4%BD%BF%E7%94%A8%E5%AE%9A%E6%97%B6%E5%99%A8%E8%A7%A6%E5%8F%91%E7%9A%84AD%E8%BD%AC%E6%8D%A2"><span class="toc-text">5    使用定时器触发的AD转换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0"><span class="toc-text">6    相关函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0"><span class="toc-text">6.1    回调函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0"><span class="toc-text">6.2    普通函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E5%B0%8F%E7%BB%86%E8%8A%82"><span class="toc-text">7    小细节</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/03/12/HAL%E5%BA%93%E5%AE%9E%E7%8E%B0STM32%E7%9A%84ADC%E7%94%B5%E5%8E%8B%E9%87%87%E6%A0%B7%EF%BC%88%E8%BD%AE%E8%AF%A2%E3%80%81%E4%B8%AD%E6%96%AD%E3%80%81DMA%EF%BC%89/" title="HAL库实现STM32的ADC电压采样（轮询、中断、DMA）"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://api.r10086.com/樱道随机图片api接口.php?图片系列=风景系列7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="HAL库实现STM32的ADC电压采样（轮询、中断、DMA）"/></a><div class="content"><a class="title" href="/2025/03/12/HAL%E5%BA%93%E5%AE%9E%E7%8E%B0STM32%E7%9A%84ADC%E7%94%B5%E5%8E%8B%E9%87%87%E6%A0%B7%EF%BC%88%E8%BD%AE%E8%AF%A2%E3%80%81%E4%B8%AD%E6%96%AD%E3%80%81DMA%EF%BC%89/" title="HAL库实现STM32的ADC电压采样（轮询、中断、DMA）">HAL库实现STM32的ADC电压采样（轮询、中断、DMA）</a><time datetime="2025-03-12T12:17:07.000Z" title="发表于 2025-03-12 20:17:07">2025-03-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/12/09/%E5%A6%82%E4%BD%95%E5%AF%B9stm32%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%BF%9B%E8%A1%8C%E5%8A%A0%E5%AF%86/" title="如何对stm32的程序进行加密"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://api.r10086.com/樱道随机图片api接口.php?图片系列=风景系列6" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="如何对stm32的程序进行加密"/></a><div class="content"><a class="title" href="/2024/12/09/%E5%A6%82%E4%BD%95%E5%AF%B9stm32%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%BF%9B%E8%A1%8C%E5%8A%A0%E5%AF%86/" title="如何对stm32的程序进行加密">如何对stm32的程序进行加密</a><time datetime="2024-12-09T12:17:07.000Z" title="发表于 2024-12-09 20:17:07">2024-12-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/12/08/%E5%91%8A%E5%88%AB%E5%8E%9F%E5%A7%8BUI%E6%A0%B7%E5%BC%8F%EF%BC%8C%E6%8B%A5%E6%8A%B1Fluent%20Design%E9%A3%8E%E6%A0%BCPyQt%20%20PySide%E7%BB%84%E4%BB%B6%E5%BA%93/" title="告别原始UI样式，拥抱Fluent Design风格PyQt / PySide组件库"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://api.r10086.com/樱道随机图片api接口.php?图片系列=风景系列5" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="告别原始UI样式，拥抱Fluent Design风格PyQt / PySide组件库"/></a><div class="content"><a class="title" href="/2024/12/08/%E5%91%8A%E5%88%AB%E5%8E%9F%E5%A7%8BUI%E6%A0%B7%E5%BC%8F%EF%BC%8C%E6%8B%A5%E6%8A%B1Fluent%20Design%E9%A3%8E%E6%A0%BCPyQt%20%20PySide%E7%BB%84%E4%BB%B6%E5%BA%93/" title="告别原始UI样式，拥抱Fluent Design风格PyQt / PySide组件库">告别原始UI样式，拥抱Fluent Design风格PyQt / PySide组件库</a><time datetime="2024-12-08T12:17:07.000Z" title="发表于 2024-12-08 20:17:07">2024-12-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/12/07/Python%E8%AE%BE%E8%AE%A1%E5%8F%AF%E8%A7%86%E5%8C%96%E5%BA%93/" title="Python设计可视化库"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://api.r10086.com/樱道随机图片api接口.php?图片系列=风景系列4" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Python设计可视化库"/></a><div class="content"><a class="title" href="/2024/12/07/Python%E8%AE%BE%E8%AE%A1%E5%8F%AF%E8%A7%86%E5%8C%96%E5%BA%93/" title="Python设计可视化库">Python设计可视化库</a><time datetime="2024-12-07T12:17:07.000Z" title="发表于 2024-12-07 20:17:07">2024-12-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/12/06/Keil%E7%94%9F%E6%88%90%E7%9A%84Map%E6%96%87%E4%BB%B6%E5%88%86%E6%9E%90%E5%8F%8A%E5%AD%98%E5%82%A8%E4%BD%BF%E7%94%A8%E6%83%85%E5%86%B5%E5%88%86%E6%9E%90/" title="Keil生成的Map文件分析及存储使用情况分析"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://api.r10086.com/樱道随机图片api接口.php?图片系列=风景系列3" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Keil生成的Map文件分析及存储使用情况分析"/></a><div class="content"><a class="title" href="/2024/12/06/Keil%E7%94%9F%E6%88%90%E7%9A%84Map%E6%96%87%E4%BB%B6%E5%88%86%E6%9E%90%E5%8F%8A%E5%AD%98%E5%82%A8%E4%BD%BF%E7%94%A8%E6%83%85%E5%86%B5%E5%88%86%E6%9E%90/" title="Keil生成的Map文件分析及存储使用情况分析">Keil生成的Map文件分析及存储使用情况分析</a><time datetime="2024-12-06T12:17:07.000Z" title="发表于 2024-12-06 20:17:07">2024-12-06</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://api.r10086.com/樱道随机图片api接口.php?图片系列=风景系列7')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025 By KAZAMA</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"></div><canvas class="fireworks" mobile="true"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = true;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>