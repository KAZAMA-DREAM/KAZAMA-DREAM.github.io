<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>Python核心要点 | KAZAMAのBlog</title><meta name="author" content="KAZAMA,wyy1778789301@163.com"><meta name="copyright" content="KAZAMA"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="本篇主要介绍Python语法的重点知识">
<meta property="og:type" content="article">
<meta property="og:title" content="Python核心要点">
<meta property="og:url" content="http://www.kazama.top/2022/12/21/Python%E6%A0%B8%E5%BF%83%E8%A6%81%E7%82%B9/2022-12-21-Python%E6%A0%B8%E5%BF%83%E8%A6%81%E7%82%B9/index.html">
<meta property="og:site_name" content="KAZAMAのBlog">
<meta property="og:description" content="本篇主要介绍Python语法的重点知识">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://api.r10086.com/樱道随机图片api接口.php?图片系列=风景系列5">
<meta property="article:published_time" content="2022-12-21T12:17:07.000Z">
<meta property="article:modified_time" content="2023-05-24T16:00:00.000Z">
<meta property="article:author" content="KAZAMA">
<meta property="article:tag" content="Python">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://api.r10086.com/樱道随机图片api接口.php?图片系列=风景系列5"><link rel="shortcut icon" href="https://api.r10086.com/樱道随机图片api接口.php?图片系列=风景系列1"><link rel="canonical" href="http://www.kazama.top/2022/12/21/Python%E6%A0%B8%E5%BF%83%E8%A6%81%E7%82%B9/2022-12-21-Python%E6%A0%B8%E5%BF%83%E8%A6%81%E7%82%B9/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Python核心要点',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-05-25 00:00:00'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = url => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      link.onload = () => resolve()
      link.onerror = () => reject()
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.2"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://api.r10086.com/樱道随机图片api接口.php?图片系列=风景系列3" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">341</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">19</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/share/"><i class="fa-fw fa fa-comments-o"></i><span> 分享</span></a></li><li><a class="site-page child" href="/photos/"><i class="fa-fw fa fa-camera-retro"></i><span> 相册</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 影视</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://api.r10086.com/樱道随机图片api接口.php?图片系列=风景系列5')"><nav id="nav"><span id="blog-info"><a href="/" title="KAZAMAのBlog"><span class="site-name">KAZAMAのBlog</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/share/"><i class="fa-fw fa fa-comments-o"></i><span> 分享</span></a></li><li><a class="site-page child" href="/photos/"><i class="fa-fw fa fa-camera-retro"></i><span> 相册</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 影视</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Python核心要点</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-12-21T12:17:07.000Z" title="发表于 2022-12-21 20:17:07">2022-12-21</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-05-24T16:00:00.000Z" title="更新于 2023-05-25 00:00:00">2023-05-25</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">50.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>198分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Python核心要点"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Python核心要点"><a href="#Python核心要点" class="headerlink" title="Python核心要点"></a>Python核心要点</h1><h2 id="1、python基础"><a href="#1、python基础" class="headerlink" title="1、python基础"></a>1、python基础</h2><h5 id="【1】直接运行py文件"><a href="#【1】直接运行py文件" class="headerlink" title="【1】直接运行py文件"></a>【1】直接运行py文件</h5><p>能不能像.exe文件那样直接运行<code>.py</code>文件呢？在Windows上是不行的，但是，在Mac和Linux上是可以的，方法是在<code>.py</code>文件的第一行加上一个特殊的注释：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;hello, world&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>然后，通过命令给<code>hello.py</code>以执行权限：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod a+x hello.py</span><br></pre></td></tr></table></figure>

<p>就可以直接运行<code>hello.py</code>了</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./hello.py</span><br></pre></td></tr></table></figure>

<h5 id="【2】浮点数"><a href="#【2】浮点数" class="headerlink" title="【2】浮点数"></a>【2】浮点数</h5><p>浮点数也就是小数，之所以称为浮点数，是因为按照科学记数法表示时，一个浮点数的小数点位置是可变的，比如，1.23x109和12.3x108是完全相等的。浮点数可以用数学写法，如<code>1.23</code>，<code>3.14</code>，<code>-9.01</code>，等等。但是对于很大或很小的浮点数，就必须用科学计数法表示，把10用e替代，1.23x109就是<code>1.23e9</code>，或者<code>12.3e8</code>，0.000012可以写成<code>1.2e-5</code>，等等。</p>
<h5 id="【3】字符串"><a href="#【3】字符串" class="headerlink" title="【3】字符串"></a>【3】字符串</h5><p>如果字符串里面有很多字符都需要转义，就需要加很多<code>\</code>，为了简化，Python还允许用<code>r&#39;&#39;</code>表示<code>&#39;&#39;</code>内部的字符串默认不转义，可以自己试试：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">&#x27;\\\t\\&#x27;</span>)</span><br><span class="line">\       \</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">r&#x27;\\\t\\&#x27;</span>)</span><br><span class="line">\\\t\\</span><br></pre></td></tr></table></figure>

<p>对于单个字符的编码，Python提供了<code>ord()</code>函数获取字符的整数表示，<code>chr()</code>函数把编码转换为对应的字符：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">ord</span>(<span class="string">&#x27;A&#x27;</span>)</span><br><span class="line"><span class="number">65</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">ord</span>(<span class="string">&#x27;中&#x27;</span>)</span><br><span class="line"><span class="number">20013</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">chr</span>(<span class="number">66</span>)</span><br><span class="line"><span class="string">&#x27;B&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">chr</span>(<span class="number">25991</span>)</span><br><span class="line"><span class="string">&#x27;文&#x27;</span></span><br><span class="line"><span class="comment"># 如果知道字符的整数编码，还可以用十六进制这么写str：</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;\u4e2d\u6587&#x27;</span></span><br><span class="line"><span class="string">&#x27;中文&#x27;</span></span><br></pre></td></tr></table></figure>

<p>如果<code>bytes</code>中只有一小部分无效的字节，可以传入<code>errors=&#39;ignore&#39;</code>忽略错误的字节：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">b&#x27;\xe4\xb8\xad\xff&#x27;</span>.decode(<span class="string">&#x27;utf-8&#x27;</span>, errors=<span class="string">&#x27;ignore&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;中&#x27;</span></span><br></pre></td></tr></table></figure>

<p>要计算<code>str</code>包含多少个字符，可以用<code>len()</code>函数，<code>len()</code>函数计算的是<code>str</code>的字符数，如果换成<code>bytes</code>，<code>len()</code>函数就计算字节数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">len</span>(<span class="string">&#x27;ABC&#x27;</span>)</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">len</span>(<span class="string">&#x27;中文&#x27;</span>)</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">len</span>(<span class="string">b&#x27;ABC&#x27;</span>)</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">len</span>(<span class="string">b&#x27;\xe4\xb8\xad\xe6\x96\x87&#x27;</span>)</span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">len</span>(<span class="string">&#x27;中文&#x27;</span>.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure>

<p>由于Python源代码也是一个文本文件，所以，当你的源代码中包含中文的时候，在保存源代码时，就需要务必指定保存为UTF-8编码。当Python解释器读取源代码时，为了让它按UTF-8编码读取，我们通常在文件开头写上这两行：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br></pre></td></tr></table></figure>

<p>只要<code>x</code>是非零数值、非空字符串、非空list等，就判断为<code>True</code>，否则为<code>False</code>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> x:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;True&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>如果要针对某个变量匹配若干种情况，可以使用<code>match</code>语句。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用match语句时，我们依次用case xxx匹配，并且可以在最后（且仅能在最后）加一个case _表示“任意值”，代码较if ... elif ... else ...更易读。</span></span><br><span class="line">score = <span class="string">&#x27;B&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">match</span> score:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;A&#x27;</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;score is A.&#x27;</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;B&#x27;</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;score is B.&#x27;</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;C&#x27;</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;score is C.&#x27;</span>)</span><br><span class="line">    <span class="keyword">case</span> _: <span class="comment"># _表示匹配到其他任何情况</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;score is ???.&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>match</code>语句除了可以匹配简单的单个值外，还可以匹配多个值、匹配一定范围，并且把匹配后的值绑定到变量：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">age = <span class="number">15</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">match</span> age:</span><br><span class="line">    <span class="keyword">case</span> x <span class="keyword">if</span> x &lt; <span class="number">10</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;&lt; 10 years old: <span class="subst">&#123;x&#125;</span>&#x27;</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;10 years old.&#x27;</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="number">11</span> | <span class="number">12</span> | <span class="number">13</span> | <span class="number">14</span> | <span class="number">15</span> | <span class="number">16</span> | <span class="number">17</span> | <span class="number">18</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;11~18 years old.&#x27;</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="number">19</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;19 years old.&#x27;</span>)</span><br><span class="line">    <span class="keyword">case</span> _:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;not sure.&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p><code>match</code>语句还可以匹配列表，功能非常强大。</p>
<p>我们假设用户输入了一个命令，用<code>args = [&#39;gcc&#39;, &#39;hello.c&#39;]</code>存储，下面的代码演示了如何用<code>match</code>匹配来解析这个列表：</p>
<p>第一个<code>case [&#39;gcc&#39;]</code>表示列表仅有<code>&#39;gcc&#39;</code>一个字符串，没有指定文件名，报错；</p>
<p>第二个<code>case [&#39;gcc&#39;, file1, *files]</code>表示列表第一个字符串是<code>&#39;gcc&#39;</code>，第二个字符串绑定到变量<code>file1</code>，后面的任意个字符串绑定到<code>*files</code>（符号<code>*</code>的作用将在<a target="_blank" rel="noopener" href="https://www.liaoxuefeng.com/wiki/1016959663602400/1017261630425888">函数的参数</a>中讲解），它实际上表示至少指定一个文件；</p>
<p>第三个<code>case [&#39;clean&#39;]</code>表示列表仅有<code>&#39;clean&#39;</code>一个字符串；</p>
<p>最后一个<code>case _</code>表示其他所有情况。</p>
<p>可见，<code>match</code>语句的匹配规则非常灵活，可以写出非常简洁的代码。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">args = [<span class="string">&#x27;gcc&#x27;</span>, <span class="string">&#x27;hello.c&#x27;</span>, <span class="string">&#x27;world.c&#x27;</span>]</span><br><span class="line"><span class="comment"># args = [&#x27;clean&#x27;]</span></span><br><span class="line"><span class="comment"># args = [&#x27;gcc&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">match</span> args:</span><br><span class="line">    <span class="comment"># 如果仅出现gcc，报错:</span></span><br><span class="line">    <span class="keyword">case</span> [<span class="string">&#x27;gcc&#x27;</span>]:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;gcc: missing source file(s).&#x27;</span>)</span><br><span class="line">    <span class="comment"># 出现gcc，且至少指定了一个文件:</span></span><br><span class="line">    <span class="keyword">case</span> [<span class="string">&#x27;gcc&#x27;</span>, file1, *files]:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;gcc compile: &#x27;</span> + file1 + <span class="string">&#x27;, &#x27;</span> + <span class="string">&#x27;, &#x27;</span>.join(files))</span><br><span class="line">    <span class="comment"># 仅出现clean:</span></span><br><span class="line">    <span class="keyword">case</span> [<span class="string">&#x27;clean&#x27;</span>]:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;clean&#x27;</span>)</span><br><span class="line">    <span class="keyword">case</span> _:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;invalid command.&#x27;</span>)</span><br></pre></td></tr></table></figure>



<br/>



<h2 id="2、函数"><a href="#2、函数" class="headerlink" title="2、函数"></a>2、函数</h2><h5 id="【1】函数的参数"><a href="#【1】函数的参数" class="headerlink" title="【1】函数的参数"></a>【1】函数的参数</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 默认参数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">power</span>(<span class="params">x, n = <span class="number">2</span></span>):</span><br><span class="line">    s = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">        n = n - <span class="number">1</span></span><br><span class="line">        s = s * x</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当我们调用power(5)时, 相当于调用power(5, 2)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置默认参数时, 有几点要注意！！！</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">1. 必选参数在前, 默认参数在后, 否则Python解释器会报错</span></span><br><span class="line"><span class="string">2. 如何设置默认参数：当函数有多个参数, 把变化大的参数放前面, 变化小的放后面, 小的可作为默认参数</span></span><br><span class="line"><span class="string">3. 当有多个默认参数时, 如果不按顺序提供部分默认参数, 需要把参数名写上比如调用enroll(&quot;Adam&quot;, &quot;M&quot;, city = &quot;Tianjin&quot;), 意思是city参数用传进去的值, 其他默认参数继续使用默认值。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#========================================================================================</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认参数有个最大的坑</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add_end</span>(<span class="params">L = []</span>):</span><br><span class="line">    L.append(<span class="string">&quot;END&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> L</span><br><span class="line"><span class="comment"># 正常调用</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>add_end([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="string">&#x27;END&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当你使用默认参数调用时, 一开始结果也是对的, 但是再次调用结果就不对了</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>add_end()</span><br><span class="line">[<span class="string">&#x27;END&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>add_end()</span><br><span class="line">[<span class="string">&#x27;END&#x27;</span>, <span class="string">&#x27;END&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 原因解释</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Python的函数在定义的时候, 默认参数L的值就被计算出来了, 即[], 因为默认参数L也是一个变量,</span></span><br><span class="line"><span class="string">它指向对象[], 每次调用该函数, 如果改变了L的内容, 则下次调用时, 默认参数的内容就变了,</span></span><br><span class="line"><span class="string">不再是函数定义时的[]了。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#========================================================================================</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 要修改上面的例子, 我们可以用None这个不变对象来实现</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add_end</span>(<span class="params">L = <span class="literal">None</span></span>):</span><br><span class="line">    <span class="keyword">if</span> L <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        L = []</span><br><span class="line">    L.append(<span class="string">&#x27;END&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> L</span><br><span class="line"></span><br><span class="line"><span class="comment"># 为什么要设计str、None这样的不变对象呢? </span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">因为不变对象一旦创建, 对象内部的数据就不能修改, 这样就减少了由于修改数据导致的错误。</span></span><br><span class="line"><span class="string">此外, 由于对象不变, 多任务环境下同时读取对象不需要加锁, 同时读一点问题都没有。我们在编写程序时,</span></span><br><span class="line"><span class="string">如果可以设计一个不变对象, 那就尽量设计成不变对象。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 可变参数</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 由于参数不确定, 我们首先想到的可以把参数作为一个list或tuple传进来, 这样, 函数可以定义如下</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">calc</span>(<span class="params">numbers</span>):</span><br><span class="line">    <span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> numbers:</span><br><span class="line">        <span class="built_in">sum</span> = <span class="built_in">sum</span> + n * n</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用的时候, 需要先组装出一个list或tuple</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>calc([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="number">14</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>calc((<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>))</span><br><span class="line"><span class="number">84</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#========================================================================================</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们把函数的参数改为可变参数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">calc</span>(<span class="params">*numbers</span>):</span><br><span class="line">    <span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> numbers:</span><br><span class="line">        <span class="built_in">sum</span> = <span class="built_in">sum</span> + n * n</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 其实可变参数函数里面, 参数numbers接收到的是一个tuple</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>calc(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果已经有一个list或者tuple, 如何调用可变参数</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>nums = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>calc(nums[<span class="number">0</span>], nums[<span class="number">1</span>], nums[<span class="number">2</span>])</span><br><span class="line"><span class="number">14</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 上面的写法可行, 但是太繁琐, 采取以下做法, 在list或tuple前面加一个*, 把list或tuple的元素变为可变参数。</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>nums = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>calc(*nums)</span><br><span class="line"><span class="number">14</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 关键字参数</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">可变参数允许你传入0个或任意个参数, 这些可变参数在函数调用时自动组装为一个tuple。而关键字参数允许你传入0个或任意个含参数名的参数, 这些关键字参数在函数内部自动组装称为一个dict</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">person</span>(<span class="params">name, age, **kw</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;name:&#x27;</span>, name, <span class="string">&#x27;age:&#x27;</span>, age, <span class="string">&#x27;other:&#x27;</span>, kw)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 函数person除了必选参数name和age外, 还接受关键字参数kw。在调用函数时, 可以只传入必选参数    </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>person(<span class="string">&#x27;Michael&#x27;</span>, <span class="number">30</span>)</span><br><span class="line">name: Michael age: <span class="number">30</span> other: &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 也可以传入任意个数的关键字参数</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>person(<span class="string">&#x27;Bob&#x27;</span>, <span class="number">35</span>, city = <span class="string">&#x27;Beijing&#x27;</span>)</span><br><span class="line">name: Bob age: <span class="number">35</span> other: &#123;<span class="string">&#x27;city&#x27;</span>: <span class="string">&#x27;Beijing&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>person(<span class="string">&#x27;Adam&#x27;</span>, <span class="number">45</span>, gender = <span class="string">&#x27;M&#x27;</span>, job = <span class="string">&#x27;Engineer&#x27;</span>)</span><br><span class="line">name: Bob age: <span class="number">45</span> other: &#123;<span class="string">&#x27;gender&#x27;</span>: <span class="string">&#x27;M&#x27;</span>, <span class="string">&#x27;job&#x27;</span>: <span class="string">&#x27;Engineer&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line">            </span><br><span class="line"><span class="comment"># 关键字参数有什么用?</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">它可以扩展函数的功能。比如person函数里, 我们保证能接收到name和age这两个参数, </span></span><br><span class="line"><span class="string">但是如果调用者愿意提供更多的参数, 我们也能收到。试想你正在做一个用户注册的功能,</span></span><br><span class="line"><span class="string">除了用户名和年龄是必填项外, 其他都是可选项, 利用关键字参数来定义这个函数就能满足注册的需求。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 和可变参数类似, 也可以先组装出一个dict, 然后把该dict转换为关键字参数传进去</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>extra = &#123;<span class="string">&#x27;city&#x27;</span>: <span class="string">&#x27;Beijing&#x27;</span>, <span class="string">&#x27;job&#x27;</span>: <span class="string">&#x27;Engineer&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>person(<span class="string">&#x27;Jack&#x27;</span>, <span class="number">24</span>, city = extra[<span class="string">&#x27;city&#x27;</span>], job = extra[<span class="string">&#x27;job&#x27;</span>])</span><br><span class="line">name: Jack age: <span class="number">24</span> other: &#123;<span class="string">&#x27;city&#x27;</span>: <span class="string">&#x27;Beijing&#x27;</span>, <span class="string">&#x27;job&#x27;</span>: <span class="string">&#x27;Engineer&#x27;</span>&#125;</span><br><span class="line">     </span><br><span class="line"><span class="comment"># 上面复杂写法可以简化</span></span><br><span class="line"><span class="comment"># 注意这里函数中的kw获得的dict是extra的一份拷贝, 对kw的改动不会影响函数外的extra</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>person(<span class="string">&#x27;Jack&#x27;</span>, <span class="number">24</span>, **extra)</span><br><span class="line">name: Jack age: <span class="number">24</span> other: &#123;<span class="string">&#x27;city&#x27;</span>: <span class="string">&#x27;Beijing&#x27;</span>, <span class="string">&#x27;job&#x27;</span>: <span class="string">&#x27;Engineer&#x27;</span>&#125;</span><br><span class="line">     </span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 命名关键字参数</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果要限制关键字参数的名字, 就可以用命名关键字参数, 例如只接收city和job作为关键字参数</span></span><br><span class="line"><span class="comment"># 和关键字参数**kw不同，命名关键字参数需要一个特殊分隔符*，*后面的参数被视为命名关键字参数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">person</span>(<span class="params">name, age, *, city, job</span>):</span><br><span class="line">    <span class="built_in">print</span>(name, age, city, job)</span><br><span class="line">    </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>person(<span class="string">&#x27;Jack&#x27;</span>, <span class="number">24</span>, city = <span class="string">&#x27;Beijing&#x27;</span>, job = <span class="string">&#x27;Engineer&#x27;</span>)</span><br><span class="line">Jack <span class="number">24</span> Beijing Engineer</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果函数定义中已经有了一个可变参数, 后面跟着的命名关键字参数就不再需要一个特殊分隔符*了</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">person</span>(<span class="params">name, age, *args, city, job</span>):</span><br><span class="line">    <span class="built_in">print</span>(name, age, args, city, job)</span><br><span class="line"><span class="comment"># 调用时必须命名关键字必须传入参数名, 没有参数名会报错</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>person(<span class="string">&#x27;Jack&#x27;</span>, <span class="number">24</span>, <span class="string">&#x27;Beijing&#x27;</span>, <span class="string">&#x27;Engineer&#x27;</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: person() missing <span class="number">2</span> required keyword-only arguments: <span class="string">&#x27;city&#x27;</span> <span class="keyword">and</span> <span class="string">&#x27;job&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 命名关键字参数可以有缺省值, 从而简化调用</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">要特别注意，如果没有可变参数，就必须加一个*作为特殊分隔符。</span></span><br><span class="line"><span class="string">如果缺少*，Python解释器将无法识别位置参数和命名关键字参数</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">person</span>(<span class="params">name, age, *, city=<span class="string">&#x27;Beijing&#x27;</span>, job</span>):</span><br><span class="line">    <span class="built_in">print</span>(name, age, city, job)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>person(<span class="string">&#x27;Jack&#x27;</span>, <span class="number">24</span>, job=<span class="string">&#x27;Engineer&#x27;</span>)</span><br><span class="line">Jack <span class="number">24</span> Beijing Engineer</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 参数组合</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">在Python中定义函数，可以用必选参数、默认参数、可变参数、关键字参数和命名关键字参数，</span></span><br><span class="line"><span class="string">这5种参数都可以组合使用。但是请注意，</span></span><br><span class="line"><span class="string">参数定义的顺序必须是：必选参数、默认参数、可变参数、命名关键字参数和关键字参数。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f1</span>(<span class="params">a, b, c=<span class="number">0</span>, *args, **kw</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;a =&#x27;</span>, a, <span class="string">&#x27;b =&#x27;</span>, b, <span class="string">&#x27;c =&#x27;</span>, c, <span class="string">&#x27;args =&#x27;</span>, args, <span class="string">&#x27;kw =&#x27;</span>, kw)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f2</span>(<span class="params">a, b, c=<span class="number">0</span>, *, d, **kw</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;a =&#x27;</span>, a, <span class="string">&#x27;b =&#x27;</span>, b, <span class="string">&#x27;c =&#x27;</span>, c, <span class="string">&#x27;d =&#x27;</span>, d, <span class="string">&#x27;kw =&#x27;</span>, kw)</span><br><span class="line">    </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f1(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">a = <span class="number">1</span> b = <span class="number">2</span> c = <span class="number">0</span> args = () kw = &#123;&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f1(<span class="number">1</span>, <span class="number">2</span>, c=<span class="number">3</span>)</span><br><span class="line">a = <span class="number">1</span> b = <span class="number">2</span> c = <span class="number">3</span> args = () kw = &#123;&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f1(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">a = <span class="number">1</span> b = <span class="number">2</span> c = <span class="number">3</span> args = (<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>) kw = &#123;&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f1(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, x=<span class="number">99</span>)</span><br><span class="line">a = <span class="number">1</span> b = <span class="number">2</span> c = <span class="number">3</span> args = (<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>) kw = &#123;<span class="string">&#x27;x&#x27;</span>: <span class="number">99</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f2(<span class="number">1</span>, <span class="number">2</span>, d=<span class="number">99</span>, ext=<span class="literal">None</span>)</span><br><span class="line">a = <span class="number">1</span> b = <span class="number">2</span> c = <span class="number">0</span> d = <span class="number">99</span> kw = &#123;<span class="string">&#x27;ext&#x27;</span>: <span class="literal">None</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 最神奇的是通过一个tuple和dict，你也可以调用上述函数</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>args = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>kw = &#123;<span class="string">&#x27;d&#x27;</span>: <span class="number">99</span>, <span class="string">&#x27;x&#x27;</span>: <span class="string">&#x27;#&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f1(*args, **kw)</span><br><span class="line">a = <span class="number">1</span> b = <span class="number">2</span> c = <span class="number">3</span> args = (<span class="number">4</span>,) kw = &#123;<span class="string">&#x27;d&#x27;</span>: <span class="number">99</span>, <span class="string">&#x27;x&#x27;</span>: <span class="string">&#x27;#&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>args = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>kw = &#123;<span class="string">&#x27;d&#x27;</span>: <span class="number">88</span>, <span class="string">&#x27;x&#x27;</span>: <span class="string">&#x27;#&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f2(*args, **kw)</span><br><span class="line">a = <span class="number">1</span> b = <span class="number">2</span> c = <span class="number">3</span> d = <span class="number">88</span> kw = &#123;<span class="string">&#x27;x&#x27;</span>: <span class="string">&#x27;#&#x27;</span>&#125;</span><br><span class="line"><span class="comment"># 所以，对于任意函数，都可以通过类似func(*args, **kw)的形式调用它，无论它的参数是如何定义的。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 递归，</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">函数调用时通过栈（stack）这种数据结构实现的，每当进入一个函数调用，栈就会加一层栈帧，</span></span><br><span class="line"><span class="string">每当函数返回，栈就会减少一层栈帧。由于栈的大小不是无限的，所以，递归调用次数过多，会导致栈溢出。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fact</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> n * fact(n-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 尾递归优化</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">解决递归调用栈溢出的方法是通过尾递归优化，事实上尾递归和循环的效果是一样的，所以，把循环看成是一种特殊的尾递归函数也是可以的。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">尾递归是指，在函数返回的时候，调用自身本身，并且，return语句不能包含表达式。这样，编译器或者解释器就可以把尾递归做优化，使递归本身无论调用多少次，都只占用一个栈帧，不会出现栈溢出的情况。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">尾递归调用时，如果做了优化，栈不会增长，因此，无论多少次调用也不会导致栈溢出。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">遗憾的是，大多数编程语言没有针对尾递归做优化，Python解释器也没有做优化，所以，即使把fact(n)函数改成尾递归方式，也会导致栈溢出。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fact</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">return</span> fact_iter(n, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fact_iter</span>(<span class="params">num, product</span>):</span><br><span class="line">    <span class="keyword">if</span> num == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> product</span><br><span class="line">    <span class="keyword">return</span> fact_iter(num - <span class="number">1</span>, num * product)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 汉诺塔</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">递归就是要找n和n-1的关系，在讨论n-1的时候，先将他视为一个整体。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">具体到这个例子，A上有n个，且n-1是个整体，那么顺序就是①n-1放到B，②a底下最大的1放到C，③再将n-1的B放到C。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">这里先忽视规定要求的每步只能挪动一个，因为你只是把n-1“视为”整体而已，当将n-1继续递归到n-2，n-2再递归到n-3......，最终一定会递归到1，也就是其实还是一步挪动一个的，有点从结果倒推过程的意思。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">move</span>(<span class="params">n, a, c, b</span>):</span><br><span class="line">    <span class="keyword">if</span> n &gt; <span class="number">0</span>:</span><br><span class="line">        move(n - <span class="number">1</span>, a, b, c)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;移动盘<span class="subst">&#123;n&#125;</span>从<span class="subst">&#123;a&#125;</span>到<span class="subst">&#123;c&#125;</span>&quot;</span>)</span><br><span class="line">        move(n - <span class="number">1</span>, b, c, a)</span><br><span class="line"></span><br><span class="line">move(<span class="number">3</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;b&#x27;</span>)</span><br></pre></td></tr></table></figure>



<blockquote>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>Python的函数具有非常灵活的参数形态，既可以实现简单的调用，又可以传入非常复杂的参数。</p>
<p>默认参数一定要用不可变对象，如果是可变对象，程序运行时会有逻辑错误！</p>
<p>要注意定义可变参数和关键字参数的语法：</p>
<p><code>*args</code>是可变参数，args接收的是一个tuple；</p>
<p><code>**kw</code>是关键字参数，kw接收的是一个dict。</p>
<p>以及调用函数时如何传入可变参数和关键字参数的语法：</p>
<p>可变参数既可以直接传入：<code>func(1, 2, 3)</code>，又可以先组装list或tuple，再通过<code>*args</code>传入：<code>func(*(1, 2, 3))</code>；</p>
<p>关键字参数既可以直接传入：<code>func(a=1, b=2)</code>，又可以先组装dict，再通过<code>**kw</code>传入：<code>func(**&#123;&#39;a&#39;: 1, &#39;b&#39;: 2&#125;)</code>。</p>
<p>使用<code>*args</code>和<code>**kw</code>是Python的习惯写法，当然也可以用其他参数名，但最好使用习惯用法。</p>
<p>命名的关键字参数是为了限制调用者可以传入的参数名，同时可以提供默认值。</p>
<p>定义命名的关键字参数在没有可变参数的情况下不要忘了写分隔符<code>*</code>，否则定义的将是位置参数。</p>
</blockquote>
<br/>



<h2 id="3、高级特性"><a href="#3、高级特性" class="headerlink" title="3、高级特性"></a>3、高级特性</h2><h5 id="【1】切片"><a href="#【1】切片" class="headerlink" title="【1】切片"></a>【1】切片</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果第一个索引是0，还可以省略：</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>L[:<span class="number">3</span>]</span><br><span class="line">[<span class="string">&#x27;Michael&#x27;</span>, <span class="string">&#x27;Sarah&#x27;</span>, <span class="string">&#x27;Tracy&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># python支持L[-1]取倒数第一个元素, 那么它同样支持倒数切片</span></span><br><span class="line">L = [<span class="string">&#x27;Michael&#x27;</span>, <span class="string">&#x27;Sarah&#x27;</span>, <span class="string">&#x27;Tracy&#x27;</span>, <span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;Jack&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>L[-<span class="number">2</span>:]</span><br><span class="line">[<span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;Jack&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 记住倒数第一个元素的索引是-1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>L[-<span class="number">2</span>:-<span class="number">1</span>]</span><br><span class="line">[<span class="string">&#x27;Bob&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过切片轻松取出某一段数列。比如前10个数：</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>L = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">100</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>L[:<span class="number">10</span>]</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 后10个数：</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>L[-<span class="number">10</span>:]</span><br><span class="line">[<span class="number">90</span>, <span class="number">91</span>, <span class="number">92</span>, <span class="number">93</span>, <span class="number">94</span>, <span class="number">95</span>, <span class="number">96</span>, <span class="number">97</span>, <span class="number">98</span>, <span class="number">99</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 前10个数, 每两个取一个</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>L[:<span class="number">10</span>:<span class="number">2</span>]</span><br><span class="line">[<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 每5个取一个</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>L[::<span class="number">5</span>]</span><br><span class="line">[<span class="number">0</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>, <span class="number">20</span>, <span class="number">25</span>, <span class="number">30</span>, <span class="number">35</span>, <span class="number">40</span>, <span class="number">45</span>, <span class="number">50</span>, <span class="number">55</span>, <span class="number">60</span>, <span class="number">65</span>, <span class="number">70</span>, <span class="number">75</span>, <span class="number">80</span>, <span class="number">85</span>, <span class="number">90</span>, <span class="number">95</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 什么都不写，只写[:]就可以原样复制一个list</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>L[:]</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, ..., <span class="number">99</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Python中没有针对字符串的截取函数, 只需切片一个操作就可以完成</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;ABCDEFG&#x27;</span>[:<span class="number">3</span>]</span><br><span class="line"><span class="string">&#x27;ABC&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;ABCDEFG&#x27;</span>[::<span class="number">2</span>]</span><br><span class="line"><span class="string">&#x27;ACEG&#x27;</span></span><br></pre></td></tr></table></figure>



<br/>



<h5 id="【2】迭代"><a href="#【2】迭代" class="headerlink" title="【2】迭代"></a>【2】迭代</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># list这种数据类型虽然有下标, 但很多其他数据类型是没有下标的, 只要是可迭代对象, 无论是否有下标, </span></span><br><span class="line"><span class="comment"># 都可以迭代</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = &#123;<span class="string">&#x27;a&#x27;</span>:<span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>:<span class="number">2</span>, <span class="string">&#x27;c&#x27;</span>:<span class="number">3</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> key <span class="keyword">in</span> d:</span><br><span class="line"><span class="meta">... </span>   <span class="built_in">print</span>(key)</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认情况下, dict迭代的是key。如果要迭代value, 可以用 for value in d.values(), 如果要同时迭代</span></span><br><span class="line"><span class="comment"># key和value, 可以用for k, v in d.items()</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如何判断一个对象是可迭代对象呢？方法是通过collections.abc模块的Iterable类型诊断</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections.abc <span class="keyword">import</span> Iterable</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span>(<span class="string">&#x27;abc&#x27;</span>, Iterable) <span class="comment"># str是否可迭代</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], Iterable) <span class="comment"># list是否可迭代</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span>(<span class="number">123</span>, Iterable) <span class="comment"># 整数是否可迭代</span></span><br><span class="line"><span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果要对list实现类似Java那样的下标循环怎么办? Python内置的enumerate函数可以把一个list变成</span></span><br><span class="line"><span class="comment"># 索引-元素对, 这样就可以在for循环中同时迭代索引和元素本身</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i, value <span class="keyword">in</span> <span class="built_in">enumerate</span>([<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>]):</span><br><span class="line"><span class="meta">... </span>   <span class="built_in">print</span>(i, value)</span><br><span class="line"><span class="number">0</span> A</span><br><span class="line"><span class="number">1</span> B</span><br><span class="line"><span class="number">2</span> C</span><br><span class="line"></span><br><span class="line"><span class="comment"># 同时引用两个变量</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> x, y <span class="keyword">in</span> [(<span class="number">1</span>, <span class="number">1</span>), (<span class="number">2</span>, <span class="number">4</span>), (<span class="number">3</span>,<span class="number">9</span>)]:</span><br><span class="line"><span class="meta">... </span>   <span class="built_in">print</span>(x,y)</span><br><span class="line"><span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="number">2</span> <span class="number">4</span></span><br><span class="line"><span class="number">3</span> <span class="number">9</span></span><br></pre></td></tr></table></figure>



<br/>



<h5 id="【3】列表生成式"><a href="#【3】列表生成式" class="headerlink" title="【3】列表生成式"></a>【3】列表生成式</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列表生成式是Python内置的非常简单却强大的可以用来创建list的生成式</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">1</span>, <span class="number">11</span>))</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列表生成式可以用一行语句代替循环生成list</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[x * x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">11</span>)]</span><br><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>, <span class="number">100</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列表生成式for循环后面还可以加上if判断, 这样就可以进行筛选</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[x * x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">11</span>) <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span>]</span><br><span class="line">[<span class="number">4</span>, <span class="number">16</span>, <span class="number">36</span>, <span class="number">64</span>, <span class="number">100</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 还可以用两层for循环, 可以生成全排列, 三层及以上就用的很少了</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[m + n <span class="keyword">for</span> m <span class="keyword">in</span> <span class="string">&quot;ABC&quot;</span> <span class="keyword">for</span> n <span class="keyword">in</span> <span class="string">&quot;XYZ&quot;</span>]</span><br><span class="line">[<span class="string">&quot;AX&quot;</span>, <span class="string">&quot;AY&quot;</span>, <span class="string">&quot;AZ&quot;</span>, <span class="string">&quot;BX&quot;</span>, <span class="string">&quot;BY&quot;</span>, <span class="string">&quot;BZ&quot;</span>, <span class="string">&quot;CX&quot;</span>, <span class="string">&quot;CY&quot;</span>, <span class="string">&quot;CZ&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运用列表生成式可以写出非常简洁的代码, 比如列出当前目录下所有文件和目录名</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> os <span class="comment"># 导入os模块, 模块的概念后面讲</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[d <span class="keyword">for</span> d <span class="keyword">in</span> os.listdir(<span class="string">&#x27;x&#x27;</span>)] <span class="comment"># os.listdir可以列出文件和目录</span></span><br><span class="line">[<span class="string">&#x27;.emacs.d&#x27;</span>, <span class="string">&#x27;.ssh&#x27;</span>, <span class="string">&#x27;.Trash&#x27;</span>, <span class="string">&#x27;Adlm&#x27;</span>, <span class="string">&#x27;Applications&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># for循环可以同时使用两个甚至多个变量, 比如dict的items()可以同时迭代key和value</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = &#123;<span class="string">&#x27;x&#x27;</span>: <span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;y&#x27;</span>: <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;z&#x27;</span>: <span class="string">&#x27;C&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> k, v <span class="keyword">in</span> d.items():</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(k, <span class="string">&#x27;=&#x27;</span>, v)</span><br><span class="line">...</span><br><span class="line">y = B</span><br><span class="line">x = A</span><br><span class="line">z = C</span><br><span class="line"></span><br><span class="line"><span class="comment"># 因此可以用列表生成式生成上述list</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = &#123;<span class="string">&#x27;x&#x27;</span>: <span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;y&#x27;</span>: <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;z&#x27;</span>: <span class="string">&#x27;C&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[k + <span class="string">&#x27;=&#x27;</span> + v <span class="keyword">for</span> k, v <span class="keyword">in</span> d.items()]</span><br><span class="line">[<span class="string">&#x27;x=A&#x27;</span>, <span class="string">&#x27;y=B&#x27;</span>, <span class="string">&#x27;z=C&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把list中所有字符串变成小写</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>L = [<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;World&quot;</span>, <span class="string">&quot;IBM&quot;</span>, <span class="string">&quot;Apple&quot;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[s.lower() <span class="keyword">for</span> s <span class="keyword">in</span> L]</span><br><span class="line">[<span class="string">&#x27;hello&#x27;</span>, <span class="string">&#x27;world&#x27;</span>, <span class="string">&#x27;ibm&#x27;</span>, <span class="string">&#x27;apple&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在使用列表生成式的时候会搞不清楚if...else的用法, 不能在if后面加上else</span></span><br><span class="line"><span class="comment"># 这是因为跟在for后面的if是一个筛选条件, 不能带else</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">11</span>) <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span>]</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span></span><br><span class="line">    [x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">11</span>) <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span>]</span><br><span class="line">                                              ^</span><br><span class="line">SyntaxError: invalid syntax</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 把if写在for前面必须加else, 否则报错</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[x <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span> <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">11</span>)]</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span></span><br><span class="line">    [x <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span> <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">11</span>)]</span><br><span class="line">                       ^</span><br><span class="line">SyntaxError: invalid syntax</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 这是因为for前面的部分是一个表达式, 它必须根据x计算出一个结果。</span></span><br><span class="line"><span class="comment"># 因此考察表达式: x if x % 2 == 0, 它无法根据x计算出结果, 因为缺少else, 必须加上else</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[x <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span> <span class="keyword">else</span> -x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">11</span>)]</span><br><span class="line">[-<span class="number">1</span>, <span class="number">2</span>, -<span class="number">3</span>, <span class="number">4</span>, -<span class="number">5</span>, <span class="number">6</span>, -<span class="number">7</span>, <span class="number">8</span>, -<span class="number">9</span>, <span class="number">10</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可见, 在一个列表生成式中, for前面的if...else是表达式, 而for后面的if是过滤条件, 不带else。</span></span><br></pre></td></tr></table></figure>



<br/>



<h5 id="【4】生成器"><a href="#【4】生成器" class="headerlink" title="【4】生成器"></a>【4】生成器</h5><p>通过列表生成式，我们可以直接创建一个列表。但是，受到内存限制，列表容量肯定是有限的。而且，创建一个包含100万个元素的列表，不仅占用很大的存储空间，如果我们仅仅需要访问前面几个元素，那后面绝大多数元素占用的空间都白白浪费了。</p>
<p>所以，如果列表元素可以按照某种算法推算出来，那我们是否可以在循环的过程中不断推算出后续的元素呢？这样就不必创建完整的list，从而节省大量的空间。在Python中，这种一边循环一边计算的机制，称为生成器：<code>generator</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 要创建一个generator, 有很多种方法。</span></span><br><span class="line"><span class="comment"># 第一种方法很简单，只要把一个列表生成式的[]改成()，就创建了一个generator：</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>L = [x * x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>L</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g = (x * x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g</span><br><span class="line">&lt;generator <span class="built_in">object</span> &lt;genexpr&gt; at <span class="number">0x000001CD8418EC10</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们怎么打印generator中的每一个元素，如果一个一个打印可以用next()</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(g)</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(g)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(g)</span><br><span class="line"><span class="number">4</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(g)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">StopIteration</span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们讲过，generator保存的是算法，每次调用next(g)，就计算出g的下一个元素的值，</span></span><br><span class="line"><span class="comment"># 直到计算到最后一个元素，没有更多的元素时，抛出StopIteration错误</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 不断调用next(g)太繁琐了，使用for循环更方便，因为generator也是可迭代对象</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g = (x * x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> n <span class="keyword">in</span> g:</span><br><span class="line">        <span class="built_in">print</span>(n)</span><br><span class="line">        </span><br><span class="line"><span class="comment"># 所以我们创建了一个generator后，基本上永远不会调用next()，而是通过for循环来迭代，</span></span><br><span class="line"><span class="comment"># 并且不需要关心StopIteration的错误。generator非常强大，如果推算的算法比较复杂，</span></span><br><span class="line"><span class="comment"># 用类似列表生成式的for循环无法实现的时候，还可以用函数来实现。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 著名的斐波拉契数列（Fibonacci），除第一个和第二个数外，任意一个数都可由前两个数相加得到</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fib</span>(<span class="params"><span class="built_in">max</span></span>):</span><br><span class="line">    n, a, b = <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> n &lt; <span class="built_in">max</span>:</span><br><span class="line">        <span class="built_in">print</span>(b)</span><br><span class="line">        a, b = b, a + b</span><br><span class="line">        n = n + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;done&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">a, b = b, a + b</span></span><br><span class="line"><span class="string">相当于:</span></span><br><span class="line"><span class="string">t = (b, a + b) # t是一个tuple</span></span><br><span class="line"><span class="string">a = t[0]</span></span><br><span class="line"><span class="string">b = t[1]</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 仔细观察可以看出，fib函数实际上是定义了斐波拉契数列的推算规则，可以从第一个元素开始，</span></span><br><span class="line"><span class="comment"># 推算出后续任意的元素，这种逻辑其实非常类似generator</span></span><br><span class="line"><span class="comment"># 上面的函数和generator仅一步之遥，如下变成真正的generator</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fib</span>(<span class="params"><span class="built_in">max</span></span>):</span><br><span class="line">    n, a, b = <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> n &lt; <span class="built_in">max</span>:</span><br><span class="line">        <span class="keyword">yield</span> b</span><br><span class="line">        a, b = b, a + b</span><br><span class="line">        n = n + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;done&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 上述就是定义generator的另一种方法。如果一个函数定义中包含yield关键字，</span></span><br><span class="line"><span class="comment"># 那么这个函数就不再是一个普通函数，而是一个generator函数，</span></span><br><span class="line"><span class="comment"># 调用一个generator函数将返回一个generator：</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = fib(<span class="number">6</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f</span><br><span class="line">&lt;generator <span class="built_in">object</span> fib at <span class="number">0x00000206DED7E0B0</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关于generator函数的理解</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">普通函数是顺序执行，遇到return语句或者最后一行函数语句就返回。</span></span><br><span class="line"><span class="string">而变成generator，在每次调用next()的时候执行，遇到yield语句返回，</span></span><br><span class="line"><span class="string">再次执行时从上次返回的yield语句处继续执行</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">odd</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;step 1&#x27;</span>)</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;step 2&#x27;</span>)</span><br><span class="line">    <span class="keyword">yield</span>(<span class="number">3</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;step 3&#x27;</span>)</span><br><span class="line">    <span class="keyword">yield</span>(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用该generator函数时，首先要生成一个generator对象，然后用next()函数不断获得下一个</span></span><br><span class="line"><span class="comment"># 在执行过程中，遇到yield就中断，下次又继续执行。执行3次后就没有yield可执行，第4次报错。</span></span><br><span class="line"><span class="comment"># 请务必注意：调用generator会创建一个generator对象，多次调用generator会创建多个独立的generator</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>o = odd()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(o)</span><br><span class="line">step <span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(o)</span><br><span class="line">step <span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(o)</span><br><span class="line">step <span class="number">3</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(o)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">StopIteration</span><br><span class="line"></span><br><span class="line"><span class="comment"># 请务必注意：调用generator会创建一个generator对象，多次调用generator会创建多个独立的generator</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">odd()会创建一个新的generator对象，上述代码实际上创建了3个完全独立的generator，</span></span><br><span class="line"><span class="string">对3个generator分别调用next()当然每个都会返回第一个值。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(odd())</span><br><span class="line">step <span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(odd())</span><br><span class="line">step <span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(odd())</span><br><span class="line">step <span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 用for循环调用generator时，发现拿不到generator的return语句的返回值。如果想要拿到返回值，</span></span><br><span class="line"><span class="comment"># 必须捕获StopIteration错误，返回值包含在StopIteration的value中</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g = fib(<span class="number">6</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        x = <span class="built_in">next</span>(g)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;g:&quot;</span>, x)</span><br><span class="line">    <span class="keyword">except</span> StopIteration <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Generator return value:&quot;</span>, e.value)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">g: <span class="number">1</span></span><br><span class="line">g: <span class="number">1</span></span><br><span class="line">g: <span class="number">2</span></span><br><span class="line">g: <span class="number">3</span></span><br><span class="line">g: <span class="number">5</span></span><br><span class="line">g: <span class="number">8</span>    </span><br><span class="line">Generator <span class="keyword">return</span> value: done    </span><br><span class="line"></span><br><span class="line"><span class="comment"># 对于函数改成的generator来说，遇到return语句或执行到函数体最后一行语句，</span></span><br><span class="line"><span class="comment"># 就是结束generator的指令，for循环随之结束</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 杨辉三角形</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">triangles</span>():</span><br><span class="line">    L = [<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">yield</span> L</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        L = [<span class="number">1</span>] + [L[i] + L[i + <span class="number">1</span>] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(L) - <span class="number">1</span>)] + [<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">yield</span> L</span><br><span class="line"><span class="keyword">def</span>  <span class="title function_">triangles2</span>():</span><br><span class="line">    L = [<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">yield</span> L</span><br><span class="line">        L = [<span class="built_in">sum</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">zip</span>([<span class="number">0</span>]+L, L+[<span class="number">0</span>])]</span><br></pre></td></tr></table></figure>



<br/>



<h5 id="【5】迭代器"><a href="#【5】迭代器" class="headerlink" title="【5】迭代器"></a>【5】迭代器</h5><p>我们已经知道，可以直接作用于for循环的数据类型有以下几种：</p>
<p>一类是集合数据类型，如<code>list</code>、<code>tuple</code>、<code>dict</code>、<code>set</code>、<code>str</code>等</p>
<p>一类是<code>generator</code>，包括生成器和带<code>yield</code>的generator function</p>
<p>这些可以直接作用于<code>for</code>循环的对象统称为可迭代对象：<code>Iterable</code>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 可以使用isinstance()判断一个对象是否是Iterable对象</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections.abc <span class="keyword">import</span> Iterable</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span>([], Iterable)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span>(&#123;&#125;, Iterable)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span>(<span class="string">&quot;abc&quot;</span>, Iterable)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span>((x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)), Iterable)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span>(<span class="number">100</span>, Iterable)</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成器不但可以作用于for循环，还可以被next()函数不断调用并返回下一个值，</span></span><br><span class="line"><span class="comment"># 直到最后抛出StopIteration错误表示无法继续返回下一个值了。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">可以被next()函数调用并不断返回下一个值的对象称为迭代器：Iterator</span></span><br><span class="line"><span class="string">可以使用isinstance()判断一个对象是否是Iterator对象</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections.abc <span class="keyword">import</span> Iterator</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span>((x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)), Iterator)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span>([], Iterator)</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span>(&#123;&#125;, Iterator)</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span>(<span class="string">&quot;abc&quot;</span>, Iterator)</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成器都是Iterator对象，但list、dict、str虽然是Iterable，却不是Iterator。</span></span><br><span class="line"><span class="comment"># 把list、dict、str等Iterable变成Iterator可以使用iter()函数</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span>(<span class="built_in">iter</span>([]), Iterator)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span>(<span class="built_in">iter</span>(<span class="string">&quot;abc&quot;</span>), Iterator)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 为什么list、dict、str等数据类型不是Iterator</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">这是因为Python的Iterator对象表示的是一个数据流，Iterator对象可以被next()函数调用并不断返回下一个</span></span><br><span class="line"><span class="string">数据，直到没有数据时抛出StopIteration错误。可以把这个数据流看作是一个有序序列，但我们却不能提前知</span></span><br><span class="line"><span class="string">道序列的长度，只能不断通过next()函数实现按需计算下一个数据，所以Iterator的计算是惰性的，只有在需要</span></span><br><span class="line"><span class="string">返回下一个数据时它才会计算。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Iterator甚至可以表示一个无限大的数据流，例如全体自然数。而使用list是永远不可能存储全体自然数的。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 小结</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">凡是可作用于for循环的对象都是Iterable类型；</span></span><br><span class="line"><span class="string">凡是可作用于next()函数的对象都是Iterator类型，它们表示一个惰性计算的序列；</span></span><br><span class="line"><span class="string">集合数据类型如list、dict、str等是Iterable但不是Iterator，不过可以通过iter()函数获得一个Iterator对象。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Python的for循环本质上就是通过不断调用next()函数实现的。</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 实际上完全等价于：</span></span><br><span class="line"><span class="comment"># 首先获得Iterator对象</span></span><br><span class="line">it = <span class="built_in">iter</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line"><span class="comment"># 循环：</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># 获得下一个值</span></span><br><span class="line">        x = <span class="built_in">next</span>(it)</span><br><span class="line">    <span class="keyword">except</span> StopIteration:</span><br><span class="line">        <span class="comment"># 遇到StopIteration就退出循环</span></span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>关于Iterable和Iterator的一些解释</strong></p>
<p>Iteratable是可迭代的对象，Iterator是迭代器。</p>
<p>可迭代对象包括迭代器，也就是说可迭代的对象（Iterable）不一定是迭代器（Iterator），而迭代器（Iterator）一定是可迭代的对象（Iterable）。</p>
<p>显然，range(10)是可迭代对象，但是它并不是一个迭代器，也不是一个list。</p>
<p>用type函数可以看到，range(10)是range类型的数据。</p>
<br/>

<p><strong>以下整理自《流畅的Python》一书</strong></p>
<p>问：如何判断对象是否为iterable？</p>
<p>答：从Python3.4开始，检查对象x能否迭代，最准确的方法是：调用iter(x)函数，如果不可迭代，则会抛出异常：”TypeError: ‘C’ is not iterable.”。这比使用isinstance(x, abc.Iterable)更准确。因为iter(x)函数会考虑到遗留的<code>__getitem__</code>方法，而abc.Iterable类则不考虑。</p>
<p><strong>可迭代对象：</strong></p>
<p>使用iter内置函数可以获取迭代器的对象。如果对象实现了能返回迭代器的<code>__iter__</code>方法，那么对象就是可迭代的。序列都是可迭代，实现了<code>__getitem__</code>方法，而且其参数是从零开始的索引，这种对象也可迭代。</p>
<p><strong>迭代器：</strong></p>
<p>实现了无参数的<code>__next__</code>方法，返回序列中的下一个元素；如果没有元素了，那么抛出StopIteration异常。Python中的迭代器还实现了<code>__iter__</code>方法，因此迭代器也可以迭代。</p>
<br/>

<p><strong>请问生成器和迭代器的区别是什么？</strong></p>
<p>生成器是迭代器的一种。所有实现了<code>__next__()</code> <code>__iter__()</code>方法的对象都是迭代器。生成器本质上也是实现了该方法，不过是通过简单的方法实现：函数中加yield关键字+使用类似列表生成式方式。这两种方式创建出来的函数或者式子都是生成器，本质上也是迭代器。迭代器比较繁琐的制造方式是创建一个对象，并在对象中实现一个方法：<code>__next__()</code>。实现之后，就可以反复调用next()方法返回值。生成器当然也可以调用next()方法。所以生成器和迭代器都可以调用next()方法来获取下一个返回值。这也是生成器和迭代器本质是一样的原因。不同点在于，生成器写起来简单明了，比通过创建一个对象并重写<code>__next__()</code>方便多了。</p>
<p>生成器是一个用于创建迭代器的简单而强大的工具，也就是说生成器也是迭代器。生成器较于一般的迭代器一是写法更紧凑，因为它会自动创建<code>__iter__()</code>和<code>__next__()</code>方法。另一点是每次在生成器上调用next()获取yield返回的值时，它会从上次离开的位置恢复执行（会记住上次执行语句时的所有数据值）。除了会自动创建方法和保存程序状态，当生成器终结时，它们还会自动引发<code>StopIteration</code>。这些特性结合在一起，使得创建迭代器能与编写常规函数一样容易。</p>
<br/>

<p><strong>示例程序</strong></p>
<p>实现了<code>__next__</code>方法的对象都可以被next()作用，但如果该对象没有实现<code>__iter__</code>方法，则不是Iterator类型。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Count</span>:</span><br><span class="line">     <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, start, end</span>):</span><br><span class="line">         <span class="string">&quot;&quot;&quot; count integers in [start, end] &quot;&quot;&quot;</span></span><br><span class="line">         self.start = start - <span class="number">1</span></span><br><span class="line">         self.end = end</span><br><span class="line">     <span class="keyword">def</span> <span class="title function_">__next__</span>(<span class="params">self</span>):</span><br><span class="line">         <span class="keyword">if</span> self.start &gt;= self.end:</span><br><span class="line">             <span class="keyword">raise</span> StopIteration</span><br><span class="line">         self.start += <span class="number">1</span></span><br><span class="line">         <span class="keyword">return</span> self.start</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>count = Count(<span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(count)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections.abc <span class="keyword">import</span> Iterator</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span>(count, Iterator)</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure>

<p>实际上，在collections.abc中可以知道（refs: <a target="_blank" rel="noopener" href="https://docs.python.org/3/library/collections.abc.html#collections-abstract-base-classes">Collections Abstract Base Classes</a>, <a target="_blank" rel="noopener" href="https://docs.python.org/3/library/stdtypes.html#iterator-types">Iterator Types</a>）：</p>
<ul>
<li>Iterable对象需要实现<code>__iter__</code>方法</li>
<li>Iterator继承自Iterable，因而也必须实现<code>__iter__</code>方法，并且原则上此方法应直接返回<code>self</code>，即对象本身，但非强制。</li>
<li>Iterator还需要实现<code>__next__</code>方法</li>
</ul>
<p>总而言之，一个Iterator对象需要且仅需同时具有<code>__iter__</code>和<code>__next__</code>方法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">IteratorExample</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__next__</span>(<span class="params">sefl</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span>(IteratorExample(), Iterator)</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>


</blockquote>
<br/>



<h2 id="4、函数式编程"><a href="#4、函数式编程" class="headerlink" title="4、函数式编程"></a>4、函数式编程</h2><p>我们通过把大段代码拆成函数，通过一层一层的函数调用，就可以把复杂任务分解成简单的任务，这种分解可以称为面向过程的程序设计。函数就是面向过程的程序设计的基本单元。</p>
<p>而函数式编程（请注意多了一个”式”字）——Functional Programming，虽然也可以归结到面向过程的程序设计，但其思想更接近数学计算。</p>
<p>越是低级的编程语言，越贴近计算机，抽象程度低，执行效率高，比如C语言；越高级的语言，越贴近计算，抽象程度高，执行效率低，比如Lisp语言。</p>
<p>函数式编程就是一种抽象程度很高的编程范式，纯粹的函数式编程语言编写的函数没有变量，因此任意一个函数，只要输入是确定的，输出就是确定的，这种纯函数我们称之为没有副作用。而允许使用变量的程序设计语言，由于函数内部的变量状态不确定，同样的输入，可能得到不同的输出，因此，这种函数是有副作用的。</p>
<p>函数式编程的一个特点就是，允许把函数本身作为参数传入另一个函数，还允许返回一个函数！</p>
<p>Python对函数式编程提供部分支持。由于Python允许使用变量，因此，Python不是纯函数式编程语言。</p>
<p>Python函数式编程视频教程：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV18E411F7YA?spm_id_from=333.337.search-card.all.click">高阶函数与函数式编程</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 函数式编程中每个函数只实现一种功能，且纯净无其他变量（避免不必要的I/O操作）。</span></span><br><span class="line"><span class="comment"># 返回值是受参数影响。通过这些函数的组合调用来实现计算任务。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">举个例子：求(1+2)*3-4</span></span><br><span class="line"><span class="string">由数学计算规则知，应当先算加法，再算乘法，最后算减法。一共需要三种运算。</span></span><br><span class="line"><span class="string">三种运算的函数定义如下：</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">x, y</span>):</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">mul</span>(<span class="params">x, y</span>):</span><br><span class="line">    <span class="keyword">return</span> x * y</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sub</span>(<span class="params">x, y</span>):</span><br><span class="line">    <span class="keyword">return</span> x - y</span><br><span class="line"><span class="comment"># 最终计算</span></span><br><span class="line">sub(mul(add(<span class="number">1</span>, <span class="number">2</span>), <span class="number">3</span>), <span class="number">4</span>)</span><br></pre></td></tr></table></figure>



<br/>



<h5 id="【1】高阶函数"><a href="#【1】高阶函数" class="headerlink" title="【1】高阶函数"></a>【1】高阶函数</h5><p>高阶函数英文叫<code>Higher-order function</code>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Python内置求绝对值函数</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">abs</span>(-<span class="number">10</span>)</span><br><span class="line"><span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 直接输出函数名</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">abs</span></span><br><span class="line">&lt;built-<span class="keyword">in</span> function <span class="built_in">abs</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 函数本身可以赋值给变量，即变量可以指向函数</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = <span class="built_in">abs</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f(-<span class="number">10</span>)</span><br><span class="line"><span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 函数名其实就是指向函数的变量！</span></span><br><span class="line"><span class="comment"># 如果把abs指向其他对象会发生什么？</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">将abs指向10后，就无法调用abs函数。因为abs这个变量已经不指向求绝对值的函数</span></span><br><span class="line"><span class="string">实际代码绝对不能这么写，这里是为了说明函数名也是变量。要恢复abs函数，请重启Python交互环境</span></span><br><span class="line"><span class="string">注：由于abs函数实际上是定义在import builtins模块中的，所以要让修改abs变量的指向在其他模</span></span><br><span class="line"><span class="string">块也生效，要用 </span></span><br><span class="line"><span class="string">import builtins; builtins.abs = 10</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">abs</span> = <span class="number">10</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">abs</span>(-<span class="number">10</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: <span class="string">&#x27;int&#x27;</span> <span class="built_in">object</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="built_in">callable</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 传入函数</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">既然变量可以指向函数，函数的参数能接收变量，那么一个函数就可以接收另一个函数作为参数，</span></span><br><span class="line"><span class="string">这种函数就称为高阶函数。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">x, y, f</span>):</span><br><span class="line">    <span class="keyword">return</span> f(x) + f(y)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>add(-<span class="number">5</span>, <span class="number">6</span>, <span class="built_in">abs</span>)</span><br><span class="line"><span class="number">11</span></span><br></pre></td></tr></table></figure>



<br/>



<h6 id="（1）map-reduce"><a href="#（1）map-reduce" class="headerlink" title="（1）map/reduce"></a>（1）map/reduce</h6><p>Python内建了<code>map()</code>和<code>reduce()</code>函数。</p>
<p>如果你读过Google的那篇大名鼎鼎的论文“<a target="_blank" rel="noopener" href="http://research.google.com/archive/mapreduce.html">MapReduce: Simplified Data Processing on Large Clusters</a>”，你就能大概明白map/reduce的概念。</p>
<p><code>map()</code>函数接受两个参数，一个是函数，一个是<code>Iterable</code>，map将传入的函数依次作用到序列的每个元素，并把结果作为新的<code>Iterator</code>返回。</p>
<p>比如说我们有一个函数<code>f(x)=x^2</code>，要把这个函数作用在一个list<code>[1, 2, 3, 4, 5, 6, 7, 8, 9]</code>上，就可以用<code>map()</code>实现。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> x * x</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r = <span class="built_in">map</span>(f, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(r)</span><br><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>]</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">map()传入的第一个参数是f，即函数对象本身。由于结果r是一个Iterator，Iterator是惰性序列，</span></span><br><span class="line"><span class="string">因此通过list()函数让它把整个序列都计算出来并返回一个list。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 不需要map()函数，写一个循环也可以计算出结果</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">的确可以，但是从下面的循环代码能一眼看明白&#x27;把f(x)作用在list的每一个元素并把结果生成一个新</span></span><br><span class="line"><span class="string">的list&#x27;吗？</span></span><br><span class="line"><span class="string">所以，map()作为高阶函数，事实上它把运算规则抽象了，因此，我们不但可以计算简单的f(x)=x^2，</span></span><br><span class="line"><span class="string">还可以计算任意复杂的函数，比如把这个list所有数字转为字符串</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">L = []</span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]:</span><br><span class="line">    L.append(f(n))</span><br><span class="line"><span class="built_in">print</span>(L)</span><br><span class="line"></span><br><span class="line"><span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">str</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]))</span><br><span class="line">[<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;6&#x27;</span>, <span class="string">&#x27;7&#x27;</span>, <span class="string">&#x27;8&#x27;</span>, <span class="string">&#x27;9&#x27;</span>]</span><br></pre></td></tr></table></figure>



<br/>



<p>再看<code>reduce</code>的用法，<code>reduce</code>把一个函数作用在一个序列<code>[x1, x2, x3, ...]</code>上，这个函数必须接收两个参数，<code>reduce</code>把结果继续和序列的下一个元素做累积计算，其效果就是：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 比方说对一个序列求和，就可以用reduce实现</span></span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">x, y</span>):</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>reduce(add, [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>])</span><br><span class="line"><span class="number">25</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 当然求和运算可以直接用Python内建函数sum()，没必要用reduce</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果要把序列[1, 3, 5, 7, 9]变换成整数13579，reduce就可以派上用场。</span></span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fn</span>(<span class="params">x, y</span>):</span><br><span class="line">    <span class="keyword">return</span> x * <span class="number">10</span> + y</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>reduce(fn, [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>])</span><br><span class="line"><span class="number">13579</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 上述例子本身无啥作用，但是如果考虑到字符串str也是一个序列，对上面的例子稍微改动，配合</span></span><br><span class="line"><span class="comment"># map()，我们就可以写出把str转换为int的函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">char2num</span>(<span class="params">s</span>):</span><br><span class="line">    digits = &#123;<span class="string">&#x27;1&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;2&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;3&#x27;</span>:<span class="number">3</span>, <span class="string">&#x27;4&#x27;</span>:<span class="number">4</span>, <span class="string">&#x27;5&#x27;</span>:<span class="number">5</span>, <span class="string">&#x27;6&#x27;</span>:<span class="number">6</span>, <span class="string">&#x27;7&#x27;</span>: <span class="number">7</span>, <span class="string">&#x27;8&#x27;</span>: <span class="number">8</span>, <span class="string">&#x27;9&#x27;</span>: <span class="number">9</span>&#125;</span><br><span class="line">    <span class="keyword">return</span> digits[s]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fn</span>(<span class="params">x, y</span>)</span><br><span class="line">	<span class="keyword">return</span> x * <span class="number">10</span> + y</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>reduce(fn, <span class="built_in">map</span>(char2num, <span class="string">&quot;13579&quot;</span>))</span><br><span class="line"><span class="number">13579</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将上述函数整理成一个str2int</span></span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line">DIGITS = &#123;<span class="string">&#x27;1&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;2&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;3&#x27;</span>:<span class="number">3</span>, <span class="string">&#x27;4&#x27;</span>:<span class="number">4</span>, <span class="string">&#x27;5&#x27;</span>:<span class="number">5</span>, <span class="string">&#x27;6&#x27;</span>:<span class="number">6</span>, <span class="string">&#x27;7&#x27;</span>: <span class="number">7</span>, <span class="string">&#x27;8&#x27;</span>: <span class="number">8</span>, <span class="string">&#x27;9&#x27;</span>: <span class="number">9</span>&#125;</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">str2int</span>(<span class="params">s</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fn</span>(<span class="params">x, y</span>):</span><br><span class="line">        <span class="keyword">return</span> x * <span class="number">10</span> + y</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">char2num</span>(<span class="params">s</span>):</span><br><span class="line">        <span class="keyword">return</span> DIGITS[s]</span><br><span class="line">    <span class="keyword">return</span> reduce(fn, <span class="built_in">map</span>(char2num, s))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用lambda继续简化上述函数</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">假设Python未提供int()函数，你完全可以自己写一个把字符串转化为整数的函数，而且只需几行代码</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line">DIGITS = &#123;<span class="string">&#x27;1&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;2&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;3&#x27;</span>:<span class="number">3</span>, <span class="string">&#x27;4&#x27;</span>:<span class="number">4</span>, <span class="string">&#x27;5&#x27;</span>:<span class="number">5</span>, <span class="string">&#x27;6&#x27;</span>:<span class="number">6</span>, <span class="string">&#x27;7&#x27;</span>: <span class="number">7</span>, <span class="string">&#x27;8&#x27;</span>: <span class="number">8</span>, <span class="string">&#x27;9&#x27;</span>: <span class="number">9</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">char2num</span>(<span class="params">s</span>):</span><br><span class="line">    <span class="keyword">return</span> DIGITS[s]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">str2int</span>(<span class="params">s</span>):</span><br><span class="line">    <span class="keyword">return</span> reduce(<span class="keyword">lambda</span> x, y: x * <span class="number">10</span> + y, <span class="built_in">map</span>(char2num, s))</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">练习题</span></span><br><span class="line"><span class="string">1、利用map()函数，把用户输入的不规范的英文名字，变为首字母大写，其他小写的规范名字。</span></span><br><span class="line"><span class="string">输入：[&#x27;adam&#x27;, &#x27;LISA&#x27;, &#x27;barT&#x27;]，输出：[&#x27;Adam&#x27;, &#x27;Lisa&#x27;, &#x27;Bart&#x27;]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">2、python提供的sum()函数可以接受一个list并求和，请编写一个prod()函数，可以接受一个list</span></span><br><span class="line"><span class="string">并利用reduce()求积</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">3、利用map和reduce编写一个str2float函数，把字符串&#x27;123.456&#x27;转换成浮点数123.456</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">normalize</span>(<span class="params">name</span>):</span><br><span class="line">    <span class="keyword">return</span> name[<span class="number">0</span>].upper() + name[<span class="number">1</span>:].lower()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">prod</span>(<span class="params">L</span>):</span><br><span class="line">    <span class="keyword">return</span> reduce(<span class="keyword">lambda</span> x, y : x * y , L)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">str2float</span>(<span class="params">s</span>):</span><br><span class="line">    idx = s.index(<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">    L1 = s[<span class="number">0</span>:idx]</span><br><span class="line">    <span class="comment">#return L1 </span></span><br><span class="line">    L2 = s[(idx + <span class="number">1</span>):]</span><br><span class="line">    f1 = reduce(<span class="keyword">lambda</span> x, y: <span class="built_in">float</span>(x) * <span class="number">10</span> + <span class="built_in">float</span>(y), L1)</span><br><span class="line">    <span class="comment">#return f1</span></span><br><span class="line">    f2 = reduce(<span class="keyword">lambda</span> x, y: <span class="built_in">float</span>(x) * <span class="number">10</span> + <span class="built_in">float</span>(y), L2)</span><br><span class="line">    <span class="keyword">return</span> f1 + f2 / <span class="number">10</span>**<span class="built_in">len</span>(L2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 优化后</span></span><br><span class="line">DIGITS = &#123;<span class="string">&#x27;0&#x27;</span>: <span class="number">0</span>, <span class="string">&#x27;1&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;2&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;3&#x27;</span>: <span class="number">3</span>, <span class="string">&#x27;4&#x27;</span>: <span class="number">4</span>,</span><br><span class="line">          <span class="string">&#x27;5&#x27;</span>: <span class="number">5</span>, <span class="string">&#x27;6&#x27;</span>: <span class="number">6</span>, <span class="string">&#x27;7&#x27;</span>: <span class="number">7</span>, <span class="string">&#x27;8&#x27;</span>: <span class="number">8</span>, <span class="string">&#x27;9&#x27;</span>: <span class="number">9</span>&#125;</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">str2float</span>(<span class="params">s</span>):</span><br><span class="line">    str_arr = s.split(<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">    char2num = <span class="keyword">lambda</span> s: DIGITS[s]</span><br><span class="line">    lam = <span class="keyword">lambda</span> x, y: x * <span class="number">10</span> + y</span><br><span class="line">    <span class="keyword">return</span> reduce(lam, <span class="built_in">map</span>(char2num, str_arr[<span class="number">0</span>])) + \</span><br><span class="line">        reduce(lam, <span class="built_in">map</span>(char2num, str_arr[<span class="number">1</span>])) / (<span class="number">10</span> ** <span class="built_in">len</span>(str_arr[<span class="number">1</span>]))</span><br></pre></td></tr></table></figure>



<br/>



<h6 id="（2）filter"><a href="#（2）filter" class="headerlink" title="（2）filter"></a>（2）filter</h6><p>Python内建的<code>filter()</code>函数用于过滤序列。</p>
<p>和<code>map()</code>类似，<code>filter()</code>也接收一个函数和一个序列。和<code>map()</code>不同的是，<code>filter()</code>把传入的函数依次作用于每个元素，然后根据返回值是<code>True</code>还是<code>False</code>决定保留还是丢弃该元素。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 例如，在一个list中，删掉偶数，只保留奇数，可以这么写。</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">is_odd</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">return</span> n % <span class="number">2</span> == <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(<span class="built_in">filter</span>(is_odd, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">15</span>]))</span><br><span class="line">[<span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">15</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把一个序列中的空字符串删掉，可以这么写</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">not_empty</span>(<span class="params">s</span>):</span><br><span class="line">    <span class="keyword">return</span> s <span class="keyword">and</span> s.strip()</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(<span class="built_in">filter</span>(not_empty, [<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="literal">None</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;    &#x27;</span>]))</span><br><span class="line">[<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可见用filter()这个高阶函数，关键在于正确实现一个“筛选”函数</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">注意到filter()函数返回的是一个Iterator，也就是一个惰性序列，所以要强迫filter()完成计算结</span></span><br><span class="line"><span class="string">果，需要使用list()函数获得所有结果并返回list。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 用filter求素数——埃氏筛法</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 先构造一个从3开始的奇数序列——这是一个生成器，并且是一个无限序列</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_odd_iter</span>():</span><br><span class="line">    n = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        n = n + <span class="number">2</span></span><br><span class="line">        <span class="keyword">yield</span> n</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 再定义一个筛选函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_not_divisible</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">lambda</span> x: x % n &gt; <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 最后，定义一个生成器，不断返回下一个素数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">primes</span>():</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">    it = _odd_iter()  <span class="comment"># 初始序列</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        n = <span class="built_in">next</span>(it)  <span class="comment"># 返回序列的第一个数</span></span><br><span class="line">        <span class="keyword">yield</span> n</span><br><span class="line">        it = <span class="built_in">filter</span>(_not_divisible(n), it) <span class="comment"># 构造新序列</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这个生成器先返回第一个素数2，然后利用filter()不断产生筛选后的新序列。</span></span><br><span class="line"><span class="comment"># 由于primes()也是一个无限序列，所以调用时需要设置一个退出循环的条件</span></span><br><span class="line"><span class="comment"># 打印1000以内的素数</span></span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> primes():</span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">1000</span>:</span><br><span class="line">        <span class="built_in">print</span>(n)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"><span class="comment"># 练习：回数是指从左向右和从右向左读都是一样的数，例如12321，909。请使用filter()筛选</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">is_palindrome</span>(<span class="params">n</span>):</span><br><span class="line">    s = <span class="built_in">str</span>(n)</span><br><span class="line">    revs = s[::-<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">return</span> s == revs</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">num</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">yield</span> i</span><br><span class="line">        </span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(<span class="built_in">filter</span>(is_palindrome, num(<span class="number">1000</span>))))</span><br></pre></td></tr></table></figure>



<br/>



<h6 id="（3）sorted排序算法"><a href="#（3）sorted排序算法" class="headerlink" title="（3）sorted排序算法"></a>（3）sorted排序算法</h6><p>Python内置的<code>sorted()</code>函数就可以对list进行排序</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">sorted</span>([<span class="number">36</span>, <span class="number">5</span>, -<span class="number">12</span>, <span class="number">9</span>, -<span class="number">21</span>])</span><br><span class="line">[-<span class="number">21</span>, -<span class="number">12</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">36</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 此外，sorted()函数也是一个高阶函数，它还可以接收一个key函数来实现自定义的排序，</span></span><br><span class="line"><span class="comment"># 例如按绝对值大小排序</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">key指定的函数将作用于list的每一个元素上，并根据key函数返回的结果进行排序。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">sorted</span>([<span class="number">36</span>, <span class="number">5</span>, -<span class="number">12</span>, <span class="number">9</span>, -<span class="number">21</span>], key = <span class="built_in">abs</span>)</span><br><span class="line">[<span class="number">5</span>, <span class="number">9</span>, -<span class="number">12</span>, -<span class="number">21</span>, <span class="number">36</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 忽略大小写按字母排序，我们用一个key函数把字符串映射为忽略大小写排序即可。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">忽略大小写来比较两个字符串，实际上就是先把字符串都变成大/小写</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">sorted</span>([<span class="string">&#x27;bob&#x27;</span>, <span class="string">&#x27;about&#x27;</span>, <span class="string">&#x27;Zoo&#x27;</span>, <span class="string">&#x27;Credit&#x27;</span>], key = <span class="built_in">str</span>.lower)</span><br><span class="line">[<span class="string">&#x27;about&#x27;</span>, <span class="string">&#x27;bob&#x27;</span>, <span class="string">&#x27;Credit&#x27;</span>, <span class="string">&#x27;Zoo&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 要进行反向排序，不必改动key函数，可以传入第三个参数reverse = True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">sorted</span>([<span class="string">&#x27;bob&#x27;</span>, <span class="string">&#x27;about&#x27;</span>, <span class="string">&#x27;Zoo&#x27;</span>, <span class="string">&#x27;Credit&#x27;</span>], key = <span class="built_in">str</span>.lower, reverse=<span class="literal">True</span>)</span><br><span class="line">[<span class="string">&#x27;Zoo&#x27;</span>, <span class="string">&#x27;Credit&#x27;</span>, <span class="string">&#x27;bob&#x27;</span>, <span class="string">&#x27;about&#x27;</span>]</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 练习——假设我们用一组tuple表示学生名字和成绩</span></span><br><span class="line">L = [(<span class="string">&#x27;Bob&#x27;</span>, <span class="number">75</span>), (<span class="string">&#x27;Adam&#x27;</span>, <span class="number">92</span>), (<span class="string">&#x27;Bart&#x27;</span>, <span class="number">66</span>), (<span class="string">&#x27;Lisa&#x27;</span>, <span class="number">88</span>)]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用sorted()对上述列表分别按名字排序</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">by_name</span>(<span class="params">t</span>):</span><br><span class="line">	<span class="keyword">return</span> t[<span class="number">0</span>]</span><br><span class="line"><span class="built_in">sorted</span>(L, key = by_name)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 再按成绩从高到低排序</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">by_score</span>(<span class="params">t</span>):</span><br><span class="line">    <span class="keyword">return</span> t[<span class="number">1</span>]</span><br><span class="line"><span class="built_in">sorted</span>(L, key = by_score, reverse = <span class="literal">True</span>)</span><br></pre></td></tr></table></figure>



<br/>



<h5 id="【2】函数作为返回值"><a href="#【2】函数作为返回值" class="headerlink" title="【2】函数作为返回值"></a>【2】函数作为返回值</h5><p>高阶函数除了可以接受函数作为参数外，还可以把函数作为结果值返回。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 通常情况下求和函数是这样定义的</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">calc_sum</span>(<span class="params">*args</span>):</span><br><span class="line">    ax = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> args:</span><br><span class="line">        ax = ax + n</span><br><span class="line">    <span class="keyword">return</span> ax</span><br><span class="line"></span><br><span class="line"><span class="comment"># 但是，如果不需要立刻求和，而是在后面的代码中，根据需要再计算怎么办？可以返回求和的函数。</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">lazy_sum</span>(<span class="params">*args</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sum</span>():</span><br><span class="line">        ax = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> args:</span><br><span class="line">            ax = ax + n</span><br><span class="line">        <span class="keyword">return</span> ax</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 当我们调用lazy_sum()时，返回的并不是求和结果，而是求和函数</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = lazy_sum(<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f</span><br><span class="line">&lt;function lazy_sum.&lt;<span class="built_in">locals</span>&gt;.<span class="built_in">sum</span> at <span class="number">0x102a3dc60</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用函数f时，才是真正计算求和的结果</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f()</span><br><span class="line"><span class="number">25</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">在上面这个例子中，我们在函数lazy_sum中又定义了函数sum，并且，内部函数sum可以引用外部函数</span></span><br><span class="line"><span class="string">lazy_sum的参数和局部变量，当lazy_sum返回函数sum时，相关参数和变量都保存在返回的函数中，</span></span><br><span class="line"><span class="string">这种称为“闭包（Closure）”的程序结构拥有极大的威力。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 当我们调用lazy_sum()时，每次调用都会返回一个新的函数，即使传入相同的参数</span></span><br><span class="line"><span class="comment"># f1()和f2()的调用结果互不影响</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f1 = lazy_sum(<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f2 = lazy_sum(<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f1 == f2</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 闭包</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">注意到返回的函数在其定义内部有用了局部变量args，所以，当一个函数返回了一个函数后，其内部的局</span></span><br><span class="line"><span class="string">部变量还被新函数引用，所以，闭包用起来简单，实现起来可不容易。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">另一个需要注意的问题是，返回的函数并没有立刻执行，而是直到调用了f()才执行</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">count</span>():</span><br><span class="line">    fs = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">4</span>):</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">f</span>():</span><br><span class="line">            <span class="keyword">return</span> i * i</span><br><span class="line">        fs.append(f)</span><br><span class="line">    <span class="keyword">return</span> fs</span><br><span class="line"></span><br><span class="line">f1, f2, f3 = count()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 你可能认为调用f1(), f2()和f3()结果应该是1，4，9，但实际结果是：</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f1()</span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f2()</span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f3()</span><br><span class="line"><span class="number">9</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果全都是9</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">原因就在于返回的函数引用了变量i，但它并非立刻执行。等到3个函数都返回时，它们所引用的变量i已经变成了3，因此最终结果为9。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">注意：返回闭包时牢记一点：返回函数不要引用任何循环变量，或者后续会发生变化的变量。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果一定要引用循环变量怎么办？方法是再创建一个函数，用该函数的参数绑定循环变量当前的值，</span></span><br><span class="line"><span class="comment"># 无论该循环变量后续如何更改，已绑定到函数参数的值不变</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">缺点是代码较长，可利用lambda函数缩短代码</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">count</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">j</span>):</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">g</span>():</span><br><span class="line">            <span class="keyword">return</span> j * j</span><br><span class="line">       	<span class="keyword">return</span> g</span><br><span class="line">    </span><br><span class="line">    fs = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">4</span>):</span><br><span class="line">        fs.append(f(i))  <span class="comment">#f(i)立刻被执行，因此i当前值被传入f()</span></span><br><span class="line">    <span class="keyword">return</span> fs</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f1, f2, f3 = count()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f1()</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f2()</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f3()</span><br><span class="line"><span class="number">9</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># nonlocal</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">使用闭包，就是内层函数引用了外层函数的局部变量。如果只是读外层变量的值，我们会发现返回的闭包</span></span><br><span class="line"><span class="string">函数调用一切正常</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">inc</span>():</span><br><span class="line">    x = <span class="number">0</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fn</span>():</span><br><span class="line">        <span class="comment"># 仅读取x的值</span></span><br><span class="line">        <span class="keyword">return</span> x + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> fn</span><br><span class="line"></span><br><span class="line">f = inc()</span><br><span class="line"><span class="built_in">print</span>(f()) <span class="comment"># 1</span></span><br><span class="line"><span class="built_in">print</span>(f()) <span class="comment"># 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 但是，如果对外层变量赋值，由于Python解释器会把x当作函数fn()的局部变量，他会报错：</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">inc</span>():</span><br><span class="line">    x = <span class="number">0</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fn</span>():</span><br><span class="line">        <span class="comment"># nonlocal x</span></span><br><span class="line">        x = x + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    <span class="keyword">return</span> fn</span><br><span class="line"></span><br><span class="line">f = inc()</span><br><span class="line"><span class="comment"># 将nonlocal x的注释放开</span></span><br><span class="line"><span class="built_in">print</span>(f()) <span class="comment"># 1</span></span><br><span class="line"><span class="built_in">print</span>(f()) <span class="comment"># 2</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">原因是x作为局部变量并没有初始化，直接计算x+1是不行的。但我们其实是想引用inc()函数内部的x，</span></span><br><span class="line"><span class="string">所以需要在fn()函数内部加一个nonlocal x的声明。加上这个声明后，解释器把fn()的x看作外层函数</span></span><br><span class="line"><span class="string">的局部变量，它已经被初始化了，可以正确计算x+1</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">注意：使用闭包时，对外层变量赋值前，需要先使用nonlocal声明该变量不是当前函数的局部变量。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 练习——利用闭包返回一个计数器函数，每次调用它返回递增整数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">createCounter</span>():</span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">counter</span>():</span><br><span class="line">        <span class="keyword">nonlocal</span> i</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> i</span><br><span class="line">    <span class="keyword">return</span> counter</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<br/>



<h5 id="【3】匿名函数"><a href="#【3】匿名函数" class="headerlink" title="【3】匿名函数"></a>【3】匿名函数</h5><p>当我们在传入函数时，有些时候，不需要显示定义函数，直接传入匿名函数更方便。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在Python中，对匿名函数提供了有限支持。还是以map()函数为例，计算f(x) = x^2时，除了定义</span></span><br><span class="line"><span class="comment"># 一个f(x)的函数外，还可以直接传入匿名函数：</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x: x * x, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]))</span><br><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过对比可以看出，匿名函数lambda x: x * x实际上就是</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> x * x</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关于lambda表示匿名函数</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">冒号前面的x表示函数参数。</span></span><br><span class="line"><span class="string">匿名函数有个限制，就是只能有一个表达式，不用写return，返回值就是该表达式的结果。</span></span><br><span class="line"><span class="string">用匿名函数有个好处，因为函数没有名字，不必担心函数名起冲突。此外，匿名函数也是一个函数对象，</span></span><br><span class="line"><span class="string">也可以把匿名函数赋值给一个变量，再利用变量来调用该函数</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = <span class="keyword">lambda</span> x: x * x</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f</span><br><span class="line">&lt;function &lt;<span class="keyword">lambda</span>&gt; at <span class="number">0x100d4e8c0</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f(<span class="number">5</span>)</span><br><span class="line"><span class="number">25</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 同样，也可以把匿名函数作为返回值返回，比如：</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">build</span>(<span class="params">x, y</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">lambda</span>: x * x + y * y</span><br></pre></td></tr></table></figure>



<br/>



<h5 id="【4】装饰器"><a href="#【4】装饰器" class="headerlink" title="【4】装饰器"></a>【4】装饰器</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 由于函数也是一个对象，而且函数对象可以被赋值给变量，所以，通过变量也能调用该函数。</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">now</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;2015-3-25&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = now</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f()</span><br><span class="line"><span class="number">2015</span>-<span class="number">3</span>-<span class="number">25</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 函数对象有一个__name__属性（注意：是前后各两个下划线），可以拿到函数的名字</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>now.__name__</span><br><span class="line"><span class="string">&#x27;now&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.__name__</span><br><span class="line"><span class="string">&#x27;now&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#何为装饰器？</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">现在，假设我们要增强now()函数的功能，比如，在函数调用前后自动打印日志，但又不希望修改now()</span></span><br><span class="line"><span class="string">函数的定义，这种在代码运行期间动态增强功能的方式，称之为“装饰器”（Decorator）。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">本质上，decorator就是一个返回函数的高阶函数。所以，我们要定义一个能打印日志的decorator，</span></span><br><span class="line"><span class="string">可以定义如下：</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">log</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kw</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;call %s():&quot;</span> % func.__name__)</span><br><span class="line">        <span class="keyword">return</span> func(*args, **kw)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="comment"># 观察上面的log，因为它是一个decorator，所以接受一个函数作为参数，并返回一个函数。</span></span><br><span class="line"><span class="comment"># 我们借助Python的@语法，把decorator置于函数的定义处：</span></span><br><span class="line"><span class="meta">@log</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">now</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;2015-3-25&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用now()函数，不仅会运行now()函数本身，还会在运行now()函数前打印一行日志：</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>now()</span><br><span class="line">call now():</span><br><span class="line"><span class="number">2015</span>-<span class="number">3</span>-<span class="number">25</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 把@log放到now()函数的定义处，相当于执行了语句：</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">由于log()是一个decorator，返回一个函数，所以，原来的now()函数仍然存在，只是现在同名的now</span></span><br><span class="line"><span class="string">变量指向了新的函数，于是调用now()将执行新函数，即在log()函数中返回的wrapper()函数。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">wrapper()函数的参数定义是(*args, **kw)，因此，wrapper()函数可以接受任意参数的调用。</span></span><br><span class="line"><span class="string">在wrapper()函数内，首先打印日志，再紧接着调用原始函数。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">now = log(now)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果decorator本身需要传入参数，那就需要编写一个返回decorator的高阶函数，写出来会更复杂</span></span><br><span class="line"><span class="comment"># 比如，要自定义log的文本</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">log</span>(<span class="params">text</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">decorator</span>(<span class="params">func</span>):</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kw</span>):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;%s %s():&#x27;</span> % (text, func.__name__))</span><br><span class="line">            <span class="keyword">return</span> func(*args, **kw)</span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line">    <span class="keyword">return</span> decorator</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这个三层嵌套的decorator用法如下：</span></span><br><span class="line"><span class="meta">@log(<span class="params"><span class="string">&#x27;execute&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">now</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;2015-3-25&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>now()</span><br><span class="line">execute now():</span><br><span class="line"><span class="number">2015</span>-<span class="number">3</span>-<span class="number">25</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 和两层嵌套的decorator相比，3层嵌套的效果是这样的</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">我们来剖析上面的语句，首先执行log(&#x27;execute&#x27;)，返回的是decorator函数，再调用返回的函数，</span></span><br><span class="line"><span class="string">参数是now函数，返回值最终是wrapper函数。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>now = log(<span class="string">&#x27;execute&#x27;</span>)(now)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以上两种decorator的定义都没有问题，但还差最后一步。因为我们讲了函数也是对象，它有</span></span><br><span class="line"><span class="comment"># __name__等属性，但你去看经过decorator装饰之后的函数，它们的__name__已经从原来的</span></span><br><span class="line"><span class="comment"># &#x27;now&#x27;变成了&#x27;wrapper&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>now.__name__</span><br><span class="line"><span class="string">&#x27;wrapper&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">因为返回的那个wrapper()函数名字就是&#x27;wrapper&#x27;，所以，需要把原始函数的__name__等属性复制</span></span><br><span class="line"><span class="string">到wrapper()函数中，否则，有些依赖函数签名的代码就会出错。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">不需要编写wrapper.__name__ = func.__name__这样的代码，Python内置的functools.wraps</span></span><br><span class="line"><span class="string">就是干这个事的，所以，一个完整的decorator的写法如下：</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">log</span>(<span class="params">func</span>):</span><br><span class="line"><span class="meta">	@functools.wraps(<span class="params">func</span>)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kw</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;call %s():&#x27;</span> % func.__name__)</span><br><span class="line">        <span class="keyword">return</span> func(*args, **kw)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者针对带参数的decorator</span></span><br><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">log</span>(<span class="params">text</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">decorator</span>(<span class="params">func</span>):</span><br><span class="line"><span class="meta">        @functools.wraps(<span class="params">func</span>)</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kw</span>):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;%s %s():&#x27;</span> % (text, func.__name__))</span><br><span class="line">            <span class="keyword">return</span> func(*args, **kw)</span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line">    <span class="keyword">return</span> decorator</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 作业——请设计一个decorator，它可作用于任何函数上，并打印该函数的执行时间</span></span><br><span class="line"><span class="keyword">import</span> time, functools</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">metric</span>(<span class="params">fn</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kw</span>):</span><br><span class="line">        begin = time.time()</span><br><span class="line">        result = fn(*args, **kw)</span><br><span class="line">        end = time.time()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;%s executed in %s s&#x27;</span> % (fn.__name__, end - begin))</span><br><span class="line">    	<span class="keyword">return</span> result</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"><span class="comment"># 测试</span></span><br><span class="line"><span class="meta">@metric</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fast</span>(<span class="params">x, y</span>):</span><br><span class="line">    time.sleep(<span class="number">0.0012</span>)</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line"></span><br><span class="line"><span class="meta">@metric</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">slow</span>(<span class="params">x, y, z</span>):</span><br><span class="line">    time.sleep(<span class="number">0.1234</span>)</span><br><span class="line">    <span class="keyword">return</span> x * y * z</span><br><span class="line"></span><br><span class="line">f = fast(<span class="number">11</span>, <span class="number">22</span>)</span><br><span class="line">s = slow(<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>)</span><br><span class="line"><span class="keyword">if</span> f != <span class="number">33</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;测试失败！&#x27;</span>)</span><br><span class="line"><span class="keyword">elif</span> s != <span class="number">7986</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;测试失败！&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment"># 附加题——再思考一下能否写出一个@log的decorator，使它同时支持下面两种函数</span></span><br><span class="line"><span class="meta">@log</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>():</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@log(<span class="params"><span class="string">&#x27;execute&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>():</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> functools, time</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">log</span>(<span class="params">*args</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">decorator</span>(<span class="params">func</span>):</span><br><span class="line"><span class="meta">        @functools.wraps(<span class="params">func</span>)</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kw</span>):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;begin call&#x27;</span>)</span><br><span class="line">            result = func(*args, **kw)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;end call&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line">    <span class="keyword">return</span> decorator</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试</span></span><br><span class="line"><span class="meta">@log() </span><span class="comment"># 不加括号会报错</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>():</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&#x27;call function done&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@log(<span class="params"><span class="string">&#x27;execute&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">g</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;call function done&#x27;</span>)</span><br><span class="line"></span><br><span class="line">f()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">g()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">log1</span>(<span class="params">arg=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">decorator</span>(<span class="params">func=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> func:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;function %s():&#x27;</span> % arg.__name__)</span><br><span class="line">            <span class="keyword">return</span> arg()</span><br><span class="line"></span><br><span class="line"><span class="meta">        @functools.wraps(<span class="params">func</span>)</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kw</span>):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;%s %s():&#x27;</span> % (arg, func.__name__))</span><br><span class="line">            <span class="keyword">return</span> func(*args, **kw)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> decorator</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">log2</span>(<span class="params">arg=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">decorator</span>(<span class="params">func</span>):</span><br><span class="line"><span class="meta">        @functools.wraps(<span class="params">func</span>)</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">            <span class="keyword">if</span> arg <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;Calling function <span class="subst">&#123;func.__name__&#125;</span>&quot;</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;arg&#125;</span> - Calling function <span class="subst">&#123;func.__name__&#125;</span>&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">callable</span>(arg):</span><br><span class="line">        <span class="keyword">return</span> decorator(arg)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> decorator</span><br></pre></td></tr></table></figure>



<br/>



<p><strong>小结：</strong></p>
<p>在面向对象（OOP）的设计模式中，decorator被称为装饰模式。OOP的装饰模式需要通过继承和组合来实现，而Python除了能支持OOP的decorator外，直接从语法层次支持decorator。Python的decorator可以用函数实现，也可以用类实现。</p>
<p>decorator可以增强函数的功能，定义起来虽然有点复杂，但使用起来非常灵活和方便。</p>
<br/>



<h5 id="【5】偏函数"><a href="#【5】偏函数" class="headerlink" title="【5】偏函数"></a>【5】偏函数</h5><p>Python的<code>functools</code>模块提供了很多有用的功能，其中一个就是偏函数（Partial function）。要注意，这里的偏函数和数学意义上的偏函数不一样。</p>
<p>在介绍函数参数的时候，我们讲到，通过设定参数的默认值，可以降低参数调用的难度。而偏函数也可以做到这一点。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># int()函数可以把字符串转换为整数，当仅传入字符串时，int()函数默认按十进制转换</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">int</span>(<span class="string">&#x27;123456&#x27;</span>)</span><br><span class="line"><span class="number">123456</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 但int()函数还提供额外的base参数，默认值为10。如果传入base参数，可以做到N进制转换</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">int</span>(<span class="string">&#x27;12345&#x27;</span>, base = <span class="number">8</span>)</span><br><span class="line"><span class="number">5349</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">int</span>(<span class="string">&#x27;12345&#x27;</span>, <span class="number">16</span>)</span><br><span class="line"><span class="number">74565</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 假设要转换大量的二进制字符串，每次都传入int(x, base = 2)非常麻烦，于是，我们想到了，</span></span><br><span class="line"><span class="comment"># 可以定义一个int2()的函数，默认把base=2传进去：</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">int2</span>(<span class="params">x, base = <span class="number">2</span></span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">int</span>(x, base)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>int2(<span class="string">&#x27;1000000&#x27;</span>)</span><br><span class="line"><span class="number">64</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>int2(<span class="string">&#x27;1010101&#x27;</span>)</span><br><span class="line"><span class="number">85</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># functools.partial就是帮助我们创建一个偏函数的，不需要我们自己定义int2()，可以直接使用</span></span><br><span class="line"><span class="comment"># 下面的代码创建一个新的函数int2</span></span><br><span class="line"><span class="keyword">import</span> functools</span><br><span class="line">int2 = functools.partial(<span class="built_in">int</span>, base = <span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>int2(<span class="string">&#x27;1000000&#x27;</span>)</span><br><span class="line"><span class="number">64</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>int2(<span class="string">&#x27;1010101&#x27;</span>)</span><br><span class="line"><span class="number">85</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 所以，简单总结functools.partial的作用就是，把一个函数的某些参数给固定住</span></span><br><span class="line"><span class="comment">#（也就是设置默认值），返回一个新的函数，调用这个新函数会更简单。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意上面的新的int2函数，仅仅是把base参数重新设定默认值为2，但也可在函数调用时传入其他值</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>int2(<span class="string">&#x27;1000000&#x27;</span>, base = <span class="number">10</span>)</span><br><span class="line"><span class="number">1000000</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 最后，创建偏函数时，实际上可以接收函数对象、*args和**kw这3个参数，当传入：</span></span><br><span class="line">int2 = functools.partial(<span class="built_in">int</span>, base = <span class="number">2</span>)</span><br><span class="line"><span class="comment"># 实际上固定了int()函数的关键字参数base，也就是：</span></span><br><span class="line">int2(<span class="string">&#x27;10010&#x27;</span>)</span><br><span class="line"><span class="comment"># 相当于：</span></span><br><span class="line">kw = &#123;<span class="string">&#x27;base: 2&#x27;</span>&#125;</span><br><span class="line"><span class="built_in">int</span>(<span class="string">&#x27;10010&#x27;</span>, **kw)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当传入</span></span><br><span class="line">max2 = functools.partial(<span class="built_in">max</span>, <span class="number">10</span>)</span><br><span class="line"><span class="comment"># 实际上会把10作为*args的一部分自动加到左边，也就是</span></span><br><span class="line">max2(<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>)	<span class="string">&quot;相当于&quot;</span>	args = (<span class="number">10</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>); <span class="built_in">max</span>(*args)</span><br><span class="line"><span class="comment"># 结果为10</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<br/>



<h2 id="5、模块"><a href="#5、模块" class="headerlink" title="5、模块"></a>5、模块</h2><p>为了编写可维护的代码，我们把很多函数分组，分别放到不同的文件里。这样，每个文件包含的代码就相对较少，很多编程语言都采用这种组织代码的方式。在Python中，一个<code>.py</code>文件就称为一个<code>模块</code>（Module）。</p>
<p>使用模块最大的好处就是大大提高了代码的可维护性。其次，编写代码不必从零开始。当一个模块编写完毕，就可以被其他地方引用。我们在编写程序的时候，也经常引用其他模块，包括Python内置的模块和来自第三方的模块。</p>
<p>使用模块还可以避免函数名和变量名冲突。相同名字的函数和变量完全可以分别存在不同的模块中，因此，我们自己在编写模块时，不必考虑名字会与其他模块冲突。但是也要注意，尽量不要与内置函数名字冲突。点<a target="_blank" rel="noopener" href="http://docs.python.org/3/library/functions.html">这里</a>查看Python的所有内置函数。</p>
<p>你也许还想到，如果不同的人编写的模块名相同怎么办？为了避免模块名冲突，Python又引入了按目录来组织模块的方法，称为<code>包</code>（Package）。</p>
<br/>

<p>现在我们假设abc和xyz这两个模块与其他模块冲突了，于是我们可以通过包来组织模块，避免冲突。方法是选择一个顶层包名，比如<code>mycompany</code>，按照如下目录存放：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mycompany</span><br><span class="line">├─ __init__.py</span><br><span class="line">├─ abc.py</span><br><span class="line">└─ xyz.py</span><br></pre></td></tr></table></figure>

<p>引入了包以后，只要顶层的包名不与别人冲突，那所有模块都不会与别人冲突。现在，<code>abc.py</code>模块的名字就变成了<code>mycompany.abc</code>，类似的，<code>xyz.py</code>模块就变成了<code>mycompany.xyz</code>。</p>
<p>请注意，每一个包目录下面都会有一个<code>__init__.py</code>的文件，这个文件是必须存在的，否则，Python就把这个目录当成普通目录，而不是一个包。</p>
<p><code>__init__.py</code>可以是空文件，也可以有Python代码，因为<code>__init__.py</code>本身就是一个模块，而它的模块名就是<code>mycompany</code>。</p>
<p>类似的，可以有多级目录，组成多级层次的包结构。比如下列：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mycompany</span><br><span class="line"> ├─ web</span><br><span class="line"> │  ├─ __init__.py</span><br><span class="line"> │  ├─ utils.py</span><br><span class="line"> │  └─ www.py</span><br><span class="line"> ├─ __init__.py</span><br><span class="line"> ├─ abc.py</span><br><span class="line"> └─ utils.py</span><br></pre></td></tr></table></figure>

<p>文件<code>www.py</code>模块名就是<code>mycompany.web.www</code>，两个文件<code>util.py</code>的模块名分别是<code>mycompany.utils</code>和<code>mycompany.web.utils</code>。</p>
<blockquote>
<p>自己创建模块时要注意命名，不能和Python自带的模块名称冲突。例如，系统自带了sys模块，自己的模块就不能命名为sys.py，否则将无法导入系统自带的sys模块。</p>
</blockquote>
<br/>



<h5 id="【1】使用模块"><a href="#【1】使用模块" class="headerlink" title="【1】使用模块"></a>【1】使用模块</h5><p>Python本身就内置了很多非常有用的模块，只要安装完毕，这些模块就可以立刻使用。</p>
<p>我们以内建的sys模块为例，编写一个hello模块。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment">#-*- coding: utf-8 -*-</span></span><br><span class="line"><span class="string">&#x27; a test module&#x27;</span></span><br><span class="line">__author__ = <span class="string">&#x27;Jason&#x27;</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>():</span><br><span class="line">    args = sys.argv</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(args) == <span class="number">1</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Hello, world&#x27;</span>)</span><br><span class="line">    <span class="keyword">elif</span> <span class="built_in">len</span>(args) == <span class="number">2</span>:</span><br><span class="line">    	<span class="built_in">print</span>(<span class="string">&#x27;Hello, %s!&#x27;</span> % args[<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Too many arguments!&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    test()</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">第1行和第2行是标准注释，第1行注释可以让这个hello.py文件直接在Unix/Linux/Mac上运行，</span></span><br><span class="line"><span class="string">第2行注释表示.py文件本身使用标准UTF-8编码；</span></span><br><span class="line"><span class="string">第3行是一个字符串，表示模块的文档注释，任何模块代码的第一个字符串都被视为模块的文档注释；</span></span><br><span class="line"><span class="string">第4行使用 __author__ 变量把作者写进去，这样当你公开源代码后别人就可以瞻仰你的大名；</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">你可能注意到了，使用sys模块的第一步就是导入该模块。import sys</span></span><br><span class="line"><span class="string">导入sys模块后，我们就有了变量sys指向该模块，利用sys这个变量就可以访问sys模块的所有功能。</span></span><br><span class="line"><span class="string">sys模块有一个argv变量，这个变量是用list存储了命令行的所有参数。argv至少有一个元素，因为</span></span><br><span class="line"><span class="string">第一个参数永远是该.py文件的名称，</span></span><br><span class="line"><span class="string">例如：运行 python3 hello.py 获得的 sys.argv 就是[&#x27;hello.py&#x27;]；</span></span><br><span class="line"><span class="string">运行 python3 hello.py Michael 获得的 sys.argv 就是 [&#x27;hello.py&#x27;, &#x27;Michael&#x27;]。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>



<br/>



<p><strong>作用域</strong></p>
<p>在一个模块中，我们希望有的函数和变量仅仅在模块内部使用。在Python中，是通过<code>_</code>前缀来实现的。</p>
<p>正常的函数和变量名是公开的（public），可以被直接引用，比如：<code>abc</code>，<code>x123</code>，<code>PI</code>等；</p>
<p>类似<code>__xxx__</code>这样的变量是特殊变量，可以被直接引用，但是有特殊用途，比如上面的<code>__author__</code>，<code>__name__</code>就是特殊变量，<code>hello</code>模块定义的文档注释也可以用特殊变量<code>__doc__</code>访问，我们自己的变量一般不要用这种变量名；</p>
<p>类似<code>_xxx</code>和<code>__xxx</code>这样的函数或变量就是非公开的（private），不应该被直接引用，比如<code>_abc</code>，<code>__abc</code>等；</p>
<p>之所以我们说，private函数和变量<code>不应该</code>被直接引用，而不是<code>不能</code>被直接引用，是因为Python并没有一种方法可以完全限制访问private函数或变量，但是，从编程习惯上不应该引用private函数或变量。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># private函数或变量不应该被别人引用，那它们有什么用呢？请看例子：</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_private_1</span>(<span class="params">name</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Hello, %s&#x27;</span> % name</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_private_2</span>(<span class="params">name</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Hi, %s&#x27;</span> % name</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">greeting</span>(<span class="params">name</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(name) &gt; <span class="number">3</span>:</span><br><span class="line">        <span class="keyword">return</span> _private_1(name)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> _private_2(name)</span><br><span class="line">    </span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">我们在模块里公开greeting()函数，而把内部逻辑用private函数隐藏起来了，这样，</span></span><br><span class="line"><span class="string">调用greeting()函数就不用关心内部的private函数细节，这也是一种非常有用的代码封装和抽象方法</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">外部不需要引用的函数全部定义成private，只有外部需要引用的函数才定义为public。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>



<br/>



<h5 id="【2】安装第三方模块"><a href="#【2】安装第三方模块" class="headerlink" title="【2】安装第三方模块"></a>【2】安装第三方模块</h5><p>在Python中，安装第三方模块，是通过包管理工具<code>pip</code>完成的。如果你正在使用Mac或者Linux，安装pip本身这个步骤就可以跳过了。如果牛正在使用windows，安装python时确保勾选了<code>pip</code>和<code>Add python.exe to Path</code>。在命令提示符窗口下尝试运行pip，如果windows提示未找到命令，可以重新安装程序添加<code>pip</code>。</p>
<p>注意：Mac或Linux上有可能并存<code>Python 3.x</code>和<code>Python 2.x</code>，因此对应的pip命令是<code>pip3</code>。</p>
<p>例如，我们要安装一个第三方库——Python Imaging Library，这是Python下非常强大的处理图像的工具库。不过，PIL目前只支持到Python 2.7，并且有年头没有更新了，因此，基于PIL的Pillow项目开发非常活跃，并且支持最新的Python3。</p>
<p>一般来说，第三方库都会在Python官方的<code>pypi.python.org</code>网站注册，要安装一个第三方库，必须先知道该库的名称，可以在官网或者pypi上搜索，比如Pillow的名称叫Pillow，因此，安装Pillow的命令就是：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install Pillow</span><br></pre></td></tr></table></figure>

<p>耐心等待下载并安装后，就可以使用Pillow了。</p>
<br/>



<p><strong>安装常用模块</strong></p>
<p>在使用Python时，我们经常需要用到很多第三方库，例如上面提到的Pillow，以及MySQL驱动程序，Web框架Flask，科学计算Numpy等。用pip一个一个安装费时费力，还需要考虑兼容性。我们推荐直接使用<code>Anaconda</code>，这是一个基于Python的数据处理和科学计算平台，它已经内置了许多非常有用的第三方库，我们装上Anaconda，就相当于把数十个第三方模块自动安装好了，非常简单易用。</p>
<p>可以从<a target="_blank" rel="noopener" href="https://www.anaconda.com/download/">Anaconda官网</a>下载GUI安装包，安装包有500～600M，所以需要耐心等待下载。下载后直接安装，Anaconda会把系统Path中的python指向自己自带的Python，并且，Anaconda安装的第三方模块会安装在Anaconda自己的路径下，不影响系统已安装的Python目录。</p>
<p>安装好Anaconda后，重新打开命令行窗口，输入python，可以看到Anaconda的信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">┌────────────────────────────────────────────────────────┐</span><br><span class="line">│Command Prompt - python                           - □ x │</span><br><span class="line">├────────────────────────────────────────────────────────┤</span><br><span class="line">│Microsoft Windows [Version 10.0.0]                      │</span><br><span class="line">│(c) 2015 Microsoft Corporation. All rights reserved.    │</span><br><span class="line">│                                                        │</span><br><span class="line">│C:\&gt; python                                             │</span><br><span class="line">│Python 3.6.3 |Anaconda, Inc.| ... on win32              │</span><br><span class="line">│Type &quot;help&quot;, ... for more information.                  │</span><br><span class="line">│&gt;&gt;&gt; import numpy                                        │</span><br><span class="line">│&gt;&gt;&gt; _                                                   │</span><br><span class="line">│                                                        │</span><br><span class="line">│                                                        │</span><br><span class="line">│                                                        │</span><br><span class="line">└────────────────────────────────────────────────────────┘</span><br></pre></td></tr></table></figure>

<p>可以尝试直接<code>import numpy</code>等已安装的第三方模块。</p>
<br/>



<p><strong>模块搜索路径</strong></p>
<p>当我们试图加载一个模块时，Python会在指定的路径下搜索对应的.py文件，如果找不到，就会报错：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> mymodule</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">ImportError: No module named mymodule</span><br></pre></td></tr></table></figure>

<p>默认情况下，Python解释器会搜索当前目录、所有已安装的内置模块和第三方模块，搜索路径存放在sys模块的path变量中：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> sys</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.path</span><br><span class="line">[<span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;/Library/Frameworks/Python.framework/Versions/3.6/lib/python36.zip&#x27;</span>, <span class="string">&#x27;/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6&#x27;</span>, ..., <span class="string">&#x27;/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/site-packages&#x27;</span>]</span><br></pre></td></tr></table></figure>

<p>如果我们要添加自己的搜索目录，有两种方法：</p>
<p>一是直接修改sys.path，添加要搜索的目录：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> sys</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.path.append(<span class="string">&#x27;/Users/michael/my_py_scripts&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>这种方法是在运行时修改，运行结束后失效。</p>
<p>第二种方法是设置环境变量<code>PYTHONPATH</code>，该环境变量的内容会被自动添加到模块搜索路径中。设置方式与设置Path环境变量类似。注意只需要添加你自己的搜索路径，Python自己本身的搜索路径不受影响。</p>
<br/>



<h2 id="6、面向对象编程"><a href="#6、面向对象编程" class="headerlink" title="6、面向对象编程"></a>6、面向对象编程</h2><p>面向对象编程——Object Oriented Programming，简称OOP，是一种程序设计思想。OOP把对象作为程序的基本单元，一个对象包含了数据和操作数据的函数。</p>
<p>面向过程的程序设计把程序看作一系列的命令集合，即一组函数的顺序执行。为了简化程序设计，面向过程把函数继续切分为子函数，即把大块函数通过切割成小块函数来降低系统的复杂度。</p>
<p>而面向对象的程序设计把计算机程序视为一组对象的集合，而每个对象都可以接收其他对象发过来的消息，并处理这些消息，计算机程序的执行就是一系列消息在各个对象之间传递。</p>
<p>在Python中，所有数据都可视为对象，自己也可以定义对象。自定义的对象数据类型就是面向对象中的类的概念。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 类的定义</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, score</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.score = score</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">print_score</span>(<span class="params">self</span>):</span><br><span class="line">    	<span class="built_in">print</span>(<span class="string">&#x27;%s: %s&#x27;</span> % (self.name, self.score))    </span><br><span class="line">    </span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">注意到 __init__ 方法的第一个参数永远是self，表示创建的实例本身，因此，在 __init__方法</span></span><br><span class="line"><span class="string">内部，就可以把各种属性绑定到self，因为self就指向创建的实例本身。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">有了 __init__ 方法，在创建实例的时候，就不能传入空的参数了，必须传入与 __init__ 方法</span></span><br><span class="line"><span class="string">匹配的参数，但 self 不需要传，Python解释器自己会把实例变量传进去。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">和普通的函数相比，在类中定义的函数只有一点不同，就是第一个参数永远是实例变量self，并且，</span></span><br><span class="line"><span class="string">调用时，不用传递该参数。除此之外，类的方法和普通函数没有什么区别，所以，你仍然可以用默认</span></span><br><span class="line"><span class="string">参数、可变参数、关键字参数和命名关键字参数。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bart = Student(<span class="string">&quot;Bart Simon&quot;</span>, <span class="number">59</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bart.name</span><br><span class="line"><span class="string">&#x27;Bart Simpson&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bart.score</span><br><span class="line"><span class="number">59</span></span><br></pre></td></tr></table></figure>

<p>和静态语言不同，Python允许对实例变量绑定任何数据，也就是说，对于两个实例变量，虽然它们都是同一个类的不同实例，但拥有的变量名称都可能不同。（可以通过对象，以外在的形式给对象添加属性，注意：后续访问过程中只有该对象有新添加的属性，该对象回收后此属性也消失。）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>bart = Student(<span class="string">&#x27;Bart Simpson&#x27;</span>, <span class="number">59</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lisa = Student(<span class="string">&#x27;Lisa Simpson&#x27;</span>, <span class="number">87</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bart.age = <span class="number">8</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bart.age</span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lisa.age</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">AttributeError: <span class="string">&#x27;Student&#x27;</span> <span class="built_in">object</span> has no attribute <span class="string">&#x27;age&#x27;</span></span><br></pre></td></tr></table></figure>



<br/>



<h5 id="【1】类内部访问限制"><a href="#【1】类内部访问限制" class="headerlink" title="【1】类内部访问限制"></a>【1】类内部访问限制</h5><p>如果想让类内部属性不被外部访问，可以把属性的名称前加上<code>两个</code>下划线<code>__</code>，在Python中，实例变量名如果以<code>__</code>开头，就变成了一个私有变量（private），只有内部可以访问，外部不能访问。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, score</span>):</span><br><span class="line">        self.__name = name</span><br><span class="line">        self.__score = score</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">print_score</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;%s: %s&#x27;</span> % (self.__name, self.__score))</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bart = Student(<span class="string">&#x27;Bart Simpson&#x27;</span>, <span class="number">59</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bart.__name</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">AttributeError: <span class="string">&#x27;Student&#x27;</span> <span class="built_in">object</span> has no attribute <span class="string">&#x27;__name&#x27;</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment"># 如果外部代码要获取name和score怎么办？给Student类增加方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_name</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.__name</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_score</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.__score</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 允许外部代码修改score怎么办？</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">set_score</span>(<span class="params">self, score</span>):</span><br><span class="line">        self.__score = score</span><br><span class="line">        </span><br><span class="line"><span class="comment"># 为何大费周折定义一个方法修改属性,因为可对参数做检查,避免传入无效的参数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">set_score</span>(<span class="params">self, score</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="number">0</span> &lt;= score &lt;= <span class="number">100</span>:</span><br><span class="line">            self.__score = score</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&#x27;bad score&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>需要注意的是，在Python中，变量名类似<code>__xxx__</code>的，也就是以双下划线开头、双下划线结尾的，是特殊变量，特殊变量是可以直接访问的，不是private变量，所以，不能用<code>__name__</code>、<code>__score__</code>这样的变量名。</p>
<p>有时候，你会看到以一个下划线开头的实例变量名，比如<code>_name</code>，这样的实例变量外部是可以访问的，但是，按照约定俗成的规定，当你看到这样的变量时，意思就是，“虽然我可以被访问，但是，请把我视为私有变量，不要随意访问”。</p>
<p>双下划线开头的实例变量是不是一定不能从外部访问呢？其实也不是。不能直接访问<code>__name</code>是因为Python解释器对外把<code>__name</code>变量改成了<code>_Student__name</code>，所以，仍然可以通过<code>_Student__name</code>来访问<code>__name</code>变量：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>bart._Student__name</span><br><span class="line"><span class="string">&#x27;Bart Simpson&#x27;</span></span><br></pre></td></tr></table></figure>

<p>但是强烈建议你不要这么干，因为不同版本的Python解释器可能会把<code>__name</code>改成不同的变量名。</p>
<p>总的来说就是，Python本身没有任何机制阻止你干坏事，一切全靠自觉。</p>
<p>最后注意下面的这种<em>错误写法</em>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>bart = Student(<span class="string">&#x27;Bart Simpson&#x27;</span>, <span class="number">59</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bart.get_name()</span><br><span class="line"><span class="string">&#x27;Bart Simpson&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bart.__name = <span class="string">&#x27;New Name&#x27;</span> <span class="comment"># 设置__name变量！</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bart.__name</span><br><span class="line"><span class="string">&#x27;New Name&#x27;</span></span><br></pre></td></tr></table></figure>

<p>表面上看，外部代码“成功”地设置了<code>__name</code>变量，但实际上这个<code>__name</code>变量和class内部的<code>__name</code>变量<em>不是</em>一个变量！内部的<code>__name</code>变量已经被Python解释器自动改成了<code>_Student__name</code>，而外部代码给<code>bart</code>新增了一个<code>__name</code>变量。不信试试：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>bart.get_name() <span class="comment"># get_name()内部返回self.__name</span></span><br><span class="line"><span class="string">&#x27;Bart Simpson&#x27;</span></span><br></pre></td></tr></table></figure>



<br/>



<h5 id="【2】继承和多态"><a href="#【2】继承和多态" class="headerlink" title="【2】继承和多态"></a>【2】继承和多态</h5><p>在OOP程序设计中，当我们定义一个class的时候，可以从某个现有的class继承，新的class称为子类（Subclass），而被继承的class称为基类、父类或超类（Base class、Super class）。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Animal is running...&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们编写Dog和Cat类时，就可以直接从Animal类继承：</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>(<span class="title class_ inherited__">Animal</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span>(<span class="title class_ inherited__">Animal</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<p>继承有什么好处？最大的好处是子类获得了父类的全部功能。由于<code>Animial</code>实现了<code>run()</code>方法，因此，<code>Dog</code>和<code>Cat</code>作为它的子类，什么事也没干，就自动拥有了<code>run()</code>方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dog = Dog()</span><br><span class="line">dog.run()</span><br><span class="line">cat = Cat()</span><br><span class="line">cat.run()</span><br><span class="line">Animal <span class="keyword">is</span> running...</span><br><span class="line">Animal <span class="keyword">is</span> running...</span><br></pre></td></tr></table></figure>

<p>继承的第二个好处需要我们对代码做一点改进。你看到了，无论是<code>Dog</code>还是<code>Cat</code>，它们<code>run()</code>的时候，显示的都是<code>Animal is running...</code>，符合逻辑的做法是分别显示<code>Dog is running...</code>和<code>Cat is running...</code>，因此，对<code>Dog</code>和<code>Cat</code>类改进如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>(<span class="title class_ inherited__">Animal</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Dog is running...&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span>(<span class="title class_ inherited__">Animal</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Cat is running...&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>再次运行，结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Dog is running...</span><br><span class="line">Cat is running...</span><br></pre></td></tr></table></figure>

<p>当子类和父类都存在相同的<code>run()</code>方法时，我们说，子类的<code>run()</code>覆盖了父类的<code>run()</code>，在代码运行的时候，总是会调用子类的<code>run()</code>。这样，我们就获得了继承的另一个好处：多态。</p>
<p>要理解多态的好处，我们还需要再编写一个函数，这个函数接受一个<code>Animal</code>类型的变量：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">run_twice</span>(<span class="params">animal</span>):</span><br><span class="line">    animal.run()</span><br><span class="line">    animal.run()</span><br><span class="line">    </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>run_twice(Animal())</span><br><span class="line">Animal <span class="keyword">is</span> running...</span><br><span class="line">Animal <span class="keyword">is</span> running...</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>run_twice(Dog())</span><br><span class="line">Dog <span class="keyword">is</span> running...</span><br><span class="line">Dog <span class="keyword">is</span> running...</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>run_twice(Cat())</span><br><span class="line">Cat <span class="keyword">is</span> running...</span><br><span class="line">Cat <span class="keyword">is</span> running...</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,  name</span>):</span><br><span class="line">        self.__name = name</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;%s is running&#x27;</span> % self.__name)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run_twice</span>(<span class="params">self</span>):</span><br><span class="line">        self.run()</span><br><span class="line">        self.run()</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>(<span class="title class_ inherited__">Animal</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span>(<span class="title class_ inherited__">Animal</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tortoise</span>(<span class="title class_ inherited__">Animal</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Tortoise is running slowly...&#x27;</span>)</span><br><span class="line"></span><br><span class="line">dog = Dog(<span class="string">&#x27;Dog&#x27;</span>)</span><br><span class="line">cat = Cat(<span class="string">&#x27;Cat&#x27;</span>)</span><br><span class="line">tortoise = Tortoise(<span class="string">&#x27;Tortoise&#x27;</span>)</span><br><span class="line"></span><br><span class="line">dog.run_twice()</span><br><span class="line">cat.run_twice()</span><br><span class="line">tortoise.run_twice()</span><br></pre></td></tr></table></figure>



<br/>



<p>对于静态语言（例如Java）来说，如果需要传入<code>Animal</code>类型，则传入的对象必须是<code>Animal</code>类型或者它的子类，否则，将无法调用<code>run()</code>方法。</p>
<p>对于Python这样的动态语言来说，则不一定需要传入<code>Animal</code>类型。我们只需要保证传入的对象有一个<code>run()</code>方法就可以了。</p>
<p>这就是动态语言的“鸭子类型”，它并不要求严格的继承体系，一个对象只要“看起来像鸭子，走起路来像鸭子”，那它就可以被看做是鸭子。</p>
<br/>



<h5 id="【3】获取对象信息"><a href="#【3】获取对象信息" class="headerlink" title="【3】获取对象信息"></a>【3】获取对象信息</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用type</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(<span class="number">123</span>)</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;int&#x27;</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(<span class="string">&#x27;str&#x27;</span>)</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;str&#x27;</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(<span class="literal">None</span>)</span><br><span class="line">&lt;<span class="built_in">type</span>(<span class="literal">None</span>) <span class="string">&#x27;NoneType&#x27;</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果一个变量指向函数或者类，也可以使用type()判断</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(<span class="built_in">abs</span>)</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;builtin_function_or_method&#x27;</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># type()函数返回的是什么类型？它返回对应的Class类型。如果我们要在if语句</span></span><br><span class="line"><span class="comment"># 中判断，就需要比较两个变量的type类型是否相同</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(<span class="number">123</span>)==<span class="built_in">type</span>(<span class="number">456</span>)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(<span class="number">123</span>)==<span class="built_in">int</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(<span class="string">&#x27;abc&#x27;</span>)==<span class="built_in">type</span>(<span class="string">&#x27;123&#x27;</span>)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(<span class="string">&#x27;abc&#x27;</span>)==<span class="built_in">str</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(<span class="string">&#x27;abc&#x27;</span>)==<span class="built_in">type</span>(<span class="number">123</span>)</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断基本数据类型可以直接写int, str等，但如果要判断一个对象是否是函数</span></span><br><span class="line"><span class="comment"># 怎么办？可以使用types模块中定义的常量：</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> types</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">fn</span>():</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">pass</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(fn)==types.FunctionType</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(<span class="built_in">abs</span>)==types.BuiltinFunctionType</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(<span class="keyword">lambda</span> x: x)==types.LambdaType</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>((x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)))==types.GeneratorType</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用isinstance()</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">对于class的继承关系来说，使用type()就很不方便。我们要判断class的类型，</span></span><br><span class="line"><span class="string">可以使用isinstance()函数。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">isinstance()除了可以判断一个对象是否是该类型本身，或者位于该类型的父</span></span><br><span class="line"><span class="string">继承链上。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span>(<span class="string">&#x27;a&#x27;</span>, <span class="built_in">str</span>)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span>(<span class="number">123</span>, <span class="built_in">int</span>)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span>(<span class="string">b&#x27;a&#x27;</span>, <span class="built_in">bytes</span>)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 还可以判断一个变量是否是某些类型中的一种，比如下面的代码就可以判断</span></span><br><span class="line"><span class="comment"># 是否是list或者tuple。</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], (<span class="built_in">list</span>, <span class="built_in">tuple</span>))</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span>((<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>), (<span class="built_in">list</span>, <span class="built_in">tuple</span>))</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 所以要优先使用isinstance()判断类型，可以将指定类型及其子类&quot;一网打尽&quot;。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用dir()</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果要获得一个对象的所有属性和方法，可以使用dir()函数，它返回一个包含</span></span><br><span class="line"><span class="comment"># 字符串的list，比如，获得一个str对象的所有属性和方法：</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">dir</span>(<span class="string">&#x27;ABC&#x27;</span>)</span><br><span class="line">[<span class="string">&#x27;__add__&#x27;</span>, <span class="string">&#x27;__class__&#x27;</span>, ..., <span class="string">&#x27;__subclasshook__&#x27;</span>, <span class="string">&#x27;capitalize&#x27;</span>, <span class="string">&#x27;casefold&#x27;</span>,..., <span class="string">&#x27;zfill&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">类似 __xxx__ 的属性和方法在Python中都是有特殊用途的，比如__len__方法返</span></span><br><span class="line"><span class="string">回长度。在Python中，如果你调用len()函数试图获取一个对象的长度，实际上，</span></span><br><span class="line"><span class="string">在len()函数内部，它自动去调用该对象的 __len__() 方法，所以，下面的代码</span></span><br><span class="line"><span class="string">是等价的</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">len</span>(<span class="string">&#x27;ABC&#x27;</span>)</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;ABC&#x27;</span>.__len__()</span><br><span class="line"><span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们自己写的类，如果也想用len(myObj)的话，就自己写一个 __len__() 方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyDog</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">100</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dog = MyDog()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">len</span>(dog)</span><br><span class="line"><span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 仅仅把属性和方法列出来是不够的，配合getattr()、setattr()</span></span><br><span class="line"><span class="comment"># 以及hasattr()，我们可以直接操作一个对象的状态：</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyObject</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.x = <span class="number">9</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">power</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.x * self.x</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj = MyObject()</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">hasattr</span>(obj, <span class="string">&#x27;x&#x27;</span>)	<span class="comment"># 有属性&#x27;x&#x27;吗？</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj.x</span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">hasattr</span>(obj, <span class="string">&#x27;y&#x27;</span>)	<span class="comment"># 有属性&#x27;y&#x27;吗？</span></span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">setattr</span>(obj, <span class="string">&#x27;y&#x27;</span>, <span class="number">19</span>)<span class="comment"># 设置一个属性&#x27;y&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">hasattr</span>(obj, <span class="string">&#x27;y&#x27;</span>)	<span class="comment"># 有属性&#x27;y&#x27;吗？</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">getattr</span>(obj, <span class="string">&#x27;y&#x27;</span>)	<span class="comment"># 获取属性&#x27;y&#x27;</span></span><br><span class="line"><span class="number">19</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj.y			   <span class="comment"># 获取属性&#x27;y&#x27;</span></span><br><span class="line"><span class="number">19</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果试图获取不存在的属性，会抛出AttributeError的错误：</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">getattr</span>(obj, <span class="string">&#x27;z&#x27;</span>) <span class="comment"># 获取属性&#x27;z&#x27;</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">AttributeError: <span class="string">&#x27;MyObject&#x27;</span> <span class="built_in">object</span> has no attribute <span class="string">&#x27;z&#x27;</span></span><br><span class="line">    </span><br><span class="line"><span class="comment"># 可以传入一个default参数，如果属性不存在，就返回默认值</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">getattr</span>(obj, <span class="string">&#x27;z&#x27;</span>, <span class="number">404</span>) <span class="comment"># 获取属性&#x27;z&#x27;，如果不存在，返回默认值404</span></span><br><span class="line"><span class="number">404</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 也可以获得对象的方法：</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">hasattr</span>(obj, <span class="string">&#x27;power&#x27;</span>) <span class="comment"># 有属性&#x27;power&#x27;吗？</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">getattr</span>(obj, <span class="string">&#x27;power&#x27;</span>) <span class="comment"># 获取属性&#x27;power&#x27;</span></span><br><span class="line">&lt;bound method MyObject.power of &lt;__main__.MyObject <span class="built_in">object</span> at <span class="number">0x10077a6a0</span>&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fn = <span class="built_in">getattr</span>(obj, <span class="string">&#x27;power&#x27;</span>) <span class="comment"># 获取属性&#x27;power&#x27;并赋值到变量fn</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fn <span class="comment"># fn指向obj.power</span></span><br><span class="line">&lt;bound method MyObject.power of &lt;__main__.MyObject <span class="built_in">object</span> at <span class="number">0x10077a6a0</span>&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fn() <span class="comment"># 调用fn()与调用obj.power()是一样的</span></span><br><span class="line"><span class="number">81</span></span><br></pre></td></tr></table></figure>

<p>小结：通过内置的一系列函数，我们可以对任意一个Python对象进行剖析，拿到其内部的数据。要注意的是，只有在不知道对象信息的时候，我们才会去获取对象信息。</p>
<br/>



<h5 id="【4】实例属性和类属性"><a href="#【4】实例属性和类属性" class="headerlink" title="【4】实例属性和类属性"></a>【4】实例属性和类属性</h5><p>由于Python是动态语言，根据类创建的实例可以任意绑定属性。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 给示例绑定属性的方法是通过实例变量，或者通过self变量</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = Student(<span class="string">&#x27;Bob&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.score = <span class="number">90</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 但是，如果Student类本身需要绑定一个属性呢？可以直接在class中定义属性，</span></span><br><span class="line"><span class="comment"># 这种属性是类属性，归 Student 类所有：</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    name = <span class="string">&#x27;Student&#x27;</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="comment"># 当我们定义一个类属性后，此属性虽然归类所有，但类的所有实例都可以访问到</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = Student() <span class="string">&quot;创建实例s&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(s.name) <span class="string">&quot;打印name属性，因为实例并没有name属性，所以会继续查找class的name属性&quot;</span></span><br><span class="line">Student</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(Student.name) <span class="string">&quot;打印类的name属性&quot;</span></span><br><span class="line">Student</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.name = <span class="string">&#x27;Michael&#x27;</span>  <span class="string">&quot;给实例绑定name属性&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(s.name) <span class="string">&quot;由于实例属性优先级比类属性高，因此，它会屏蔽掉类的name属性&quot;</span></span><br><span class="line">Michael</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(Student.name) <span class="string">&quot;但类属性并未消失，用Student.name仍然可访问&quot;</span></span><br><span class="line">Student</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> s.name  <span class="string">&quot;如果删除实例的name属性&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(s.name) <span class="string">&quot;再次调用s.name，由于实例的name属性没有找到，类的name属性就显示出来了&quot;</span></span><br><span class="line">Student</span><br></pre></td></tr></table></figure>

<p>从上面的例子可以看出，在编写程序的时候，千万不要对实例属性和类属性使用相同的名字，因为相同名称的实例属性将屏蔽掉类属性，但是当你删除实例属性后，再使用相同的名称，访问到的将是类属性。</p>
<p>实例属性属于各个实例所有，互不干扰；</p>
<p>类属性属于类所有，所有实例共享一个属性；</p>
<p>不要对实例属性和类属性使用相同的名字，否则将产生难以发现的错误。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">在 Python 中，如果一个子类继承了父类的类属性，并且在子类中对该属性进行修改，这个操作不会修改父类的类属性。子类和父类的类属性是分开的，它们拥有各自的内存空间，所以对子类中的类属性的修改不会影响父类中的类属性。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">当子类继承了父类的类属性后，如果在子类中对该属性进行修改，实际上是在子类的命名空间中创建了一个新的类属性，覆盖了继承自父类的同名类属性。这样，子类和父类的类属性就成了两个不同的属性，分别存储在各自的命名空间中。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">子类继承父类后，初始状态下，继承了父类的属性, 实际是子类属性对父类属性的引用</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">当在子类中修改继承过来的类属性时，并不会修改父类的同名类属性。以后只要是通过子类访问该属性，访问的都是子类的属性</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span>:</span><br><span class="line">    class_attr = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span>(<span class="title class_ inherited__">Parent</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(Child.class_attr)  <span class="comment"># Output: 10</span></span><br><span class="line">Child.class_attr = <span class="number">20</span></span><br><span class="line"><span class="built_in">print</span>(Child.class_attr)  <span class="comment"># Output: 20</span></span><br><span class="line"><span class="built_in">print</span>(Parent.class_attr) <span class="comment"># Output: 10 (父类的类属性没有被修改)</span></span><br><span class="line"><span class="keyword">del</span> Child.class_attr</span><br><span class="line"><span class="built_in">print</span>(Child.class_attr)  <span class="comment"># Output: 10 (子类的类属性被删除，恢复到继承自父类的值)</span></span><br></pre></td></tr></table></figure>



<br/>



<h2 id="7、面向对象高级编程"><a href="#7、面向对象高级编程" class="headerlink" title="7、面向对象高级编程"></a>7、面向对象高级编程</h2><h5 id="【1】使用-slots"><a href="#【1】使用-slots" class="headerlink" title="【1】使用  __slots__  "></a>【1】使用  <code>__slots__  </code></h5><p>当我们定义了一个class，创建了一个class的实例后，我们可以给该实例绑定任何属性和方法，这就是动态语言的灵活性。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 给实例绑定一个属性</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = Student()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.name = <span class="string">&#x27;Michael&#x27;</span>	<span class="comment"># 动态给实例绑定一个属性</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(s.name)</span><br><span class="line">Michael</span><br><span class="line"></span><br><span class="line"><span class="comment"># 给实例绑定一个方法</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">set_age</span>(<span class="params">self, age</span>): <span class="string">&quot;定义一个函数作为实例方法&quot;</span></span><br><span class="line">    self.age = age</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> types <span class="keyword">import</span> MethodType</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.set_age = MethodType(set_age, s)  <span class="string">&quot;给实例绑定一个方法&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.set_age(<span class="number">25</span>)  <span class="string">&quot;调用实例方法&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.age	<span class="string">&quot;测试结果&quot;</span></span><br><span class="line"><span class="number">25</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 给一个实例绑定的方法，对另一个实例是不起作用的</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s2 = Student()	<span class="comment"># 创建新的实例</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s2.set_age(<span class="number">25</span>)	<span class="comment"># 尝试调用方法</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">AttributeError: <span class="string">&#x27;Student&#x27;</span> <span class="built_in">object</span> has no attribute <span class="string">&#x27;set_age&#x27;</span></span><br><span class="line">    </span><br><span class="line"><span class="comment"># 为了给所有实例都绑定方法，可以给class绑定方法</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">set_score</span>(<span class="params">self, score</span>):</span><br><span class="line">    self.score = score</span><br><span class="line">    </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Student.set_score = set_score</span><br><span class="line"></span><br><span class="line"><span class="comment"># 给class绑定方法后，所有实例均可调用</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.set_score(<span class="number">100</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.score</span><br><span class="line"><span class="number">100</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s2.set_score(<span class="number">99</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s2.score</span><br><span class="line"><span class="number">99</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">通常情况下，上面的set_score方法可以直接定义在class中，但动态绑定允许我们</span></span><br><span class="line"><span class="string">在程序运行的过程中动态给class加上功能，这在静态语言中很难实现。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 __slots__</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 但是，如果我们想要限制实例的属性怎么办？比如只允许添加name和age属性</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">为了达到限制的目的，Python允许在定义class的时候，定义一个特殊的 </span></span><br><span class="line"><span class="string">__slots__变量，来限制该class实例能添加的属性</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    __slots__ = (<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;age&#x27;</span>)  <span class="string">&quot;用tuple定义允许绑定的属性名称&quot;</span></span><br><span class="line">    </span><br><span class="line"><span class="comment"># 然后我们试试</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = Student() <span class="comment"># 创建新的实例</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.name = <span class="string">&#x27;Michael&#x27;</span> <span class="comment"># 绑定属性&#x27;name&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.age = <span class="number">25</span> <span class="comment"># 绑定属性&#x27;age&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.score = <span class="number">99</span> <span class="comment"># 绑定属性&#x27;score&#x27;</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">AttributeError: <span class="string">&#x27;Student&#x27;</span> <span class="built_in">object</span> has no attribute <span class="string">&#x27;score&#x27;</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment"># 由于 score 没有被放到 __slots__ 中，所以不能绑定score属性，试图绑定</span></span><br><span class="line"><span class="comment"># score将得到AttributeError的错误。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 __slots__ 要注意， __slots__ 定义的属性仅仅对当前类实例起作用，</span></span><br><span class="line"><span class="comment"># 对继承的子类是不起作用的。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Gradute</span>(<span class="title class_ inherited__">Student</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g = Gradute()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g.score = <span class="number">999</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">除非在子类中也定义__slots__，这样，子类实例允许定义的属性就是</span></span><br><span class="line"><span class="string">自身的__slots__加上父类的__slots__。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>



<br/>



<h5 id="【2】使用-property"><a href="#【2】使用-property" class="headerlink" title="【2】使用@property"></a>【2】使用@property</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在绑定属性时，如果我们直接把属性暴露出去，这会导致无法检查参数，成绩会被随便修改</span></span><br><span class="line">s = Student()</span><br><span class="line">s.score = <span class="number">9999</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 为了限制score的范围，可以通过一个 set_score() 方法来设置成绩，再通过一个 get_score()</span></span><br><span class="line"><span class="comment"># 来取成绩。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_score</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self._score</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">set_score</span>(<span class="params">self, value</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(value, <span class="built_in">int</span>):</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&#x27;score must be an integer!&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> value &lt; <span class="number">0</span> <span class="keyword">or</span> value &gt; <span class="number">100</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&#x27;score must between 0 ~ 100!&#x27;</span>)</span><br><span class="line">        self._score = value</span><br><span class="line">        </span><br><span class="line"><span class="comment"># 现在，对任意的Student实例进行操作，就不能随心所欲地设置score了</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = Student()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.set_score(<span class="number">60</span>) <span class="comment"># ok!</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.get_score()</span><br><span class="line"><span class="number">60</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.set_score(<span class="number">9999</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  ...</span><br><span class="line">ValueError: score must between <span class="number">0</span> ~ <span class="number">100</span>!</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 有没有既能检查参数，又可以用类似属性这样简单的方式来访问类的变量呢</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">还记得装饰器（decorator）可以给函数动态加上功能吗？对于类的方法，装饰器</span></span><br><span class="line"><span class="string">一样起作用。Python内置的@property装饰器就是负责把一个方法变成属性调用的</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">score</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self._score</span><br><span class="line"></span><br><span class="line"><span class="meta">    @score.setter</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">score</span>(<span class="params">self, value</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(value, <span class="built_in">int</span>):</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&#x27;score must be an integer!&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> value &lt; <span class="number">0</span> <span class="keyword">or</span> value &gt; <span class="number">100</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&#x27;score must between 0 ~ 100!&#x27;</span>)</span><br><span class="line">        self._score = value</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">@property的实现比较复杂，我们先考察如何使用。把一个getter方法变成属性，</span></span><br><span class="line"><span class="string">只需要加上@property就可以了，此时，@property本身又创建了另一个装饰器</span></span><br><span class="line"><span class="string">@score.setter，负责把一个setter方法变成属性赋值，于是，我们就拥有一个可</span></span><br><span class="line"><span class="string">控的属性操作</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = Student()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.score = <span class="number">60</span> <span class="comment"># OK，实际转化为s.set_score(60)</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.score <span class="comment"># OK，实际转化为s.get_score()</span></span><br><span class="line"><span class="number">60</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.score = <span class="number">9999</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  ...</span><br><span class="line">ValueError: score must between <span class="number">0</span> ~ <span class="number">100</span>!</span><br><span class="line">    </span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">注意到这个神奇的@property，我们在对实例属性操作的时候，就知道该属性很可能</span></span><br><span class="line"><span class="string">不是直接暴露的，而是通过getter和setter方法来实现的。</span></span><br><span class="line"><span class="string">还可以定义只读属性，只定义getter方法，不定义setter方法就是一个只读属性</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">上面的birth是可读写属性，而age就是一个只读属性，因为age可以根据birth和当</span></span><br><span class="line"><span class="string">前时间计算出来。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">birth</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self._birth</span><br><span class="line"></span><br><span class="line"><span class="meta">    @birth.setter</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">birth</span>(<span class="params">self, value</span>):</span><br><span class="line">        self._birth = value</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">age</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2015</span> - self._birth</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="comment"># 要特别注意，属性的方法名不要和实例变量重名。例如，以下的代码时错误的。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">这是因为调用s.birth时，首先转换为方法调用，在执行return self.birth时，</span></span><br><span class="line"><span class="string">又视为访问self的属性，于是又转换为方法调用，造成无限递归，最终导致栈溢出</span></span><br><span class="line"><span class="string">报错RecursionError。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 方法名称和实例变量均为birth:</span></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">birth</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.birth</span><br></pre></td></tr></table></figure>



<br/>



<h5 id="【3】多重继承"><a href="#【3】多重继承" class="headerlink" title="【3】多重继承"></a>【3】多重继承</h5><p>继承是面向对象编程的一个重要的方式，因为通过继承，子类就可以扩展父类的功能。但是随着类结构变得逐渐复杂，类的数量会呈现指数增加，很明显这样设计是不行的。正确方法是采用多继承。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 主要的类层次仍按照哺乳类和鸟类设计</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 大类:</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Mammal</span>(<span class="title class_ inherited__">Animal</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bird</span>(<span class="title class_ inherited__">Animal</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 各种动物:</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>(<span class="title class_ inherited__">Mammal</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bat</span>(<span class="title class_ inherited__">Mammal</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Parrot</span>(<span class="title class_ inherited__">Bird</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Ostrich</span>(<span class="title class_ inherited__">Bird</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 现在，我们要给动物再加上Runnable和Flyable的功能，</span></span><br><span class="line"><span class="comment"># 只需要先定义好Runnable和Flyable的类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Runnable</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Running...&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Flyable</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fly</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Flying...&#x27;</span>)</span><br><span class="line">        </span><br><span class="line"><span class="comment"># 对于需要Runnable功能的动物，就多继承一个Runnable</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>(Mammal, Runnable):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对于需要Flyable功能的动物，就多继承一个Flyable</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bat</span>(Mammal, Flyable):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># MixIn</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">在设计类的继承关系时，通常，主线都是单一继承下来的，例如，Ostrich继承自</span></span><br><span class="line"><span class="string">Bird。但是，如果需要“混入”额外的功能，通过多重继承就可以实现，比如，让</span></span><br><span class="line"><span class="string">Ostrich除了继承自Bird外，再同时继承Runnable。这种设计通常称之为MixIn。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">为了更好地看出继承关系，我们把Runnable和Flyable改为RunnableMixIn和</span></span><br><span class="line"><span class="string">FlyableMixIn。类似的，你还可以定义出肉食动物CarnivorousMixIn和植食动物</span></span><br><span class="line"><span class="string">HerbivoresMixIn，让某个动物同时拥有好几个MixIn：</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>(Mammal, RunnableMixIn, CarnivorousMixIn):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">MixIn的目的就是给一个类增加多个功能，这样，在设计类的时候，我们优先考虑</span></span><br><span class="line"><span class="string">通过多重继承来组合多个MixIn的功能，而不是设计多层次的复杂的继承关系。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Python自带的很多库也使用了MixIn。举个例子，Python自带了TCPServer和</span></span><br><span class="line"><span class="string">UDPServer这两类网络服务，而要同时服务多个用户就必须使用多进程或多线程模</span></span><br><span class="line"><span class="string">型，这两种模型由ForkingMixIn和ThreadingMixIn提供。通过组合，我们就可以</span></span><br><span class="line"><span class="string">创造出合适的服务来。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 编写一个多进程模式的TCP服务</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyTCPServer</span>(TCPServer, ForkingMixIn):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 编写一个多线程模式的UDP服务</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyUDPServer</span>(UDPServer, ThreadingMixIn):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 更先进的协程模型，可以编写一个CoroutineMixIn</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyTCPServer</span>(TCPServer, CoroutineMixIn):</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>



<br/>



<h5 id="【4】定制类"><a href="#【4】定制类" class="headerlink" title="【4】定制类"></a>【4】定制类</h5><p>看到类似<code>__slots__</code>这种形如<code>__xxx__</code>的变量或者函数名就要注意，这些在Python中是有特殊用途的。</p>
<p><code>__slots__</code>我们已经知道怎么用了，<code>__len__()</code>方法我们也知道是为了能让class作用于<code>len()</code>函数。</p>
<p>除此之外，Python的class中还有许多这样有特殊用途的函数，可以帮助我们定制类。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># __str__</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(Student(<span class="string">&#x27;Michael&#x27;</span>))</span><br><span class="line">&lt;__main__.Student <span class="built_in">object</span> at <span class="number">0x0000019285C7DD00</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 怎么才能打印得好看呢？只需要定义好__str__()方法，</span></span><br><span class="line"><span class="comment"># 返回一个好看的字符串就可以了</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">		self.name = name</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&#x27;Student object (name: %s)&#x27;</span> % self.name</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(Student(<span class="string">&#x27;Michael&#x27;</span>))</span><br><span class="line">Student <span class="built_in">object</span> (name: Michael)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 细心的朋友会发现直接敲变量不用print，打印出来的实例还是不好看。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">这是因为直接显示变量调用的不是__str__()，而是__repr__()，两者的区别是</span></span><br><span class="line"><span class="string">__str__()返回用户看到的字符串，而__repr__()返回程序开发者看到的字符串，</span></span><br><span class="line"><span class="string">也就是说，__repr__()是为调试服务的。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = Student(<span class="string">&#x27;Michael&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line">&lt;__main__.Student <span class="built_in">object</span> at <span class="number">0x109afb310</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解决办法是再定义一个__repr__()。</span></span><br><span class="line"><span class="comment"># 但是通常__str__()和__repr__()代码都是一样的</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;Student object (name=%s)&#x27;</span> % self.name</span><br><span class="line">    __repr__ = __str__</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># __iter__</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">如果一个类想被用于for ... in循环，类似list或tuple那样，就必须实现一个</span></span><br><span class="line"><span class="string">__iter__()方法，该方法返回一个迭代对象，然后，Python的for循环就会不断调</span></span><br><span class="line"><span class="string">用该迭代对象的__next__()方法拿到循环的下一个值，直到遇到StopIteration错</span></span><br><span class="line"><span class="string">误时退出循环。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Fib</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.a, self.b = <span class="number">0</span>, <span class="number">1</span> <span class="comment"># 初始化两个计数器a，b</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self <span class="comment"># 实例本身就是迭代对象，故返回自己</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__next__</span>(<span class="params">self</span>):</span><br><span class="line">        self.a, self.b = self.b, self.a + self.b <span class="comment"># 计算下一个值</span></span><br><span class="line">        <span class="keyword">if</span> self.a &gt; <span class="number">100000</span>: <span class="comment"># 退出循环的条件</span></span><br><span class="line">            <span class="keyword">raise</span> StopIteration()</span><br><span class="line">        <span class="keyword">return</span> self.a <span class="comment"># 返回下一个值</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> n <span class="keyword">in</span> Fib():</span><br><span class="line">    	<span class="built_in">print</span>(n)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="built_in">list</span>(Fib()))</span><br><span class="line">[<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">13</span>, <span class="number">21</span>, <span class="number">34</span>, <span class="number">55</span>, <span class="number">89</span>, <span class="number">144</span>, <span class="number">233</span>, <span class="number">377</span>, <span class="number">610</span>, <span class="number">987</span>,</span><br><span class="line"> <span class="number">1597</span>, <span class="number">2584</span>, <span class="number">4181</span>, <span class="number">6765</span>, <span class="number">10946</span>, <span class="number">17711</span>, <span class="number">28657</span>, <span class="number">46368</span>, <span class="number">75025</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 既然可以被for循环迭代的都要有__iter__和__next__函数，为什么有些可被for循环迭代的对象只是Iterable类型的而不是Iterator，这是否有矛盾？</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">你提到的确实是一个很重要且常见的问题。在 Python 中，有些对象可以被 for 循环迭代的原因是它们实现了 __iter__() 方法，而不是 __next__() 方法。这种对象被称为可迭代对象（Iterable）。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">可迭代对象只需要提供一个返回迭代器的 __iter__() 方法，该迭代器本身需要实现 __next__() 方法。所以，可迭代对象和迭代器是两个不同的概念。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">为什么会有这样的设计呢？这是由于 Python 中的可迭代对象和迭代器的责任分工。可迭代对象负责返回一个新的迭代器对象，而迭代器则负责提供实际的迭代过程。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">这种分工的好处在于：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    1、可迭代对象可以被多次迭代。每次迭代都会返回一个新的迭代器对象，这样可以实现对同一数据集的多次独立迭代，而不会相互干扰。</span></span><br><span class="line"><span class="string">    2、迭代器只需关注一个状态和一种行为：通过 __next__() 方法返回下一个值。这种简化的设计更加高效和灵活。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">因此，Python 设计中将可迭代对象和迭代器分开，以便提供更好的灵活性和性能。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">以下是一个示例来说明这种区别：</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># 可迭代对象</span></span><br><span class="line">my_list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> my_list:</span><br><span class="line">    <span class="built_in">print</span>(item)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 迭代器</span></span><br><span class="line">my_iterator = <span class="built_in">iter</span>(my_list)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(my_iterator))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(my_iterator))</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">在上述示例中，my_list 是一个可迭代对象，它通过实现 __iter__() 方法来支持迭代。我们可以直接使用 for 循环来遍历它。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">而通过调用 iter(my_list) 我们获得了一个迭代器对象 my_iterator，它负责实际的迭代过程。我们可以使用 next() 函数来逐个获取迭代器中的元素。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">所以，并不是所有可以被 for 循环迭代的对象都必须同时是迭代器，而是要实现 __iter__() 方法以返回一个迭代器对象即可。这样的设计使得 Python 中的迭代更加灵活和高效。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># __getitem__</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Fib实例虽然能作用于for循环，看起来和list有点像，但是，把它当成list来使用还是不行，比如，取第5个元素：</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Fib()[<span class="number">5</span>]</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: <span class="string">&#x27;Fib&#x27;</span> <span class="built_in">object</span> does <span class="keyword">not</span> support indexing</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 要表现的像list那样按下标取出元素，需要实现__getitem__()方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Fib</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, n</span>):</span><br><span class="line">        a, b = <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            a, b = b, a + b</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f[<span class="number">10</span>]</span><br><span class="line"><span class="number">89</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># list有个神奇的切片方法，对于Fib却报错。原因是__getitem__()传入的参数可</span></span><br><span class="line"><span class="comment"># 能是一个int，也可能是一个切片对象slice</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Fib</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, n</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(n, <span class="built_in">int</span>): <span class="comment"># n是索引</span></span><br><span class="line">            a, b = <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                a, b = b, a + b</span><br><span class="line">            <span class="keyword">return</span> a</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(n, <span class="built_in">slice</span>): <span class="comment"># n是切片</span></span><br><span class="line">            start = n.start</span><br><span class="line">            stop = n.stop</span><br><span class="line">            <span class="keyword">if</span> start <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                start = <span class="number">0</span></span><br><span class="line">            a, b = <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">            L = []</span><br><span class="line">            <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(stop):</span><br><span class="line">                <span class="keyword">if</span> x &gt;= start:</span><br><span class="line">                    L.append(a)</span><br><span class="line">                a, b = b, a + b</span><br><span class="line">            <span class="keyword">return</span> L</span><br><span class="line"></span><br><span class="line"><span class="comment"># 现在试试Fib的切片</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = Fib()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f[<span class="number">0</span>:<span class="number">5</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f[:<span class="number">10</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">13</span>, <span class="number">21</span>, <span class="number">34</span>, <span class="number">55</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 但是没对step参数处理，也没有对负数作处理，</span></span><br><span class="line"><span class="comment"># 所以，要正确实现一个__getitem__()还是有很多工作要做的。</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f[:<span class="number">10</span>:<span class="number">2</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">13</span>, <span class="number">21</span>, <span class="number">34</span>, <span class="number">55</span>, <span class="number">89</span>]</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">此外，如果把对象看成dict，__getitem__()的参数也可能是一个可以作key的</span></span><br><span class="line"><span class="string">object，例如str。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">与之对应的是__setitem__()方法，把对象视作list或dict来对集合赋值。最后，</span></span><br><span class="line"><span class="string">还有一个__delitem__()方法，用于删除某个元素。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">总之，通过上面的方法，我们自己定义的类表现得和Python自带的list、tuple、</span></span><br><span class="line"><span class="string">dict没什么区别，这完全归功于动态语言的“鸭子类型”，不需要强制继承某个接</span></span><br><span class="line"><span class="string">口。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># __getattr__</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">正常情况下，当我们调用类的方法或属性时，如果不存在，就会报错。</span></span><br><span class="line"><span class="string">比如定义Student类：</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.name = <span class="string">&#x27;Michael&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = Student()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(s.name)</span><br><span class="line">Michael</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(s.score)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  ...</span><br><span class="line">AttributeError: <span class="string">&#x27;Student&#x27;</span> <span class="built_in">object</span> has no attribute <span class="string">&#x27;score&#x27;</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment"># 要避免这个错误，除了可以加上一个score属性外，Python还有另一个机制，</span></span><br><span class="line"><span class="comment"># 那就是写一个__getattr__()方法，动态返回一个属性。修改如下： </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.name = <span class="string">&#x27;Michael&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getattr__</span>(<span class="params">self, attr</span>):</span><br><span class="line">        <span class="keyword">if</span> attr==<span class="string">&#x27;score&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">99</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 当调用不存在的属性时，比如score，Python解释器会试图调用__getattr__</span></span><br><span class="line"><span class="comment"># (self, &#x27;score&#x27;)来尝试获得属性，这样，我们就有机会返回score的值：</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = Student()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.name</span><br><span class="line"><span class="string">&#x27;Michael&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.score</span><br><span class="line"><span class="number">99</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回函数也是完全可以的</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getattr__</span>(<span class="params">self, attr</span>):</span><br><span class="line">        <span class="keyword">if</span> attr==<span class="string">&#x27;age&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">lambda</span>: <span class="number">25</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用方式要变为</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.age()</span><br><span class="line"><span class="number">25</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">注意，只有在没有找到属性的情况下，才调用 __getattr__ ，已有的属性，比如</span></span><br><span class="line"><span class="string">name，不会在 __getattr__ 中查找。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">此外，注意到任意调用如s.abc都会返回None，这是因为我们定义的 __getattr__</span></span><br><span class="line"><span class="string">默认返回就是None。要让class只响应特定的几个属性，我们就要按照约定，抛出</span></span><br><span class="line"><span class="string">AttributeError的错误。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getattr__</span>(<span class="params">self, attr</span>):</span><br><span class="line">        <span class="keyword">if</span> attr == <span class="string">&#x27;age&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">lambda</span>: <span class="number">25</span></span><br><span class="line">        <span class="keyword">raise</span> AttributeError(<span class="string">&quot;\&#x27;Student\&#x27; object has no attribute\</span></span><br><span class="line"><span class="string">                             \&#x27;%s\&#x27;&quot;</span> % attr)</span><br><span class="line"><span class="comment"># 这实际上可以把一个类的所有属性和方法调用全部动态化处理了，不需要任何特殊手段</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 举个例子，很多网站都搞REST API，比如新浪微博、豆瓣啥的。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">http://api.server/user/friends</span></span><br><span class="line"><span class="string">http://api.server/user/timeline/list</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">如果要写SDK，给每个URL对应的API都写一个方法，那得累死，而且，API一旦改动</span></span><br><span class="line"><span class="string">SDK也要改。利用完全动态的 __getattr__，我们可以写出一个链式调用。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Chain</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, path = <span class="string">&#x27;&#x27;</span></span>):</span><br><span class="line">        self._path = path</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getattr__</span>(<span class="params">self, path</span>):</span><br><span class="line">        <span class="keyword">return</span> Chain(<span class="string">&quot;%s/%s&quot;</span> % (self._path, path))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self._path</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, path</span>):</span><br><span class="line">        <span class="keyword">return</span> Chain(<span class="string">&quot;%s/%s&quot;</span> % (self._path, path))</span><br><span class="line">    </span><br><span class="line">    __repr__ = __str__</span><br><span class="line">    </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Chain().status.user.timeline.<span class="built_in">list</span></span><br><span class="line"><span class="string">&#x27;/status/user/timeline/list&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 还有些REST API会把参数放到URL中，比如GItHub的API</span></span><br><span class="line"><span class="string">&quot;GET /user/:user/repos&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用时，需要把 :user 替换为实际用户名。如果我们能写出这样的链式调用</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">添加了一个新的 __call__() 方法。这个方法允许对象像函数一样被调用，所以我们可以像函数调用一样使用 chain.users(&#x27;michael&#x27;)</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Chain().users(<span class="string">&#x27;michael&#x27;</span>).repos</span><br><span class="line"><span class="comment"># 就可以非常方便地调用API了</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># __call__</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">一个对象实例可以有自己的属性和方法，当我们调用实例方法时，我们用 </span></span><br><span class="line"><span class="string">instance.method()来调用。能否直接在实例本身上调用呢？在Python中是肯定的</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">任何类，只需要定义一个 __call__() 方法，就可以直接对实例进行调用。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;My name is %s.&quot;</span> % self.name)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用方式如下</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = Student(<span class="string">&quot;Michael&quot;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s()	<span class="comment">#self参数不要传入</span></span><br><span class="line">My name <span class="keyword">is</span> Michael.</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">__call__()还可以定义参数。对实例进行直接调用就好比对一个函数进行调用一样</span></span><br><span class="line"><span class="string">所以你完全可以把对象看出函数，把函数看成对象，因为这两者之间本来就没啥根本</span></span><br><span class="line"><span class="string">区别。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">如果你把对象看成函数，那么函数本身其实也可以在运行期动态创建出来，因为类的</span></span><br><span class="line"><span class="string">实例都是运行期创建出来的，这么一来，我们就模糊了对象和函数的界限。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">那么，怎么判断一个变量是对象还是函数呢？其实，更多的时候，我们需要判断一个</span></span><br><span class="line"><span class="string">对象是否能被调用，能被调用的对象就是一个Callable对象，比如函数和我们上面</span></span><br><span class="line"><span class="string">定义的带有 __call__()的类实例。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">callable</span>(Student())</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">callable</span>(<span class="built_in">max</span>)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">callable</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">callable</span>(<span class="literal">None</span>)</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">callable</span>(<span class="string">&#x27;str&#x27;</span>)</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 作业</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Chain</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, path = <span class="string">&#x27;&#x27;</span></span>):</span><br><span class="line">        self._path = path</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getattr__</span>(<span class="params">self, path</span>):</span><br><span class="line">        <span class="keyword">return</span> Chain(<span class="string">&#x27;%s/%s&#x27;</span> % (self._path, path))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, *args, **kwargs</span>):</span><br><span class="line">        <span class="keyword">for</span> v <span class="keyword">in</span> args:</span><br><span class="line">            self._path = self._path+<span class="string">&quot;/&quot;</span>+v</span><br><span class="line">        <span class="keyword">return</span> Chain(self._path)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self._path</span><br><span class="line"></span><br><span class="line">    __repr__ = __str__</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(Chain().users(<span class="string">&quot;mimi&quot;</span>, <span class="string">&quot;jiji&quot;</span>).repos)</span><br></pre></td></tr></table></figure>



<br/>



<h5 id="【5】使用枚举类"><a href="#【5】使用枚举类" class="headerlink" title="【5】使用枚举类"></a>【5】使用枚举类</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 我们需要定义常量时，一个办法是用大写变量通过整数来定义，例如月份</span></span><br><span class="line">JAN = <span class="number">1</span></span><br><span class="line">FEB = <span class="number">2</span></span><br><span class="line">MAR = <span class="number">3</span></span><br><span class="line">...</span><br><span class="line">NOV = <span class="number">11</span></span><br><span class="line">DEC = <span class="number">12</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 好处是简单，缺点是类型是int，并且仍然是变量</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">更好的方法是为这样的枚举类型定义一个class类型，然后，每个常量都是class的一个唯一实例。</span></span><br><span class="line"><span class="string">Python提供了Enum类来实现这个功能。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">from</span> enum <span class="keyword">import</span> Enum</span><br><span class="line"></span><br><span class="line">Month = Enum(<span class="string">&#x27;Month&#x27;</span>, (<span class="string">&#x27;Jan&#x27;</span>, <span class="string">&#x27;Feb&#x27;</span>, <span class="string">&#x27;Mar&#x27;</span>, <span class="string">&#x27;Apr&#x27;</span>, <span class="string">&#x27;May&#x27;</span>, <span class="string">&#x27;Jun&#x27;</span>, <span class="string">&#x27;Jul&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这样我们就获得了Month类型的枚举类，可以直接使用Month.Jan来引用一个常量，或者枚举它的</span></span><br><span class="line"><span class="comment"># 所有成员。</span></span><br><span class="line"><span class="keyword">for</span> name, member <span class="keyword">in</span> Month.__members__.items():</span><br><span class="line">    <span class="built_in">print</span>(name, <span class="string">&#x27;=&gt;&#x27;</span>, member, <span class="string">&#x27;,&#x27;</span>, member.value)</span><br><span class="line"></span><br><span class="line"><span class="comment"># value属性则是自动赋给成员的int常量，默认从1开始计数。</span></span><br><span class="line"><span class="comment"># 如果需要更精确地控制枚举类型，可以从Enum派生出自定义类。</span></span><br><span class="line"><span class="keyword">from</span> enum <span class="keyword">import</span> Enum, unique</span><br><span class="line"></span><br><span class="line"><span class="meta">@unique</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Weekday</span>(<span class="title class_ inherited__">Enum</span>):</span><br><span class="line">    Sun = <span class="number">0</span> <span class="comment"># Sun的value被设定为0</span></span><br><span class="line">    Mon = <span class="number">1</span></span><br><span class="line">    Tue = <span class="number">2</span></span><br><span class="line">    Wed = <span class="number">3</span></span><br><span class="line">    Thu = <span class="number">4</span></span><br><span class="line">    Fri = <span class="number">5</span></span><br><span class="line">    Sat = <span class="number">6</span></span><br><span class="line">    </span><br><span class="line"><span class="comment"># @unique装饰器可以帮助我们检查保证没有重复值。</span></span><br><span class="line"><span class="comment"># 访问这些枚举类型可以有若干种方法</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>day1 = Weekday.Mon</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(day1)</span><br><span class="line">Weekday.Mon</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(Weekday.Tue)</span><br><span class="line">Weekday.Tue</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(Weekday[<span class="string">&#x27;Tue&#x27;</span>])</span><br><span class="line">Weekday.Tue</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(Weekday.Tue.value)</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(day1 == Weekday.Mon)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(day1 == Weekday.Tue)</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(Weekday(<span class="number">1</span>))</span><br><span class="line">Weekday.Mon</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(day1 == Weekday(<span class="number">1</span>))</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Weekday(<span class="number">7</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  ...</span><br><span class="line">ValueError: <span class="number">7</span> <span class="keyword">is</span> <span class="keyword">not</span> a valid Weekday</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> name, member <span class="keyword">in</span> Weekday.__members__.items():</span><br><span class="line"><span class="meta">... </span>   	<span class="built_in">print</span>(name, <span class="string">&#x27;=&gt;&#x27;</span>, member)</span><br><span class="line">Sun =&gt; Weekday.Sun</span><br><span class="line">Mon =&gt; Weekday.Mon</span><br><span class="line">Tue =&gt; Weekday.Tue</span><br><span class="line">Wed =&gt; Weekday.Wed</span><br><span class="line">Thu =&gt; Weekday.Thu</span><br><span class="line">Fri =&gt; Weekday.Fri</span><br><span class="line">Sat =&gt; Weekday.Sat</span><br></pre></td></tr></table></figure>



<br/>



<h5 id="【6】使用元类"><a href="#【6】使用元类" class="headerlink" title="【6】使用元类"></a>【6】使用元类</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># type()</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">动态语言和静态语言最大的不同，就是函数和类的定义，不是编译时定义的，而是运行时动态创建的。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Hello</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hello</span>(<span class="params">self, name = <span class="string">&#x27;world&#x27;</span></span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Hello, %s&#x27;</span> % name)</span><br><span class="line">        </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>h = Hello()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>h.hello()</span><br><span class="line">Hello, world.</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="built_in">type</span>(Hello))</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;type&#x27;</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="built_in">type</span>(h))</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;hello.Hello&#x27;</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># type()函数可以查看一个类型或变量的类型，Hello是一个class，它的类型就是type，而h是一个</span></span><br><span class="line"><span class="comment"># 实例，它的类型就是class Hello。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">我们说class的定义是运行时动态创建的，而创建class的方法就是使用type()函数。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">type()函数既可以返回一个对象的类型，又可以创建出新的类型，比如，我们可以通过type()函数创建</span></span><br><span class="line"><span class="string">出Hello类，而无需通过class Hello(object)...的定义：</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fn</span>(<span class="params">self, name = <span class="string">&quot;world&quot;</span></span>):	<span class="comment"># 先定义函数</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello, %s&quot;</span> % name)</span><br><span class="line"></span><br><span class="line">Hello = <span class="built_in">type</span>(<span class="string">&quot;Hello&quot;</span>, (<span class="built_in">object</span>,), <span class="built_in">dict</span>(hello = fn))	<span class="comment"># 创建Hello class</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>h = Hello()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>h.hello()</span><br><span class="line">Hello, world.</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="built_in">type</span>(Hello))</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;type&#x27;</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="built_in">type</span>(h))</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;__main__.Hello&#x27;</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 要创建一个class对象，type()函数依次传入3个参数</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">1. class的名称</span></span><br><span class="line"><span class="string">2. 继承的父类集合，注意Python支持多重继承，如果只有一个父类，别忘了tuple的单元素写法。</span></span><br><span class="line"><span class="string">3. class的方法名称与函数绑定，这里我们把函数fn绑定到方法名hello上。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">通过type()函数创建的类和直接写class是完全一样的，因为Python解释器遇到class定义时，仅仅</span></span><br><span class="line"><span class="string">是扫描一下class定义的语法，然后调用type()函数创建出class。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">正常情况下，我们都用 class XXX 来定义类，但是，type()函数也允许我们动态创建出来，也就是</span></span><br><span class="line"><span class="string">说，动态语言本身支持运行期动态创建类，这和静态语言有非常大的不同，要在静态语言运行期创建类，</span></span><br><span class="line"><span class="string">必须构造源代码字符串再调用编译器，或者借助一些工具生成字节码实现，本质上都是动态编译，会非常</span></span><br><span class="line"><span class="string">复杂。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># metaclass</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">除了使用type()动态创建类以外，要控制类的创建行为，还可以使用metaclass。</span></span><br><span class="line"><span class="string">metaclass，直译为元类，简单的解释就是：</span></span><br><span class="line"><span class="string">当我们定义了类以后，就可以根据这个类创建出实例，所以，先定义类，然后创建实例。</span></span><br><span class="line"><span class="string">但如果我们想创建出类呢？那就必须根据metaclass创建出类，所以先定义metaclass，然后创建类。</span></span><br><span class="line"><span class="string">连起来就是：先定义metaclass，就可以创建类，最后创建实例。</span></span><br><span class="line"><span class="string">所以，metaclass允许你创建类或者修改类。换句话说，你可以把类看成是metaclass创建出来的实例</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 简单例子，这个metaclass可以给我们自定义的MyList增加一个 add 方法。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">定义 ListMetaclass，按照默认习惯，metaclass的类名总是以Metaclass结尾，以便清楚地表示</span></span><br><span class="line"><span class="string">这是一个metaclass</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># metaclass是类的模版，所以必须从 type 类型派生。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ListMetaclass</span>(<span class="title class_ inherited__">type</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">cls, name, bases, attrs</span>):</span><br><span class="line">        attrs[<span class="string">&#x27;add&#x27;</span>] = <span class="keyword">lambda</span> self, value: self.append(value)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">type</span>.__new__(cls, name, bases, attrs)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 有了ListMetaclass，我们在定义类的时候还要指示使用ListMetaclass来定制类，传入关键字参</span></span><br><span class="line"><span class="comment"># 数metaclass：</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyList</span>(<span class="built_in">list</span>, metaclass = ListMetaclass):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">当我们传入关键字参数metaclass时，魔术就生效了，它指示Python解释器在创建MyList时，要通过</span></span><br><span class="line"><span class="string">ListMetaclass.__new__()来创建，在此，我们可以修改类的定义，比如加上新的方法，</span></span><br><span class="line"><span class="string">然后，返回修改后的定义。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># __new__()方法接收到的参数依次是：</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">1、当前准备创建的类的对象。</span></span><br><span class="line"><span class="string">2、类的名字。</span></span><br><span class="line"><span class="string">3、类继承的父类集合。</span></span><br><span class="line"><span class="string">4、类的方法集合。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>L = MyList()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>L.add(<span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>L</span><br><span class="line">[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 而普通的list没有add()方法</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>L2 = <span class="built_in">list</span>()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>L2.add(<span class="number">1</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">AttributeError: <span class="string">&#x27;list&#x27;</span> <span class="built_in">object</span> has no attribute <span class="string">&#x27;add&#x27;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 正常情况下，直接在类中编写代码更简单，但总会遇到需要通过metaclass修改类定义的，</span></span><br><span class="line"><span class="comment"># ORM是一个典型的使用metaclass的例子。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">ORM全称 &quot;Object Relational Mapping&quot;, 即对象-关系映射，就是把关系数据库的一行映射为一个</span></span><br><span class="line"><span class="string">对象，也就是一个类对应一个表，这样，写代码更简单，不用直接操作SQL语句。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">要编写一个ORM框架，所有的类都只能动态定义，因为只有使用者才能根据表的结构定义出对应的类来。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 编写底层模块的第一步，就是先把调用接口写出来。比如，使用者如果使用这个ORM框架，想定义一个</span></span><br><span class="line"><span class="comment"># User类来操作对应的数据库表User，我们期待写出这样的代码。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>(<span class="title class_ inherited__">Model</span>):</span><br><span class="line">    <span class="comment"># 定义类的属性到列的映射</span></span><br><span class="line">    <span class="built_in">id</span> = IntegerField(<span class="string">&#x27;id&#x27;</span>)</span><br><span class="line">    name = StringField(<span class="string">&#x27;username&#x27;</span>)</span><br><span class="line">    email = StringField(<span class="string">&#x27;email&#x27;</span>)</span><br><span class="line">    password = StringField(<span class="string">&#x27;password&#x27;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 创建一个实例</span></span><br><span class="line">u = User(<span class="built_in">id</span> = <span class="number">12345</span>, name = <span class="string">&#x27;Michael&#x27;</span>, email = <span class="string">&#x27;test@orm.org&#x27;</span>, </span><br><span class="line">         password = <span class="string">&#x27;my-pwd&#x27;</span>)</span><br><span class="line"><span class="comment"># 保存到数据库</span></span><br><span class="line">u.save()</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">其中，父类Model和属性类型StringField、IntegerField是由ORM框架提供的，剩下的魔术方法比</span></span><br><span class="line"><span class="string">如save()全部由父类Model自动完成。</span></span><br><span class="line"><span class="string">虽然metaclass的编写比较复杂，但ORM的使用者用起来很简单。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 首先定义Field类，它负责保存数据库表的字段名和字段类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Field</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, column_type</span>):</span><br><span class="line">    	self.name = name</span><br><span class="line">    	self.column_type = column_type</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&lt;%s:%s&gt;&#x27;</span> % (self.__class__.__name__, self.name)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 在Field的基础上，进一步定义各种类型的Field，比如StringField，IntegerField等等</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StringField</span>(<span class="title class_ inherited__">Field</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        <span class="built_in">super</span>(StringField, self).__init__(name, <span class="string">&#x27;varchar(100)&#x27;</span>)</span><br><span class="line">        </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IntegerField</span>(<span class="title class_ inherited__">Field</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        <span class="built_in">super</span>(IntegerField, self).__init__(name, <span class="string">&#x27;bigint&#x27;</span>)</span><br><span class="line">        </span><br><span class="line"><span class="comment"># 下一步，就是编写最复杂的ModelMetaclass了</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ModelMetaclass</span>(<span class="title class_ inherited__">type</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">cls, name, bases, attrs</span>):</span><br><span class="line">        <span class="keyword">if</span> name == <span class="string">&#x27;Model&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">type</span>.__new__(cls, name, bases, attrs)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Found model: %s&#x27;</span> % name)</span><br><span class="line">        mappings = <span class="built_in">dict</span>()</span><br><span class="line">        <span class="keyword">for</span> k, v <span class="keyword">in</span> attrs.items():</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">isinstance</span>(v, Field):</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;Found mapping: %s ==&gt; %s&#x27;</span> % (k, v))</span><br><span class="line">                mappings[k] = v</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> mappings.keys():</span><br><span class="line">        	attrs.pop(k)</span><br><span class="line">            </span><br><span class="line">        attrs[<span class="string">&#x27;__mappings__&#x27;</span>] = mappings <span class="comment">#保存属性和列的映射关系</span></span><br><span class="line">        attrs[<span class="string">&#x27;__table__&#x27;</span>] = name <span class="comment"># 假设表名和类名一致</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">type</span>.__new__(cls, name, bases, attrs)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以及基类Model</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Model</span>(<span class="built_in">dict</span>, metaclass = ModelMetaclass):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, **kw</span>):</span><br><span class="line">        <span class="built_in">super</span>(Model, self).__init__(**kw)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getattr__</span>(<span class="params">self, key</span>):</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">return</span> self[key]</span><br><span class="line">        <span class="keyword">except</span> KeyError:</span><br><span class="line">            <span class="keyword">raise</span> AttributeError(<span class="string">r&quot;&#x27;Model&#x27; object has no attribute &#x27;%s&#x27;&quot;</span> % key)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__setattr__</span>(<span class="params">self, key, value</span>):</span><br><span class="line">        self[key] = value</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">save</span>(<span class="params">self</span>):</span><br><span class="line">        fields = []</span><br><span class="line">        params = []</span><br><span class="line">        args = []</span><br><span class="line">        <span class="keyword">for</span> k, v <span class="keyword">in</span> self.__mappings__.items():</span><br><span class="line">            fields.append(v.name)</span><br><span class="line">            params.append(<span class="string">&#x27;?&#x27;</span>)</span><br><span class="line">            args.append(<span class="built_in">getattr</span>(self, k, <span class="literal">None</span>))</span><br><span class="line">        sql = <span class="string">&#x27;insert into %s (%s) values (%s)&#x27;</span> % (self.__table__, <span class="string">&#x27;,&#x27;</span>.join(fields), <span class="string">&#x27;,&#x27;</span>.join(params))</span><br><span class="line">    	<span class="built_in">print</span>(<span class="string">&#x27;SQL: %s&#x27;</span> % sql)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;ARGS: %s&#x27;</span> % <span class="built_in">str</span>(args))</span><br><span class="line">        </span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">当用户定义一个class User(Model)时，Python解释器首先在当前类User的定义中查找</span></span><br><span class="line"><span class="string">metaclass，如果没找到，就继续在父类Model中查找metaclass，找到了，就使用Model中定义的</span></span><br><span class="line"><span class="string">metaclass的ModelMetaclass来创建User类，也就是说，metaclass可以隐式地继承到子类，</span></span><br><span class="line"><span class="string">但子类自己却感觉不到。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">在ModelMetaclass中，一共做了几件事情</span></span><br><span class="line"><span class="string">1、排除掉对Model类的修改</span></span><br><span class="line"><span class="string">2、在当前类（比如User）中查找定义的类的所有属性，如果找到一个Field属性，就把它保存到一个</span></span><br><span class="line"><span class="string">__mappings__的dict中，同时从类属性中删除该Field属性，否则，容易造成运行时错误</span></span><br><span class="line"><span class="string">（实例的属性会遮盖类的同名属性）</span></span><br><span class="line"><span class="string">3、把表名保存到__table__中，这里简化为表名默认为类名。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span> </span><br><span class="line"></span><br><span class="line"><span class="comment"># 在Model类中就可以定义各种操作数据库的方法，比如save()，delete()，find()，update等。</span></span><br><span class="line"><span class="comment"># 我们实现了save()方法，把一个实例保存到数据库中。因为有表名，属性到字段的映射和属性值的集合，就可以构造出INSERT语句。</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>u = User(<span class="built_in">id</span> = <span class="number">12345</span>, name = <span class="string">&#x27;Michael&#x27;</span>, email = <span class="string">&#x27;test@orm.org&#x27;</span>, password = <span class="string">&#x27;my-pwd&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>u.save()</span><br><span class="line">Found model: User</span><br><span class="line">Found mapping: email ==&gt; &lt;StringField:email&gt;</span><br><span class="line">Found mapping: password ==&gt; &lt;StringField:password&gt;</span><br><span class="line">Found mapping: <span class="built_in">id</span> ==&gt; &lt;IntegerField:uid&gt;</span><br><span class="line">Found mapping: name ==&gt; &lt;StringField:username&gt;</span><br><span class="line">SQL: insert into User (password,email,username,<span class="built_in">id</span>) values (?,?,?,?)</span><br><span class="line">ARGS: [<span class="string">&#x27;my-pwd&#x27;</span>, <span class="string">&#x27;test@orm.org&#x27;</span>, <span class="string">&#x27;Michael&#x27;</span>, <span class="number">12345</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 上述User中创建的属性是类级别的，为什么？</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">这种方式创建的属性确实属于类级别的属性。在ORM框架中，通常会将类的属性到列的映射定义为类级别的属性。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">这样定义的原因是为了将数据库表的结构与Python类进行关联。通过在类级别定义属性与列的映射关系，可以使得操作数据库表和操作Python类对象更加方便和一致。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">当使用User类进行数据库操作时，比如查询、插入、更新等操作，这些类级别的属性就起到了关键的作用。通过这些属性，ORM框架可以根据类级别的定义来生成合适的SQL语句，并将查询结果映射到类的对象中。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">同时，将属性定义为类级别的属性还可以节省内存空间。如果将属性定义为对象级别的属性，每个对象都会拥有一份属性的副本，而对于大量的对象和复杂的数据模型，这可能会导致内存浪费。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">因此，通过在类级别定义属性与列的映射关系，可以实现更高效、便捷的数据库操作，并节省内存空间。当然，在一些特定的情况下，也可以使用对象级别的属性，这完全取决于具体的需求和设计。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>



<br/>



<h2 id="8、错误、调试和测试"><a href="#8、错误、调试和测试" class="headerlink" title="8、错误、调试和测试"></a>8、错误、调试和测试</h2><h5 id="【1】错误处理"><a href="#【1】错误处理" class="headerlink" title="【1】错误处理"></a>【1】错误处理</h5><p>高级语言都内置了一套<code>try...except...finally...</code>的错误机制，Python也不例外。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 当我们认为某些代码可能会出错，就可以用try来运行这段代码，如果执行出错则后续代码不会继续执</span></span><br><span class="line"><span class="comment"># 行，而是直接跳转至错误处理代码，即except语句块，执行完except后，如果有finally语句块，</span></span><br><span class="line"><span class="comment"># 则执行finally语句块，至此，执行完毕。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果try中没有错误发生，则except语句块不会被执行，但是finally如果有，则一定会被执行。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以有多个except来捕获不同类型的错误</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;try...&#x27;</span>)</span><br><span class="line">    r = <span class="number">10</span> / <span class="built_in">int</span>(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;result:&#x27;</span>, r)</span><br><span class="line"><span class="keyword">except</span> ValueError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;ValueError:&#x27;</span>, e)</span><br><span class="line"><span class="keyword">except</span> ZeroDivisionError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;ZeroDivisionError:&#x27;</span>, e)</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;finally...&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;END&#x27;</span>)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="keyword">try</span>...</span><br><span class="line">ValueError: invalid literal <span class="keyword">for</span> <span class="built_in">int</span>() <span class="keyword">with</span> base <span class="number">10</span>: <span class="string">&#x27;a&#x27;</span></span><br><span class="line"><span class="keyword">finally</span>...</span><br><span class="line">END</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果没有错误发生，可以在except语句块后面加一个else，当没有错误发生时，会自动执行else</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;try...&#x27;</span>)</span><br><span class="line">    r = <span class="number">10</span> / <span class="built_in">int</span>(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;result:&#x27;</span>, r)</span><br><span class="line"><span class="keyword">except</span> ValueError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;ValueError:&#x27;</span>, e)</span><br><span class="line"><span class="keyword">except</span> ZeroDivisionError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;ZeroDivisionError:&#x27;</span>, e)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;no error!&#x27;</span>)</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;finally...&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;END&#x27;</span>)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="keyword">try</span>...</span><br><span class="line">result: <span class="number">5.0</span></span><br><span class="line">no error!</span><br><span class="line"><span class="keyword">finally</span>...</span><br><span class="line">END</span><br><span class="line"></span><br><span class="line"><span class="comment"># Python的错误其实也是class，所有的错误类型都继承自BaseException，所以在使用except时需</span></span><br><span class="line"><span class="comment"># 要注意的是，它不但捕获该类型的错误，还把其子类也 &quot;一网打尽&quot;。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">第二个except永远也捕获不到UnicodeError，因为UnicodeError是ValueError的子类，如果有，</span></span><br><span class="line"><span class="string">也被第一个except给捕获了。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    foo()</span><br><span class="line"><span class="keyword">except</span> ValueError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;ValueError&#x27;</span>)</span><br><span class="line"><span class="keyword">except</span> UnicodeError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;UnicodeError&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Python所有的错误都是从BaseException类派生的，常见的错误类型和继承关系看这里：</span></span><br><span class="line">https://docs.python.org/<span class="number">3</span>/library/exceptions.html<span class="comment">#exception-hierarchy</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用try...except捕获还有一个巨大的好处，就是可以跨越多层调用，比如函数main()调用bar()</span></span><br><span class="line"><span class="comment"># bar()调用foo()，结果foo()出错了，这时，只要main()捕获到了，就可以处理。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">不需要在每个可能出错的地方去捕获错误，只要在合适的层次去捕获错误就可以了。这样一来，就大大</span></span><br><span class="line"><span class="string">减少了写 try...except...finally的麻烦。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">s</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span> / <span class="built_in">int</span>(s)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bar</span>(<span class="params">s</span>):</span><br><span class="line">    <span class="keyword">return</span> foo(s) * <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        bar(<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Error:&#x27;</span>, e)</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;finally...&#x27;</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 记录错误</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">如果不捕获错误，自然可以让Python解释器来打印出错误堆栈，但程序也被结束了。既然我们能捕获错</span></span><br><span class="line"><span class="string">误，就可以把错误堆栈打印出来，然后分析错误原因，同时，让程序继续执行下去。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Python内置的logging模块可以非常容易地记录错误信息</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">s</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span> / <span class="built_in">int</span>(s)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bar</span>(<span class="params">s</span>):</span><br><span class="line">    <span class="keyword">return</span> foo(s) * <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        bar(<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        logging.exception(e)</span><br><span class="line">        </span><br><span class="line">main()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;END&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 同样出错，但程序打印完错误信息后会继续执行，并正常退出。</span></span><br><span class="line">ERROR:root:division by zero</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;/Users/kazama/Documents/VSProject/qemu/Test.py&quot;</span>, line <span class="number">10</span>, <span class="keyword">in</span> main</span><br><span class="line">    bar(<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">  File <span class="string">&quot;/Users/kazama/Documents/VSProject/qemu/Test.py&quot;</span>, line <span class="number">6</span>, <span class="keyword">in</span> bar</span><br><span class="line">    <span class="keyword">return</span> foo(s) * <span class="number">2</span></span><br><span class="line">  File <span class="string">&quot;/Users/kazama/Documents/VSProject/qemu/Test.py&quot;</span>, line <span class="number">3</span>, <span class="keyword">in</span> foo</span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span> / <span class="built_in">int</span>(s)</span><br><span class="line">ZeroDivisionError: division by zero</span><br><span class="line">END</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 抛出错误</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">因为错误是class，捕获一个错误就是捕获到该class的一个实例。因此，错误并不是凭空产生的，而是</span></span><br><span class="line"><span class="string">有意创建并抛出的。Python的内置函数会抛出很多类型的错误，我们自己编写的函数也可以抛出错误。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果要抛出错误，首先根据需要，可以定义一个错误的class，选择好继承关系，然后用raise抛出</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FooError</span>(<span class="title class_ inherited__">ValueError</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">s</span>):</span><br><span class="line">    n = <span class="built_in">int</span>(s)</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">raise</span> FooError(<span class="string">&#x27;invalid value: %s&#x27;</span> % s)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span> / n </span><br><span class="line">foo(<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;err_throw.py&quot;</span>, line <span class="number">11</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    foo(<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">  File <span class="string">&quot;err_throw.py&quot;</span>, line <span class="number">8</span>, <span class="keyword">in</span> foo</span><br><span class="line">    <span class="keyword">raise</span> FooError(<span class="string">&#x27;invalid value: %s&#x27;</span> % s)</span><br><span class="line">__main__.FooError: invalid value: <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 另一种错误处理方式</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">s</span>):</span><br><span class="line">    n = <span class="built_in">int</span>(s)</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">&#x27;invalid value: %s&#x27;</span> % s)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span> / n</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bar</span>():</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        foo(<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">    <span class="keyword">except</span> ValueError <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;ValueError!&#x27;</span>)</span><br><span class="line">        <span class="keyword">raise</span></span><br><span class="line">        </span><br><span class="line">bar()</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">在上面函数中，捕获了错误，但又抛出去了，这是为何？</span></span><br><span class="line"><span class="string">这里捕获错误的目的只是为了记录一下，便于后续追踪。但是，由于当前函数不知道应该怎么处理该错误</span></span><br><span class="line"><span class="string">所以，最恰当的方式是继续往上抛，让顶层调用者去处理。好比一个员工处理不了一个问题时，就把问题</span></span><br><span class="line"><span class="string">抛给老板，如果老板也处理不了，就一直往上抛，最终会抛给CEO去处理。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># raise语句如果不带参数，就会把当前错误原样抛出。此外，在except中raise一个Error，还可</span></span><br><span class="line"><span class="comment"># 以把一种类型的错误转换为另一种类型。(合理转换，不是毫无逻辑的转换。)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="number">10</span> / <span class="number">0</span></span><br><span class="line"><span class="keyword">except</span> ZerpDivisionError:</span><br><span class="line">    <span class="keyword">raise</span> ValueError(<span class="string">&#x27;input error!&#x27;</span>)</span><br></pre></td></tr></table></figure>



<br/>



<h5 id="【2】调试"><a href="#【2】调试" class="headerlink" title="【2】调试"></a>【2】调试</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># print()大法</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">直接使用print()把可能有问题的变量打印出来看看。</span></span><br><span class="line"><span class="string">但是用print()最大的坏处是将来还得删掉它，想想程序里到处都是print()，运行结果也会包含很多</span></span><br><span class="line"><span class="string">垃圾信息。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 断言assert（个人感觉不太适合调试，没有打印来的简单明了）</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">assert的意思是，表达式n!=0应该是True，否则，根据程序运行的逻辑，后面的代码肯定会出错。</span></span><br><span class="line"><span class="string">如果断言失败，assert语句本身就会抛出AssertionError</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">s</span>):</span><br><span class="line">    n = <span class="built_in">int</span>(s)</span><br><span class="line">    <span class="keyword">assert</span> n != <span class="number">0</span>,	<span class="string">&#x27;n is zero!&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span> / n </span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    foo(<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>main()</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;/Users/kazama/Documents/VSProject/qemu/Test.py&quot;</span>, line <span class="number">10</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    main()</span><br><span class="line">  File <span class="string">&quot;/Users/kazama/Documents/VSProject/qemu/Test.py&quot;</span>, line <span class="number">7</span>, <span class="keyword">in</span> main</span><br><span class="line">    foo(<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">  File <span class="string">&quot;/Users/kazama/Documents/VSProject/qemu/Test.py&quot;</span>, line <span class="number">3</span>, <span class="keyword">in</span> foo</span><br><span class="line">    <span class="keyword">assert</span> n != <span class="number">0</span>,      <span class="string">&#x27;n is zero!&#x27;</span></span><br><span class="line">AssertionError: n <span class="keyword">is</span> zero!</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动Python解释器时可以用-O参数来关闭assert（O是英文大写字母O，不是0）</span></span><br><span class="line"><span class="comment"># 关闭后，你可以把所有的assert当成pass来看</span></span><br><span class="line">python -O err.py</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># logging大法</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">把print()替换为logging是第三种方式，和assert比，logging不会抛出错误，可输出到文件。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line">s = <span class="string">&#x27;0&#x27;</span></span><br><span class="line">n = <span class="built_in">int</span>(s)</span><br><span class="line">logging.info(<span class="string">&#x27;n = %d&#x27;</span> % n)</span><br><span class="line"><span class="built_in">print</span>(<span class="number">10</span> / n)</span><br><span class="line"></span><br><span class="line"><span class="comment"># logging.info()就可以输出一段文本。运行，发现除了ZeroDivisionError，没有任何信息。</span></span><br><span class="line"><span class="comment"># 在import logging之后添加一行配置再试试</span></span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line">logging.basicConfig(level = logging.INFO)</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">INFO:root:n = <span class="number">0</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;/Users/kazama/Documents/VSProject/qemu/Test.py&quot;</span>, line <span class="number">6</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">10</span> / n)</span><br><span class="line">ZeroDivisionError: division by zero</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">这就是logging的好处，它允许你指定记录信息的级别，有debug，info，warning，error等几个级</span></span><br><span class="line"><span class="string">别，当我们指定level=INFO时，logging.debug就不起作用了。同理，指定level=WARNING后，</span></span><br><span class="line"><span class="string">debug和info就不起作用了。这样一来，你可以放心地输出不同级别的信息，也不用删除，最后统一控制</span></span><br><span class="line"><span class="string">输出哪个级别的信息。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">logging的另一个好处是通过简单的配置，一条语句可以同时输出到不同的地方，比如console和文件。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># pdb (理论上是万能的，但实在是太麻烦了。)</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">启动Python的调试器pdb，让程序以单步方式运行，可以随时查看运行状态。</span></span><br><span class="line"><span class="string">我们先准备好程序 err.py</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">a = <span class="string">&#x27;0&#x27;</span></span><br><span class="line">n = <span class="built_in">int</span>(s)</span><br><span class="line"><span class="built_in">print</span>(<span class="number">10</span> / n)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 然后启动</span></span><br><span class="line">python -m pdb err.py</span><br><span class="line">&gt; /Users/kazama/Documents/VSProject/qemu/Test.py(<span class="number">1</span>)&lt;module&gt;()</span><br><span class="line">-&gt; s = <span class="string">&#x27;0&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 以参数 -m pdb 启动后，pdb定位到下一步要执行的代码 -&gt; s = &#x27;0&#x27;。输入命令l来查看代码</span></span><br><span class="line">(Pdb) l</span><br><span class="line">  <span class="number">1</span>     s = <span class="string">&#x27;0&#x27;</span></span><br><span class="line">  <span class="number">2</span>  -&gt; n = <span class="built_in">int</span>(s)</span><br><span class="line">  <span class="number">3</span>     <span class="built_in">print</span>(<span class="number">10</span>/n)</span><br><span class="line">  <span class="number">4</span>  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 输入命令n可以单步执行代码</span></span><br><span class="line">(Pdb) n</span><br><span class="line">&gt; /Users/kazama/Documents/VSProject/qemu/Test.py(<span class="number">3</span>)&lt;module&gt;()</span><br><span class="line">-&gt; <span class="built_in">print</span>(<span class="number">10</span>/n)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 任何时候都可以输入命令 p 变量名 来查看变量。</span></span><br><span class="line">(Pdb) p s</span><br><span class="line"><span class="string">&#x27;0&#x27;</span></span><br><span class="line">(Pdb) p n</span><br><span class="line"><span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输入命令 q 结束调试，退出程序。</span></span><br><span class="line">(Pdb) q</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过pdb在命令行调试的方法理论上是万能的，但实在是太麻烦了，如果有一千行代码，要运行到第999行得敲多少命令，还好可以用</span></span><br><span class="line"><span class="comment"># pdb.set_trace()</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">这个方法也是用pdb，但是不需要单步执行，我们只需要import pdb，然后在可能出错的地方放一个</span></span><br><span class="line"><span class="string">pdb.set_trace()，就可以设置一个断点。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">import</span> pdb</span><br><span class="line">s = <span class="string">&#x27;0&#x27;</span></span><br><span class="line">n = <span class="built_in">int</span>(s)</span><br><span class="line">pdb.set_trace()		<span class="comment"># 运行到这里会自动暂停</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">10</span> / n)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行代码，程序会自动在 pdb.set_trace() 暂停并进入pdb调试环境，可以使用命令 p 查看变量</span></span><br><span class="line"><span class="comment"># 或者使用命令 c 继续运行</span></span><br><span class="line">$ python err.py </span><br><span class="line">&gt; /Users/michael/Github/learn-python3/samples/debug/err.py(<span class="number">7</span>)&lt;module&gt;()</span><br><span class="line">-&gt; <span class="built_in">print</span>(<span class="number">10</span> / n)</span><br><span class="line">(Pdb) p n</span><br><span class="line"><span class="number">0</span></span><br><span class="line">(Pdb) c</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;err.py&quot;</span>, line <span class="number">7</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">10</span> / n)</span><br><span class="line">ZeroDivisionError: division by zero</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># IDE开发工具</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">如果要比较爽地设置断点、单步执行，就需要一个支持调试功能的IDE。</span></span><br><span class="line"><span class="string">Visual Studio Code：https://code.visualstudio.com/，需要安装Python插件。</span></span><br><span class="line"><span class="string">PyCharm：http://www.jetbrains.com/pycharm/</span></span><br><span class="line"><span class="string">另外，Eclipse加上pydev插件也可以调试Python程序。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 最后你会发现，logging才是最终武器</span></span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line">logging.basicConfig(</span><br><span class="line">	level = logging.DEBUG,</span><br><span class="line">    filename = <span class="string">&quot;test.log&quot;</span>,</span><br><span class="line">    datefmt = <span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>,</span><br><span class="line">    <span class="built_in">format</span> = <span class="string">&quot;[%(asctime)s %(levelname)s] %(lineno)d: %(message)s&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">logging.debug(<span class="string">&quot;debug&quot;</span>)</span><br><span class="line">logging.info(<span class="string">&quot;info&quot;</span>)</span><br><span class="line">logging.warning(<span class="string">&quot;warning&quot;</span>)</span><br><span class="line">logging.error(<span class="string">&quot;error&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>text.log内容 &lt;&lt;&lt;</span><br><span class="line">[<span class="number">2022</span>-<span class="number">12</span>-<span class="number">18</span> <span class="number">14</span>:<span class="number">37</span>:<span class="number">54</span> DEBUG] <span class="number">9</span>: debug</span><br><span class="line">[<span class="number">2022</span>-<span class="number">12</span>-<span class="number">18</span> <span class="number">14</span>:<span class="number">37</span>:<span class="number">54</span> INFO] <span class="number">10</span>: info</span><br><span class="line">[<span class="number">2022</span>-<span class="number">12</span>-<span class="number">18</span> <span class="number">14</span>:<span class="number">37</span>:<span class="number">54</span> WARNING] <span class="number">11</span>: warning</span><br><span class="line">[<span class="number">2022</span>-<span class="number">12</span>-<span class="number">18</span> <span class="number">14</span>:<span class="number">37</span>:<span class="number">54</span> ERROR] <span class="number">12</span>: error</span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认日志级别为WARNING，所以要将DEBUG和INFO的日志文件输出到文件或终端，需要在</span></span><br><span class="line"><span class="comment"># basicConfig中调整&quot;level = logging.DEBUG&quot;</span></span><br></pre></td></tr></table></figure>



<br/>



<h5 id="【3】单元测试"><a href="#【3】单元测试" class="headerlink" title="【3】单元测试"></a>【3】单元测试</h5><p>如果你听说过”测试驱动开发”（TDD：Test-Driven Development），单元测试就不陌生。</p>
<p>单元测试是用来对一个模块、一个函数或者一个类来进行正确性检验对测试工作。</p>
<p>比如对函数<code>abs()</code>，我们可以编写出以下几个测试用例：</p>
<ul>
<li>1、输入正数，比如1、1.2、0.99，期待返回值与输入相同。</li>
<li>2、输入负数，比如-1、-1.2、-0.99，期待返回值与输入相反。</li>
<li>3、输入0，期待返回0.</li>
<li>4、输入非数值类型，比如None、[]、{}，期待抛出TypeError。</li>
</ul>
<p>把上面的测试用例放到一个测试模块里，就是一个完整的单元测试。</p>
<p>如果单元测试通过，说明我们测试的这个函数能够正常工作。如果单元测试不通过，要么函数有bug，要么测试条件输入不正确。</p>
<p>单元测试通过后有什么意义呢？如果我们对abs()函数代码做了修改，只需要再跑一遍单元测试，如果测试通过，说明我们的修改不会对abs()函数原有的行为造成影响，如果测试不通过，说明我们的修改与原有行为不一致，要么修改代码，要么修改测试。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 我们来编写一个Dict类，这个类的行为和dict一致，但是可以通过属性来访问，用起来像下面这样。</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = <span class="type">Dict</span>(a = <span class="number">1</span>, b = <span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d[<span class="string">&#x27;a&#x27;</span>]</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.a</span><br><span class="line"><span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 代码如下：</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dict</span>(<span class="title class_ inherited__">dict</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, **kw</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__(**kw)</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getattr__</span>(<span class="params">self, key</span>):</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">return</span> self[key]</span><br><span class="line">        <span class="keyword">except</span> KeyError:</span><br><span class="line">            <span class="keyword">raise</span> AttributeError(<span class="string">r&quot;&#x27;Dict&#x27; object has no attribute &#x27;%s&#x27;&quot;</span> % key)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__setattr__</span>(<span class="params">self, key, value</span>):</span><br><span class="line">        self[key] = value</span><br><span class="line">        </span><br><span class="line"><span class="comment"># 为了编写单元测试，我们需要引入Python自带的unittest模块，编写mydict_test.py如下：</span></span><br><span class="line"><span class="keyword">import</span> unittest</span><br><span class="line"><span class="keyword">from</span> mydict <span class="keyword">import</span> <span class="type">Dict</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TestDict</span>(unittest.TestCase):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">test_init</span>(<span class="params">self</span>):</span><br><span class="line">        d = <span class="type">Dict</span>(a = <span class="number">1</span>, b = <span class="string">&#x27;test&#x27;</span>)</span><br><span class="line">        self.assertEqual(d.a, <span class="number">1</span>)</span><br><span class="line">        self.assertEqual(d.b, <span class="string">&#x27;test&#x27;</span>)</span><br><span class="line">        self.assertTrue(<span class="built_in">isinstance</span>(d, <span class="built_in">dict</span>))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">test_key</span>(<span class="params">self</span>):</span><br><span class="line">        d = <span class="type">Dict</span>()</span><br><span class="line">        d[<span class="string">&#x27;key&#x27;</span>] = <span class="string">&#x27;value&#x27;</span></span><br><span class="line">        self.assertEqual(d.key, <span class="string">&#x27;value&#x27;</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">test_attr</span>(<span class="params">self</span>):</span><br><span class="line">        d = <span class="type">Dict</span>()</span><br><span class="line">        d.key = <span class="string">&#x27;value&#x27;</span></span><br><span class="line">        self.assertTrue(<span class="string">&#x27;key&#x27;</span> <span class="keyword">in</span> d)</span><br><span class="line">        self.assertEqual(d[<span class="string">&#x27;key&#x27;</span>], <span class="string">&#x27;value&#x27;</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">test_keyerror</span>(<span class="params">self</span>):</span><br><span class="line">        d = <span class="type">Dict</span>()</span><br><span class="line">        <span class="keyword">with</span> self.assertRaises(KeyError):</span><br><span class="line">            value = d[<span class="string">&#x27;empty&#x27;</span>]</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">test_attrerror</span>(<span class="params">self</span>):</span><br><span class="line">        d = <span class="type">Dict</span>()</span><br><span class="line">        <span class="keyword">with</span> self.assertRaises(AttributeError):</span><br><span class="line">            value = d.empty</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">编写单元测试时，我们需要编写一个测试类，从unittest.TestCase继承。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">以test开头的方法就是测试方法，不以test开头的方法不被认为是测试方法，测试的时候不会被执行。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">对每一类测试都需要编写一个test_xxx()方法。由于unittest.TestCase提供了很多内置的条件判</span></span><br><span class="line"><span class="string">断，我们只需要调用这些方法就可以断言输出是否是我们所期望的。最常用的断言就是assertEqual():</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">self.assertEqual(<span class="built_in">abs</span>(-<span class="number">1</span>), <span class="number">1</span>)	<span class="comment"># 断言函数返回的结果与1相等</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 另一种重要的断言就是期待抛出指定类型的Error，比如通过d[&#x27;empty&#x27;]访问不存在的key时，断言</span></span><br><span class="line"><span class="comment"># 会抛出KeyError</span></span><br><span class="line"><span class="keyword">with</span> self.assertRaises(KeyError):</span><br><span class="line">    value = d[<span class="string">&#x27;empty&#x27;</span>]</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 而通过d.empty访问不存在的key时，我们期待抛出AttributeError</span></span><br><span class="line"><span class="keyword">with</span> self.assertRaises(AttributeError):</span><br><span class="line">    value = d.empty</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 运行单元测试</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">最简单的运行方式是在 mydict_test.py 的最后加上两行代码</span></span><br><span class="line"><span class="string">这样就可以把 mydict_test.py 当作正常的python脚本运行。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    unittest.main()</span><br><span class="line">    </span><br><span class="line">$ python mydict_test.py</span><br><span class="line"></span><br><span class="line"><span class="comment"># 另一种方法是在命令行通过参数 -m unittest 直接运行单元测试</span></span><br><span class="line">$ python -m unittest mydict_test</span><br><span class="line">.....</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">Ran <span class="number">5</span> tests <span class="keyword">in</span> <span class="number">0.000</span>s</span><br><span class="line"></span><br><span class="line">OK</span><br><span class="line"><span class="comment"># 第二种是推荐的做法，因为这样可以一次批量运行很多单元测试，并且有很多工具可以自动运行这些</span></span><br><span class="line"><span class="comment"># 单元测试。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># setUp与tearDown</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">可以在单元测试中编写两个特殊的setUp()和tearDown()方法。这两个方法会分别在每调用一个测试方</span></span><br><span class="line"><span class="string">法的前后分别执行。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">setUp()和tearDown()方法有什么用呢？设想你的测试需要启动一个数据库，这时，就可以在setUp()</span></span><br><span class="line"><span class="string">方法中连接数据库，在tearDown()方法中关闭数据库，这样，不必在每个测试方法中重复相同代码</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TestDict</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">setUp</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;setUp...&quot;</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">tearDown</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;tearDown...&quot;</span>)</span><br></pre></td></tr></table></figure>



<br/>



<h5 id="【4】文档测试"><a href="#【4】文档测试" class="headerlink" title="【4】文档测试"></a>【4】文档测试</h5><p>如果你经常阅读Python官方文档，可以看到很多文档都有示例代码。比如<a target="_blank" rel="noopener" href="https://docs.python.org/3/library/re.html">re模块</a>就带了很多示例代码。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 可以把这些示例代码在Python的交互式环境下输入并执行，结果与文档中的示例代码显示的一致。</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">这些代码与其他说明可以写在注释中，然后由一些工具来自动生成文档。既然这些代码本身就可以粘贴出</span></span><br><span class="line"><span class="string">来直接运行，那么，可不可以自动执行写在注释中的这些代码呢？	答案是肯定的</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> re</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m = re.search(<span class="string">&#x27;(?&lt;=abc)def&#x27;</span>, <span class="string">&#x27;abcdef&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m.group(<span class="number">0</span>)</span><br><span class="line"><span class="string">&#x27;def&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 答案是肯定的</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">当我们编写注释时，如果写上这样的注释：</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">abs</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    Function to get absolute value of number.</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Example:</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; abs(1)</span></span><br><span class="line"><span class="string">    1</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; abs(-1)</span></span><br><span class="line"><span class="string">    1</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; abs(0)</span></span><br><span class="line"><span class="string">    0</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">	<span class="keyword">return</span> n <span class="keyword">if</span> n &gt;= <span class="number">0</span> <span class="keyword">else</span> (-n)</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">无疑更明确地告诉函数的调用者该函数的期望输入和输出。</span></span><br><span class="line"><span class="string">并且，Python内置的 &quot;文档测试&quot;（doctest）模块可以直接提取注释中的代码并执行测试。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">doctest严格按照Python交互式命令行的输入和输出来判断测试结果是否正确。只有测试异常的时候，</span></span><br><span class="line"><span class="string">可以用 ... 表示中间一大段烦人的输出。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 让我们用doctest来测试上次编写的Dict类。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dict</span>(<span class="title class_ inherited__">dict</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    Simple dict but also support access as x.y style.</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; d1 = Dict()</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; d1[&#x27;x&#x27;] = 100</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; d1.x</span></span><br><span class="line"><span class="string">    100</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; d1.y = 200</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; d1[&#x27;y&#x27;]</span></span><br><span class="line"><span class="string">    200</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; d2 = Dict(a=1, b=2, c=&#x27;3&#x27;)</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; d2.c</span></span><br><span class="line"><span class="string">    &#x27;3&#x27;</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; d2[&#x27;empty&#x27;]</span></span><br><span class="line"><span class="string">    Traceback (most recent call last):</span></span><br><span class="line"><span class="string">        ...</span></span><br><span class="line"><span class="string">    KeyError: &#x27;empty&#x27;</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; d2.empty</span></span><br><span class="line"><span class="string">    Traceback (most recent call last):</span></span><br><span class="line"><span class="string">        ...</span></span><br><span class="line"><span class="string">    AttributeError: &#x27;Dict&#x27; object has no attribute &#x27;empty&#x27;</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, **kw</span>):</span><br><span class="line">        <span class="built_in">super</span>(<span class="type">Dict</span>, self).__init__(**kw)</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getattr__</span>(<span class="params">self, key</span>):</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">return</span> self[key]</span><br><span class="line">        <span class="keyword">except</span> KeyError:</span><br><span class="line">            <span class="keyword">raise</span> AttributeError(<span class="string">r&quot;&#x27;Dict&#x27; object has no attribute &#x27;%s&#x27;&quot;</span> % key)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__setattr__</span>(<span class="params">self, key, value</span>):</span><br><span class="line">        self[key] = value</span><br><span class="line">        </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="keyword">import</span> doctest</span><br><span class="line">    doctest.testmod()</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行 上面代码，什么输出都没有这说明我们写的doctest运行都是正确的。比如把__getattr__注释掉运行就报错了。</span></span><br><span class="line">$ python mydict2.py</span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意到最后3行代码。当模块正常导入时，doctest不会被执行。只有在命令行直接运行时，才执行</span></span><br><span class="line"><span class="comment"># doctest。所以，不必担心doctest会在非测试环境下执行。</span></span><br></pre></td></tr></table></figure>



<br/>



<h2 id="9、IO编程"><a href="#9、IO编程" class="headerlink" title="9、IO编程"></a>9、IO编程</h2><h5 id="【1】文件读写"><a href="#【1】文件读写" class="headerlink" title="【1】文件读写"></a>【1】文件读写</h5><p>读写文件是最常见的IO操作。Python内置了读写文件的函数，用法和C是兼容的。</p>
<p>读写文件前，我们先必须了解一下，在磁盘上读写文件的功能都是由操作系统提供的，现代操作系统不允许普通的程序员直接操作磁盘，所以，读写文件就是请求操作系统打开一个文件对象（通常称为文件描述符），然后，通过操作系统提供的接口从这个文件对象中读取数据（读文件），或者把数据写入这个文件对象（写文件）。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 读文件</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">要以读文件的模式打开一个文件对象，使用Python内置的 open() 函数，传入文件名和提示符。</span></span><br><span class="line"><span class="string">标识符 &#x27;r&#x27; 表示读，这样，我们就成功地打开了一个文件。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = <span class="built_in">open</span>(<span class="string">&quot;/Users/michael/test.txt&quot;</span>, <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果文件不存在，open()函数就会抛出一个IOError的错误，并且给出错误码和详细信息告诉你文件</span></span><br><span class="line"><span class="comment"># 不存在</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = <span class="built_in">open</span>(<span class="string">&#x27;/Users/michael/notfound.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">FileNotFoundError: [Errno <span class="number">2</span>] No such file <span class="keyword">or</span> directory: <span class="string">&#x27;/Users/michael/notfound.txt&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果文件打开成功，接下来，调用read()方法可以一次读取文件的全部内容，Python把内容读到内存</span></span><br><span class="line"><span class="comment"># 用一个str对象表示</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.read()</span><br><span class="line"><span class="string">&#x27;Hello, world!&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 最后一步调用 close() 方法关闭文件。文件使用完毕后必须关闭，因为文件对象会占用操作系统的</span></span><br><span class="line"><span class="comment"># 资源，并且操作系统同一时间能打开的文件数量也是有限的。</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.close()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 由于文件读写时有可能产生IOError，一旦出错，后面的 f.close() 就不会调用。所以，为例保证</span></span><br><span class="line"><span class="comment"># 无论是否出错都能正确地关闭文件，我们可以使用 try...finally 来实现。</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    f = <span class="built_in">open</span>(<span class="string">&#x27;/path/to/file&#x27;</span>, <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(f.read())</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    <span class="keyword">if</span> f:</span><br><span class="line">        f.close()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 但是每次都如上面那样写实在太繁琐，所以Python引入了with语句来自动帮我们调用close()方法。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">这和前面的 try...finally 是一样的，但是代码更简洁，并且不必调用 f.close() 方法。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">调用read()会一次性读取文件的全部内容，如果文件有10G，内存就爆了，所以，要保险起见，可以反复</span></span><br><span class="line"><span class="string">调用read(size)方法，每次最多读取size个字节的内容。另外，调用readline()可以每次读取一行内</span></span><br><span class="line"><span class="string">容，调用readlines()一次读取所有内容并按行返回list。因此，要根据需要决定怎么调用。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;/path/to/file&quot;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="built_in">print</span>(f.read())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果文件很小，read() 一次读取最方便。如果不能确定文件大小，反复调用read(size)比较保险。</span></span><br><span class="line"><span class="comment"># 如果是配置文件，调用 readlines() 最方便</span></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> f.readlines():</span><br><span class="line">    <span class="built_in">print</span>(line.strip())		<span class="comment"># 把末尾的 &#x27;\n&#x27; 删掉</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="comment"># file-like Object</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">像 open() 函数返回的这种有个 read() 方法的对象，在Python中统称为 file-like Object。</span></span><br><span class="line"><span class="string">除了file外，还可以是内存的字节流，网络流，自定义流等等。file-like Object不要求从特定类</span></span><br><span class="line"><span class="string">继承，只要写个 read() 方法就行。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">StringIO就是在内存中创建的file-like Object，常用作临时缓冲。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 二进制文件</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">前面讲的默认都是读取文本文件，并且是 UTF-8 编码的文本文件。要读取二进制文件，比如图片、视频</span></span><br><span class="line"><span class="string">等等，用 &#x27;rb&#x27; 模式打开文件即可。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = <span class="built_in">open</span>(<span class="string">&#x27;/Users/michael/test.jpg&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.read()</span><br><span class="line"><span class="string">b&#x27;\xff\xd8\xff\xe1\x00\x18Exif\x00\x00...&#x27;</span> <span class="comment"># 十六进制表示的字节</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 字符编码</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">要读取非UTF-8编码的文本文件，需要给open()函数传入encoding参数，例如，读取GBK编码的文件。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = <span class="built_in">open</span>(<span class="string">&quot;/Users/michael/gbk.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, encoding = <span class="string">&quot;gbk&quot;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.read()</span><br><span class="line"><span class="string">&#x27;测试&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 遇到有些编码不规范的文件，你可能会遇到UnicodeDecodeError，因为在文本文件中可能夹杂了</span></span><br><span class="line"><span class="comment"># 一些非法编码的字符。遇到这种情况，open()函数还接收一个errors参数，表示如果遇到编码错误</span></span><br><span class="line"><span class="comment"># 后如何处理。最简单的方式是直接忽略。</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = <span class="built_in">open</span>(<span class="string">&quot;/Users/michael/gbk.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, encoding = <span class="string">&quot;gbk&quot;</span>, errors = <span class="string">&quot;ignore&quot;</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 写文件</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">写文件和读文件是一样的，唯一区别是调用 open() 函数时，传入标识符 &#x27;w&#x27; 或者 &#x27;wb&#x27; 表示写文本</span></span><br><span class="line"><span class="string">文件或写二进制文件。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = <span class="built_in">open</span>(<span class="string">&quot;/Users/michael/test.txt&quot;</span>, <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.write(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">你可以反复调用 write() 来写入文件，但是务必要调用 f.close() 来关闭文件。当我们写文件时，</span></span><br><span class="line"><span class="string">操作系统往往不会立刻把数据写入磁盘，而是放到内存缓存起来，空闲的时候再慢慢写入。只有调用</span></span><br><span class="line"><span class="string">close()方法时，操作系统才保证把没有写入的数据全部写入到磁盘。忘记调用close()的后果是数据</span></span><br><span class="line"><span class="string">可能只写了一部分到磁盘，剩下的丢失了。所以，用with语句比较好</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;/Users/michael/test.txt&quot;</span>, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(<span class="string">&#x27;Hello, world!&#x27;</span>)</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="comment"># 要写入特定编码的文本文件，请给open()函数传入encoding参数，将字符串自动转换成指定编码。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 以 &#x27;w&#x27; 模式写入文件时，如果文件已存在，会直接覆盖（相当于删掉后新写入一个文件）。如果我们</span></span><br><span class="line"><span class="comment"># 希望追加到文件末尾怎么办？可以传入 &#x27;a&#x27; 以追加（append）模式写入。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">所有模式的定义及含义可以参考Python的官方文档。https://docs.python.org/3/library/functions.html#open</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>



<br/>



<h5 id="【2】StringIO和BytesIO"><a href="#【2】StringIO和BytesIO" class="headerlink" title="【2】StringIO和BytesIO"></a>【2】StringIO和BytesIO</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># StringIO</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">StringIO顾名思义就是在内存中读写str。</span></span><br><span class="line"><span class="string">要把str写入StringIO，我们需要先创建一个StringIO，然后，像文件一样写入即可。</span></span><br><span class="line"><span class="string">getvalue()方法用于获得写入后的str</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> io <span class="keyword">import</span> StringIO</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = StringIO()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.write(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.write(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.write(<span class="string">&quot;world!&quot;</span>)</span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(f.getvalue())</span><br><span class="line">hello world!</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 要读取StringIO，可以用一个str初始化StringIO，然后，像读文件一样读取。</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> io <span class="keyword">import</span> StringIO</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = StringIO(<span class="string">&#x27;Hello!\nHi!\nGoodbye!&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"><span class="meta">... </span>	s = f.readline()</span><br><span class="line">...		<span class="keyword">if</span> s == <span class="string">&#x27;&#x27;</span>:</span><br><span class="line">...			<span class="keyword">break</span></span><br><span class="line">...		<span class="built_in">print</span>(s.strip())</span><br><span class="line">...</span><br><span class="line">Hello!</span><br><span class="line">Hi!</span><br><span class="line">Goodbye!</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ByteIO</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">StringIO操作的只能是str，如果要操作二进制数据，就需要使用BytesIO。</span></span><br><span class="line"><span class="string">BytesIO实现了在内存中读写bytes，我们创建一个BytesIO，然后写入一些bytes</span></span><br><span class="line"><span class="string">这里注意，写入的不是str，而是经过UTF-8编码的bytes</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> io <span class="keyword">import</span> BytesIO</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = BytesIO()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.write(<span class="string">&#x27;中文&#x27;</span>.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(f.getvalue())</span><br><span class="line"><span class="string">b&#x27;\xe4\xb8\xad\xe6\x96\x87&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 和StringIO类似，可以用一个bytes初始化BytesIO，然后像文件一样读取。</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> io <span class="keyword">import</span> BytesIO</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = BytesIO(<span class="string">b&#x27;\xe4\xb8\xad\xe6\x96\x87&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.read()</span><br><span class="line"><span class="string">b&#x27;\xe4\xb8\xad\xe6\x96\x87&#x27;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> io <span class="keyword">import</span> StringIO</span><br><span class="line">f = StringIO()</span><br><span class="line">f.write(<span class="string">&#x27;Hello world!&#x27;</span>)  <span class="comment">#此时stream position移动到12</span></span><br><span class="line"><span class="built_in">print</span>(f.getvalue())</span><br><span class="line">s = f.read()   <span class="comment">#从stream position=12的位置读取f内容，s = &#x27;&#x27;</span></span><br><span class="line"> </span><br><span class="line">f.seek(<span class="number">0</span>) <span class="comment">#将stream position拨回到0</span></span><br><span class="line">s = f.read()  <span class="comment">#从头开始读起f内容，s = &#x27;Hello world!&#x27;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># StringIO和BytesIO</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># stringIO 比如说，这时候，你需要对获取到的数据进行操作，但是你并不想把数据写到本地硬盘上，这时候你就可以用stringIO</span></span><br><span class="line"><span class="keyword">from</span> io <span class="keyword">import</span> StringIO</span><br><span class="line"><span class="keyword">from</span> io <span class="keyword">import</span> BytesIO</span><br><span class="line"></span><br><span class="line">s = <span class="string">&#x27;string \nfrom \noutputstring \nfunction&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将函数返回的数据在内存中读</span></span><br><span class="line">sio = StringIO(s)</span><br><span class="line"><span class="comment"># 可以用StringIO本身的方法</span></span><br><span class="line"><span class="built_in">print</span>(sio.getvalue())</span><br><span class="line"><span class="comment"># 也可以用file-like object的方法</span></span><br><span class="line">f = sio.readlines()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> f:</span><br><span class="line">    <span class="built_in">print</span>(i.strip())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将函数返回的数据在内存中写</span></span><br><span class="line">sio = StringIO()</span><br><span class="line">sio.write(s)</span><br><span class="line"><span class="comment"># 可以用StringIO本身的方法查看</span></span><br><span class="line">s = sio.getvalue()</span><br><span class="line"><span class="built_in">print</span>(s)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果你用file-like object的方法查看的时候，你会发现数据为空</span></span><br><span class="line">sio = StringIO()</span><br><span class="line">sio.write(s)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> sio.readlines():</span><br><span class="line">    <span class="built_in">print</span>(i.strip())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这时候我们需要修改下文件的指针位置</span></span><br><span class="line"><span class="comment"># 我们发现可以打印出内容了</span></span><br><span class="line">sio = StringIO()</span><br><span class="line">sio.write(s)</span><br><span class="line">sio.seek(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(sio.tell())</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> sio.readlines():</span><br><span class="line">    <span class="built_in">print</span>(i.strip())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这就涉及到了两个方法seek 和 tell</span></span><br><span class="line"><span class="comment"># tell 方法获取当前文件读取指针的位置</span></span><br><span class="line"><span class="comment"># seek 方法，用于移动文件读写指针到指定位置,有两个参数，第一个offset: 偏移量，需要向前或向后的字节数，正为向后，负为向前；第二个whence: 可选值，默认为0，表示文件开头，1表示相对于当前的位置，2表示文件末尾</span></span><br><span class="line"><span class="comment"># 用seek方法时，需注意，如果你打开的文件没有用&#x27;b&#x27;的方式打开，则offset无法使用负值哦</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># stringIO 只能操作str，如果要操作二进制数据，就需要用到BytesIO</span></span><br><span class="line"><span class="comment"># 上面的sio无法用seek从当前位置向前移动，这时候，我们用&#x27;b&#x27;的方式写入数据，就可以向前移动了</span></span><br><span class="line">bio = BytesIO()</span><br><span class="line">bio.write(s.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(bio.getvalue())</span><br><span class="line">bio.seek(-<span class="number">36</span>, <span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(bio.tell())</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> bio.readlines():</span><br><span class="line">    <span class="built_in">print</span>(i.strip())</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br/>



<h5 id="【3】操作文件和目录"><a href="#【3】操作文件和目录" class="headerlink" title="【3】操作文件和目录"></a>【3】操作文件和目录</h5><p>如果我们要操作文件、目录，可以在命令行下面输入操作系统提供的各种命令来完成。如dir、cp。</p>
<p>如果要在Python程序中执行这些目录和文件的操作怎么办？其实操作系统提供的命令只是简单地调用了操作系统提供的接口函数，Python内置的os模块也可以直接调用操作系统提供的接口函数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 打开Python交互式命令行，我们来看看如何使用os模块的基本功能。</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> os</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.name		<span class="comment"># 操作系统类型</span></span><br><span class="line"><span class="string">&#x27;posix&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">如果是posix，说明系统是Linux、Unix或Mac OS X，如果是nt，就是Windows系统。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 要获取详细的系统信息，可以调用 uname() 函数</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">注意uname()函数在Windows上不提供，也就是说，os模块的某些函数是和操作系统相关的。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(os.uname())</span><br><span class="line">posix.uname_result(sysname=<span class="string">&#x27;Darwin&#x27;</span>, nodename=<span class="string">&#x27;KAZAMAdeMacBook-Air.local&#x27;</span>, release=<span class="string">&#x27;21.5.0&#x27;</span>, version=<span class="string">&#x27;Darwin Kernel Version 21.5.0: Tue Apr 26 21:08:29 PDT 2022; root:xnu-8020.121.3~4/RELEASE_ARM64_T8101&#x27;</span>, machine=<span class="string">&#x27;x86_64&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 环境变量</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">在操作系统中定义的环境变量，全部保存在 os.environ 这个变量中，可以直接查看。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.environ</span><br><span class="line">environ(&#123;<span class="string">&#x27;VERSIONER_PYTHON_PREFER_32_BIT&#x27;</span>: <span class="string">&#x27;no&#x27;</span>, <span class="string">&#x27;TERM_PROGRAM_VERSION&#x27;</span>: <span class="string">&#x27;326&#x27;</span>, <span class="string">&#x27;LOGNAME&#x27;</span>: <span class="string">&#x27;michael&#x27;</span>, <span class="string">&#x27;USER&#x27;</span>: <span class="string">&#x27;michael&#x27;</span>, <span class="string">&#x27;PATH&#x27;</span>: <span class="string">&#x27;/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin:/opt/X11/bin:/usr/local/mysql/bin&#x27;</span>, ...&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 要获取某个环境变量的值，可以调用 os.environ.get(&#x27;key&#x27;)</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.environ.get(<span class="string">&#x27;PATH&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin:/opt/X11/bin:/usr/local/mysql/bin&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.environ.get(<span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;default&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;default&#x27;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 操作文件和目录</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">操作文件和目录的函数一部分放在os模块中，一部分放在os.path模块中，这一点要注意一下。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># 查看当前目录的绝对路径</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.path.abspath(<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;/Users/michael&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在某个目录下创建一个新目录，首先把新目录的完整路径表示出来。</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.path.join(<span class="string">&quot;/Users/michael&quot;</span>, <span class="string">&quot;testdir&quot;</span>)</span><br><span class="line"><span class="string">&#x27;/Users/michael/testdir&#x27;</span></span><br><span class="line"><span class="comment"># 然后创建一个目录:</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.mkdir(<span class="string">&#x27;/Users/michael/testdir&#x27;</span>)</span><br><span class="line"><span class="comment"># 删掉一个目录:</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.rmdir(<span class="string">&#x27;/Users/michael/testdir&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 把两个路径合成一个时，不要直接拼字符串，而要通过os.path.join()函数，这样可以正确处理不</span></span><br><span class="line"><span class="comment"># 同操作系统的路径分隔符。在Linux/Unix/Mac下，os.path.join()返回这样的字符串。</span></span><br><span class="line">part-<span class="number">1</span>/part-<span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 而Windows下会返回这样的字符串</span></span><br><span class="line">part-<span class="number">1</span>\part-<span class="number">2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 同样的道理，要拆分路径时，也不要去拆字符串，而要通过os.path.split()函数，这样可以把一个</span></span><br><span class="line"><span class="comment"># 路径拆分为两部分，后一部分总是最后级别的目录或文件名</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.path.split(<span class="string">&#x27;/Users/michael/testdir/file.txt&#x27;</span>)</span><br><span class="line">(<span class="string">&#x27;/Users/michael/testdir&#x27;</span>, <span class="string">&#x27;file.txt&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># os.path.splitext()可以直接让你得到文件扩展名，很多时候非常方便：</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.path.splitext(<span class="string">&#x27;/path/to/file.txt&#x27;</span>)</span><br><span class="line">(<span class="string">&#x27;/path/to/file&#x27;</span>, <span class="string">&#x27;.txt&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">这些合并、拆分路径的函数并不要求目录和文件要真实存在，它们只对字符串进行操作。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 文件操作使用下面的函数。假定当前目录下有一个 test.txt 文件。</span></span><br><span class="line"><span class="comment"># 对文件重命名:</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.rename(<span class="string">&#x27;test.txt&#x27;</span>, <span class="string">&#x27;test.py&#x27;</span>)</span><br><span class="line"><span class="comment"># 删掉文件:</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.remove(<span class="string">&#x27;test.py&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 但是复制文件的函数在os模块中不存在！原因是复制文件并非由操作系统提供的系统调用。</span></span><br><span class="line"><span class="comment"># 理论上讲，我们通过上一节的读写文件可以完成文件复制，只不过要多写很多代码。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 幸运的是 shutil 模块提供了 copyfile() 的函数，你还可以在 shutil模块中找到很多实用函数</span></span><br><span class="line"><span class="comment"># 它们可以看作是 os 模块的补充。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 最后看看如何利用Python的特性来过滤文件。比如我们要列出当前目录下的所有目录，只需一行代码</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[x <span class="keyword">for</span> x <span class="keyword">in</span> os.listdir(<span class="string">&#x27;.&#x27;</span>) <span class="keyword">if</span> os.path.isdir(x)]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 要列出所有的 .py 文件，也只需一行代码</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[x <span class="keyword">for</span> x <span class="keyword">in</span> os.listdir(<span class="string">&#x27;.&#x27;</span>) <span class="keyword">if</span> os.path.isfile(x) <span class="keyword">and</span> os.path.splitext(x)[<span class="number">1</span>] == <span class="string">&#x27;.py&#x27;</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 编写一个程序，能在当前目录以及当前目录的所有子目录下查找文件名包含指定字符串的文件，并打印出相对路径。</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">find</span>(<span class="params">s, dest=<span class="literal">None</span>, pat=<span class="string">&#x27;.&#x27;</span>, level=<span class="number">0</span></span>):</span><br><span class="line">    <span class="keyword">if</span> dest <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        dest = []</span><br><span class="line">    abspath = os.path.abspath(pat)</span><br><span class="line">    lispath = os.listdir(abspath)</span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> [os.path.join(abspath, x) <span class="keyword">for</span> x <span class="keyword">in</span> lispath]:</span><br><span class="line">        <span class="keyword">if</span> os.path.isdir(p):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;  &#x27;</span> * level + <span class="string">&#x27;|- &#x27;</span> + os.path.relpath(p))</span><br><span class="line">            find(s, dest, p, level + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;  &#x27;</span> * level + <span class="string">&#x27;|- &#x27;</span> + os.path.relpath(p))</span><br><span class="line">            <span class="keyword">if</span> os.path.split(p)[<span class="number">1</span>].split(<span class="string">&#x27;.&#x27;</span>)[<span class="number">0</span>].find(s) != -<span class="number">1</span>:</span><br><span class="line">                dest.append(p)</span><br><span class="line">    <span class="keyword">return</span> dest</span><br><span class="line"></span><br><span class="line">result = find(<span class="string">&#x27;Pip&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure>



<br/>



<h5 id="【4】序列化"><a href="#【4】序列化" class="headerlink" title="【4】序列化"></a>【4】序列化</h5><p>在程序运行的过程中，所有的变量都是在内存中，比如，定义一个dict。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d = <span class="built_in">dict</span>(name=<span class="string">&#x27;Bob&#x27;</span>, age=<span class="number">20</span>, score=<span class="number">88</span>)</span><br></pre></td></tr></table></figure>

<p>可以随时修改变量，比如把<code>name</code>改成<code>&#39;Bill&#39;</code>，但是一旦程序结束，变量所占用的内存就被操作系统全部回收。如果没有把修改后的<code>&#39;Bill&#39;</code>存储到磁盘上，下次重新运行程序，变量又被初始化为<code>&#39;Bob&#39;</code>。</p>
<p>我们把变量从内存中变成可存储或传输的过程称之为序列化，在Python中叫pickling，在其他语言中也被称之为serialization，marshalling，flattening等等，都是一个意思。</p>
<p>序列化之后，就可以把序列化后的内容写入磁盘，或者通过网络传输到别的机器上。</p>
<p>反过来，把变量内容从序列化的对象重新读到内存里称之为反序列化，即unpickling。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># python提供了pickle模块来实现序列化。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">首先，我们尝试把一个对象序列化并写入文件。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">pickle.dumps()方法把任意对象序列化成一个bytes，然后，就可以把这个bytes写入文件。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> pickle</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = <span class="built_in">dict</span>(name=<span class="string">&#x27;Bob&#x27;</span>, age=<span class="number">20</span>, score=<span class="number">88</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pickle.dumps(d)</span><br><span class="line"><span class="string">b&#x27;\x80\x03&#125;q\x00(X\x03\x00\x00\x00ageq\x01K\x14X\x05\x00\x00\x00scoreq\x02KXX\x04\x00\x00\x00nameq\x03X\x03\x00\x00\x00Bobq\x04u.&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者用另一个方法pickle.dump()直接把对象序列化后写入一个file-like Object</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">看看写入的dump.txt文件，一堆乱七八糟的内容，这些都是Python保存的对象内部信息。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = <span class="built_in">open</span>(<span class="string">&#x27;dump.txt&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pickle.dump(d, f)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 反序列化</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">当我们要把对象从磁盘读到内存时，可以先把内容读到一个bytes，然后用</span></span><br><span class="line"><span class="string">pickle.loads()方法反序列化出对象，也可以直接用pickle.load()方法从一个</span></span><br><span class="line"><span class="string">file-like Object中直接反序列化出对象。我们打开另一个Python命令行来反序列</span></span><br><span class="line"><span class="string">化刚才保存的对象。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">当然，这个反序列化回来的变量和原来的变量是完全不相干的对象，它们只是内容相同而已。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Pickle的问题和所有其他编程语言特有的序列化问题一样，就是它只能用于Python，并且可能不同版本的Python彼此都不兼容，因此，只能用Pickle保存那些不重要的数据，不能成功地反序列化也没关系。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = <span class="built_in">open</span>(<span class="string">&#x27;dump.txt&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = pickle.load(f)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.close()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d</span><br><span class="line">&#123;<span class="string">&#x27;age&#x27;</span>: <span class="number">20</span>, <span class="string">&#x27;score&#x27;</span>: <span class="number">88</span>, <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Bob&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># JSON</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">如果我们要在不同的编程语言之间传递对象，就必须把对象序列化为标准格式，比如XML，但更好的方法是序列化为JSON，因为JSON表示出来就是一个字符串，可以被所有语言读取，也可以方便地存储到磁盘或者通过网络传输。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">JSON不仅是标准格式，并且比XML更快，而且可以直接在Web页面中读取，非常方便。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">JSON表示的对象就是标准的JavaScript语言的对象，JSON和Python内置的数据类型对应如下：</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">JSON类型	Python类型</span><br><span class="line">&#123;&#125;			<span class="built_in">dict</span></span><br><span class="line">[]			<span class="built_in">list</span></span><br><span class="line"><span class="string">&quot;string&quot;</span>	 <span class="built_in">str</span></span><br><span class="line"><span class="number">1234.56</span>		 <span class="built_in">int</span>或<span class="built_in">float</span></span><br><span class="line">true/false	 <span class="literal">True</span>/<span class="literal">False</span></span><br><span class="line">null		 <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Python内置的json模块提供了非常完善的Python对象到JSON格式的转换</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">dumps()方法返回一个str，内容就是标准的JSON。类似的，dump()方法可以直接把</span></span><br><span class="line"><span class="string">JSON写入一个file-like Object。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> json</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = <span class="built_in">dict</span>(name=<span class="string">&#x27;Bob&#x27;</span>, age=<span class="number">20</span>, score=<span class="number">88</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>json.dumps(d)</span><br><span class="line"><span class="string">&#x27;&#123;&quot;age&quot;: 20, &quot;score&quot;: 88, &quot;name&quot;: &quot;Bob&quot;&#125;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 把JSON反序列化为Python对象</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">用loads()或者对应的load()方法，前者把JSON的字符串反序列化，后者从</span></span><br><span class="line"><span class="string">file-like Object中读取字符串并反序列化。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">由于JSON标准规定JSON编码是UTF-8，所以我们总是能正确地在Python的str与JSON</span></span><br><span class="line"><span class="string">的字符串之间转换。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>json_str = <span class="string">&#x27;&#123;&quot;age&quot;: 20, &quot;score&quot;: 88, &quot;name&quot;: &quot;Bob&quot;&#125;&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>json.loads(json_str)</span><br><span class="line">&#123;<span class="string">&#x27;age&#x27;</span>: <span class="number">20</span>, <span class="string">&#x27;score&#x27;</span>: <span class="number">88</span>, <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Bob&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># JSON进阶</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Python的dict对象可以直接序列化为JSON的&#123;&#125;，不过，很多时候，我们更喜欢用</span></span><br><span class="line"><span class="string">class表示对象，比如定义Student类，然后序列化</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age, score</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">        self.score = score</span><br><span class="line">        </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = Student(<span class="string">&#x27;Bob&#x27;</span>, <span class="number">20</span>, <span class="number">88</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(json.dumps(s))</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  ...</span><br><span class="line">TypeError: &lt;__main__.Student <span class="built_in">object</span> at <span class="number">0x10603cc50</span>&gt; <span class="keyword">is</span> <span class="keyword">not</span> JSON serializable</span><br><span class="line">    </span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">错误原因是Student对象不是一个可序列化为JSON的对象。</span></span><br><span class="line"><span class="string">如果连 class 的实例对象都无法序列化为JSON，这肯定不合理！</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们仔细看一下 dumps() 方法的参数列表，可以发现，除了第一个必须的obj参</span></span><br><span class="line"><span class="comment"># 数外，dumps()方法还提供了一大堆的可选参数。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">https://docs.python.org/3/library/json.html#json.dumps</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这些可选参数就是让我们来定制JSON序列化。前面的代码之所以无法把Student类</span></span><br><span class="line"><span class="comment"># 实例序列化为JSON，是因为默认情况下，dumps()方法不知道如何将Student实例</span></span><br><span class="line"><span class="comment"># 变为一个JSON的&#123;&#125;对象。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">可选参数default就是把任意一个对象变成一个可序列化为JSON的对象，我们只需要</span></span><br><span class="line"><span class="string">为Student专门写一个转换函数，再把函数传进去即可。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">student2dict</span>(<span class="params">std</span>):</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="string">&#x27;name&#x27;</span>: std.name,</span><br><span class="line">        <span class="string">&#x27;age&#x27;</span>:	std.age,</span><br><span class="line">        <span class="string">&#x27;score&#x27;</span>: std.score</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这样Student实例首先被student2dict()函数转换成dict，然后再被顺利序列化为JSON</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(json.dumps(s, default = student2dict))</span><br><span class="line">&#123;<span class="string">&quot;age&quot;</span>: <span class="number">20</span>, <span class="string">&quot;name&quot;</span>: <span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;score&quot;</span>: <span class="number">88</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不过下一次如果遇到一个Teacher类的实例，照样无法序列化为JSON。我们可以偷</span></span><br><span class="line"><span class="comment"># 个懒，把任意class的实例变为dict</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">因为通常class的实例都有一个 __dict__属性，它就是一个dict，用来存储实例变</span></span><br><span class="line"><span class="string">量。也有少数例外，比如定义了 __slots__的class。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(json.dumps(s, default=<span class="keyword">lambda</span> obj: obj.__dict__))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果我们要把JSON反序列化为一个Student对象实例，loads()方法首先转换出一</span></span><br><span class="line"><span class="comment"># 个dict对象，然后，我们传入的object_hook函数负责把dict转为Student实例。</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dict2student</span>(<span class="params">d</span>):</span><br><span class="line">    <span class="keyword">return</span> Student(d[<span class="string">&#x27;name&#x27;</span>], d[<span class="string">&#x27;age&#x27;</span>], d[<span class="string">&#x27;score&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>json_str = <span class="string">&#x27;&#123;&quot;age&quot;: 20, &quot;score&quot;: 88, &quot;name&quot;: &quot;Bob&quot;&#125;&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(json.loads(json_str, object_hook=dict2student))</span><br><span class="line"><span class="string">&quot;&quot;&quot;打印出的是反序列化的Student实例对象&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>



<br/>



<h2 id="10、进程与线程"><a href="#10、进程与线程" class="headerlink" title="10、进程与线程"></a>10、进程与线程</h2><p>现在，多核CPU已经非常普及了，但是，即使过去的单核CPU，也可以执行多任务。由于CPU执行代码都是顺序执行的，那么，单核CPU是怎么执行多任务的呢？</p>
<p>答案就是操作系统轮流让各个任务交替执行，任务1执行0.01秒，切换到任务2，任务2执行0.01秒，再切换到任务3，执行0.01秒……这样反复执行下去。表面上看，每个任务都是交替执行的，但是，由于CPU的执行速度实在是太快了，我们感觉就像所有任务都在同时执行一样。</p>
<p>真正的并行执行多任务只能在多核CPU上实现，但是，由于任务数量远远多于CPU的核心数量，所以，操作系统也会自动把很多任务轮流调度到每个核心上执行。</p>
<p>对于操作系统来说，一个任务就是一个进程（Process），比如打开一个浏览器就是启动一个浏览器进程，打开一个记事本就启动了一个记事本进程，打开两个记事本就启动了两个记事本进程，打开一个Word就启动了一个Word进程。</p>
<p>有些进程还不止同时干一件事，比如Word，它可以同时进行打字、拼写检查、打印等事情。在一个进程内部，要同时干多件事，就需要同时运行多个“子任务”，我们把进程内的这些“子任务”称为线程（Thread）。</p>
<p>由于每个进程至少要干一件事，所以，一个进程至少有一个线程。当然，像Word这种复杂的进程可以有多个线程，多个线程可以同时执行，多线程的执行方式和多进程是一样的，也是由操作系统在多个线程之间快速切换，让每个线程都短暂地交替运行，看起来就像同时执行一样。当然，真正地同时执行多线程需要多核CPU才可能实现。</p>
<p>我们前面编写的所有的Python程序，都是执行单任务的进程，也就是只有一个线程。如果我们要同时执行多个任务怎么办？</p>
<p>有两种解决方案：</p>
<p>一种是启动多个进程，每个进程虽然只有一个线程，但多个进程可以一块执行多个任务。</p>
<p>还有一种方法是启动一个进程，在一个进程内启动多个线程，这样，多个线程也可以一块执行多个任务。</p>
<p>当然还有第三种方法，就是启动多个进程，每个进程再启动多个线程，这样同时执行的任务就更多了，当然这种模型更复杂，实际很少采用。</p>
<p>总结一下就是，多任务的实现有3种方式：</p>
<ul>
<li>多进程模式；</li>
<li>多线程模式；</li>
<li>多进程+多线程模式。</li>
</ul>
<p>Python既支持多进程，又支持多线程，我们会讨论如何编写这两种多任务程序。</p>
<p><strong>小结：</strong> 线程是最小的执行单元，而进程由至少一个线程组成。如何调度进程和线程，完全由操作系统决定，程序自己不能决定什么时候执行，执行多长时间。多进程和多线程的程序涉及到同步、数据共享的问题，编写起来更复杂。</p>
<br/>



<h5 id="【1】多进程"><a href="#【1】多进程" class="headerlink" title="【1】多进程"></a>【1】多进程</h5><p>Unix/Linux操作系统提供了一个<code>fork()</code>系统调用，它非常特殊。普通的函数调用，调用一次，返回一次，但是<code>fork()</code>调用一次，返回两次，因为操作系统自动把当前进程（称为父进程）复制了一份（称为子进程），然后，分别在父进程和子进程内返回。</p>
<p>子进程永远返回<code>0</code>，而父进程返回子进程的ID。这样做的理由是，一个父进程可以fork出很多子进程，所以，父进程要记下每个子进程的ID，而子进程只需要调用<code>getppid()</code>就可以拿到父进程的ID。</p>
<p>Python的<code>os</code>模块封装了常见的系统调用，其中就包括<code>fork</code>，可以在Python程序中轻松创建子进程：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Process (%s) start...&#x27;</span> % os.getpid())</span><br><span class="line"><span class="comment"># Only works on Unix/Linux/Mac:</span></span><br><span class="line">pid = os.fork()</span><br><span class="line"><span class="keyword">if</span> pid == <span class="number">0</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;I am child process (%s) and my parent is %s.&#x27;</span> % (os.getpid(), os.getppid()))</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;I (%s) just created a child process (%s).&#x27;</span> % (os.getpid(), pid))</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 运行结果如下</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">由于Windows没有fork调用，上面的代码在Windows上无法运行。而Mac系统是基于</span></span><br><span class="line"><span class="string">BSD（Unix的一种）内核，所以，在Mac下运行是没有问题的。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">有了fork调用，一个进程在接到新任务时就可以复制出一个子进程来处理新任务，常</span></span><br><span class="line"><span class="string">见的Apache服务器就是由父进程监听端口，每当有新的http请求时，就fork出子进程</span></span><br><span class="line"><span class="string">来处理新的http请求。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">Process (<span class="number">876</span>) start...</span><br><span class="line">I (<span class="number">876</span>) just created a child process (<span class="number">877</span>).</span><br><span class="line">I am child process (<span class="number">877</span>) <span class="keyword">and</span> my parent <span class="keyword">is</span> <span class="number">876.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># multiprocessing</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">如果你打算编写多进程的服务程序，Unix/Linux无疑是正确的选择。由于Windows没</span></span><br><span class="line"><span class="string">有fork调用，难道在Windows上无法用Python编写多进程的程序？</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">由于Python是跨平台的，自然也应该提供一个跨平台的多进程支持。multiprocessing模块就是跨平台版本的多进程模块。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">multiprocessing模块提供了一个Process类来代表一个进程对象，下面的例子演示</span></span><br><span class="line"><span class="string">了启动一个子进程并等待其结束</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="comment"># 子进程要执行的代码</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run_proc</span>(<span class="params">name</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Run child process %s (%s)...&#x27;</span> % (name, os.getpid()))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Parent process %s.&#x27;</span> % os.getpid())</span><br><span class="line">    p = Process(target=run_proc, args=(<span class="string">&#x27;test&#x27;</span>,))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Child process will start.&#x27;</span>)</span><br><span class="line">    p.start()</span><br><span class="line">    p.join()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Child process end.&#x27;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 执行结果</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">创建子进程时，只需要传入一个执行函数和函数的参数，创建一个Process实例，用start()方法启动，这样创建进程比fork()还要简单。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">join()方法可以等待子进程结束后再继续往下运行，通常用于进程间的同步。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">Parent process <span class="number">928.</span></span><br><span class="line">Child process will start.</span><br><span class="line">Run child process test (<span class="number">929</span>)...</span><br><span class="line">Process end.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Pool</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">如果要启动大量的子进程，可以用进程池的方式批量创建子进程。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</span><br><span class="line"><span class="keyword">import</span> os, time, random</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">long_time_task</span>(<span class="params">name</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Run task %s (%s)...&#x27;</span> % (name, os.getpid()))</span><br><span class="line">    start = time.time()</span><br><span class="line">    time.sleep(random.random() * <span class="number">3</span>)</span><br><span class="line">    end = time.time()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Task %s runs %0.2f seconds.&#x27;</span> % (name, (end - start)))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Parent process %s.&#x27;</span> % os.getpid())</span><br><span class="line">    p = Pool(<span class="number">4</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">        p.apply_async(long_time_task, args=(i,))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Waiting for all subprocesses done...&#x27;</span>)</span><br><span class="line">    p.close()</span><br><span class="line">    p.join()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;All subprocesses done.&#x27;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 执行结果如下</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">对Pool对象调用join()方法会等待所有子进程执行完毕，调用join()之前必须先调用</span></span><br><span class="line"><span class="string">close()，调用close()之后就不能继续添加新的Process了。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">Parent process <span class="number">669.</span></span><br><span class="line">Waiting <span class="keyword">for</span> <span class="built_in">all</span> subprocesses done...</span><br><span class="line">Run task <span class="number">0</span> (<span class="number">671</span>)...</span><br><span class="line">Run task <span class="number">1</span> (<span class="number">672</span>)...</span><br><span class="line">Run task <span class="number">2</span> (<span class="number">673</span>)...</span><br><span class="line">Run task <span class="number">3</span> (<span class="number">674</span>)...</span><br><span class="line">Task <span class="number">2</span> runs <span class="number">0.14</span> seconds.</span><br><span class="line">Run task <span class="number">4</span> (<span class="number">673</span>)...</span><br><span class="line">Task <span class="number">1</span> runs <span class="number">0.27</span> seconds.</span><br><span class="line">Task <span class="number">3</span> runs <span class="number">0.86</span> seconds.</span><br><span class="line">Task <span class="number">0</span> runs <span class="number">1.41</span> seconds.</span><br><span class="line">Task <span class="number">4</span> runs <span class="number">1.91</span> seconds.</span><br><span class="line">All subprocesses done.</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">请注意输出的结果，task 0，1，2，3是立刻执行的，而task 4要等待前面某个task</span></span><br><span class="line"><span class="string">完成后才执行，这是因为Pool的默认大小在我的电脑上是4，因此，最多同时执行4个</span></span><br><span class="line"><span class="string">进程。这是Pool有意设计的限制，并不是操作系统的限制。如果改成</span></span><br><span class="line"><span class="string">p = Pool(5)</span></span><br><span class="line"><span class="string">就可以同时跑5个进程。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">由于Pool的默认大小是CPU的核数，如果你不幸拥有8核CPU，你要提交至少9个子进程</span></span><br><span class="line"><span class="string">才能看到上面的等待效果。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 子进程</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">很多时候，子进程并不是自身，而是一个外部进程。我们创建了子进程后，还需要控</span></span><br><span class="line"><span class="string">制子进程的输入和输出。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">subprocess模块可以让我们非常方便地启动一个子进程，然后控制其输入和输出。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">下面的例子演示了如何在Python代码中运行命令nslookup www.python.org，这和命</span></span><br><span class="line"><span class="string">令行直接运行的效果是一样的</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;$ nslookup www.python.org&#x27;</span>)</span><br><span class="line">r = subprocess.call([<span class="string">&#x27;nslookup&#x27;</span>, <span class="string">&#x27;www.python.org&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Exit code:&#x27;</span>, r)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行结果</span></span><br><span class="line">$ nslookup www.python.org</span><br><span class="line">Server:		<span class="number">192.168</span><span class="number">.19</span><span class="number">.4</span></span><br><span class="line">Address:	<span class="number">192.168</span><span class="number">.19</span><span class="number">.4</span><span class="comment">#53</span></span><br><span class="line"></span><br><span class="line">Non-authoritative answer:</span><br><span class="line">www.python.org	canonical name = python.<span class="built_in">map</span>.fastly.net.</span><br><span class="line">Name:	python.<span class="built_in">map</span>.fastly.net</span><br><span class="line">Address: <span class="number">199.27</span><span class="number">.79</span><span class="number">.223</span></span><br><span class="line"></span><br><span class="line">Exit code: <span class="number">0</span></span><br><span class="line">    </span><br><span class="line"><span class="comment"># 如果子进程还需要输入，则可以通过communicate()方法输入</span></span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;$ nslookup&#x27;</span>)</span><br><span class="line">p = subprocess.Popen([<span class="string">&#x27;nslookup&#x27;</span>], stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE)</span><br><span class="line">output, err = p.communicate(<span class="string">b&#x27;set q=mx\npython.org\nexit\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(output.decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Exit code:&#x27;</span>, p.returncode)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 上面的代码相当于在命令行执行命令nslookup，然后手动输入</span></span><br><span class="line"><span class="built_in">set</span> q=mx</span><br><span class="line">python.org</span><br><span class="line">exit</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行结果如下</span></span><br><span class="line">$ nslookup</span><br><span class="line">Server:		<span class="number">192.168</span><span class="number">.19</span><span class="number">.4</span></span><br><span class="line">Address:	<span class="number">192.168</span><span class="number">.19</span><span class="number">.4</span><span class="comment">#53</span></span><br><span class="line"></span><br><span class="line">Non-authoritative answer:</span><br><span class="line">python.org	mail exchanger = <span class="number">50</span> mail.python.org.</span><br><span class="line"></span><br><span class="line">Authoritative answers can be found <span class="keyword">from</span>:</span><br><span class="line">mail.python.org	internet address = <span class="number">82.94</span><span class="number">.164</span><span class="number">.166</span></span><br><span class="line">mail.python.org	has AAAA address <span class="number">2001</span>:<span class="number">888</span>:<span class="number">2000</span>:d::a6</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Exit code: <span class="number">0</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="comment"># 进程间通信</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Process之间肯定是需要通信的，操作系统提供了很多机制来实现进程间的通信。</span></span><br><span class="line"><span class="string">Python的multiprocessing模块包装了底层的机制，提供了Queue、Pipes等多种方</span></span><br><span class="line"><span class="string">式来交换数据。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">我们以Queue为例，在父进程中创建两个子进程，一个往Queue里写数据，一个从</span></span><br><span class="line"><span class="string">Queue里读数据</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process, Queue</span><br><span class="line"><span class="keyword">import</span> os, time, random</span><br><span class="line"></span><br><span class="line"><span class="comment"># 写数据进程执行的代码:</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">write</span>(<span class="params">q</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Process to write: %s&#x27;</span> % os.getpid())</span><br><span class="line">    <span class="keyword">for</span> value <span class="keyword">in</span> [<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>]:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Put %s to queue...&#x27;</span> % value)</span><br><span class="line">        q.put(value)</span><br><span class="line">        time.sleep(random.random())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读数据进程执行的代码:</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">read</span>(<span class="params">q</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Process to read: %s&#x27;</span> % os.getpid())</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        value = q.get(<span class="literal">True</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Get %s from queue.&#x27;</span> % value)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 父进程创建Queue，并传给各个子进程：</span></span><br><span class="line">    q = Queue()</span><br><span class="line">    pw = Process(target=write, args=(q,))</span><br><span class="line">    pr = Process(target=read, args=(q,))</span><br><span class="line">    <span class="comment"># 启动子进程pw，写入:</span></span><br><span class="line">    pw.start()</span><br><span class="line">    <span class="comment"># 启动子进程pr，读取:</span></span><br><span class="line">    pr.start()</span><br><span class="line">    <span class="comment"># 等待pw结束:</span></span><br><span class="line">    pw.join()</span><br><span class="line">    <span class="comment"># pr进程里是死循环，无法等待其结束，只能强行终止:</span></span><br><span class="line">    pr.terminate()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行结果如下</span></span><br><span class="line">Process to write: <span class="number">50563</span></span><br><span class="line">Put A to queue...</span><br><span class="line">Process to read: <span class="number">50564</span></span><br><span class="line">Get A <span class="keyword">from</span> queue.</span><br><span class="line">Put B to queue...</span><br><span class="line">Get B <span class="keyword">from</span> queue.</span><br><span class="line">Put C to queue...</span><br><span class="line">Get C <span class="keyword">from</span> queue.</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">在Unix/Linux下，multiprocessing模块封装了fork()调用，使我们不需要关注</span></span><br><span class="line"><span class="string">fork()的细节。由于Windows没有fork调用，因此，multiprocessing需要“模拟”出</span></span><br><span class="line"><span class="string">fork的效果，父进程所有Python对象都必须通过pickle序列化再传到子进程去，所</span></span><br><span class="line"><span class="string">以，如果multiprocessing在Windows下调用失败了，要先考虑是不是pickle失败</span></span><br><span class="line"><span class="string">了。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 小结</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">在Unix/Linux下，可以使用fork()调用实现多进程。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">要实现跨平台的多进程，可以使用multiprocessing模块。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">进程间通信是通过Queue、Pipes等实现的。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>



<br/>



<h5 id="【2】多线程"><a href="#【2】多线程" class="headerlink" title="【2】多线程"></a>【2】多线程</h5><p>多任务可以由多进程完成，也可以由一个进程内的多线程完成。</p>
<p>我们前面提到了进程是由若干线程组成的，一个进程至少有一个线程。</p>
<p>由于线程是操作系统直接支持的执行单元，因此，高级语言通常都内置多线程的支持，Python也不例外，并且，Python的线程是真正的Posix Thread，而不是模拟出来的线程。</p>
<p>Python的标准库提供了两个模块：<code>_thread</code>和<code>threading</code>，<code>_thread</code>是低级模块，<code>threading</code>是高级模块，对<code>_thread</code>进行了封装。绝大多数情况下，我们只需要使用<code>threading</code>这个高级模块。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动一个线程就是把一个函数传入并创建Thread实例，然后调用start()开始执行</span></span><br><span class="line"><span class="keyword">import</span> time, threading</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新线程执行的代码:</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">loop</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;thread %s is running...&#x27;</span> % threading.current_thread().name)</span><br><span class="line">    n = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> n &lt; <span class="number">5</span>:</span><br><span class="line">        n = n + <span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;thread %s &gt;&gt;&gt; %s&#x27;</span> % (threading.current_thread().name, n))</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;thread %s ended.&#x27;</span> % threading.current_thread().name)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;thread %s is running...&#x27;</span> % threading.current_thread().name)</span><br><span class="line">t = threading.Thread(target=loop, name=<span class="string">&#x27;LoopThread&#x27;</span>)</span><br><span class="line">t.start()</span><br><span class="line">t.join()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;thread %s ended.&#x27;</span> % threading.current_thread().name)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行结果如下</span></span><br><span class="line">thread MainThread <span class="keyword">is</span> running...</span><br><span class="line">thread LoopThread <span class="keyword">is</span> running...</span><br><span class="line">thread LoopThread &gt;&gt;&gt; <span class="number">1</span></span><br><span class="line">thread LoopThread &gt;&gt;&gt; <span class="number">2</span></span><br><span class="line">thread LoopThread &gt;&gt;&gt; <span class="number">3</span></span><br><span class="line">thread LoopThread &gt;&gt;&gt; <span class="number">4</span></span><br><span class="line">thread LoopThread &gt;&gt;&gt; <span class="number">5</span></span><br><span class="line">thread LoopThread ended.</span><br><span class="line">thread MainThread ended.</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">由于任何进程默认就会启动一个线程，我们把该线程称为主线程，主线程又可以启动</span></span><br><span class="line"><span class="string">新的线程，Python的threading模块有个current_thread()函数，它永远返回当前</span></span><br><span class="line"><span class="string">线程的实例。主线程实例的名字叫MainThread，子线程的名字在创建时指定，我们用</span></span><br><span class="line"><span class="string">LoopThread命名子线程。名字仅仅在打印时用来显示，完全没有其他意义，如果不起</span></span><br><span class="line"><span class="string">名字Python就自动给线程命名为Thread-1，Thread-2……</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Lock</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">多线程和多进程最大的不同在于，多进程中，同一个变量，各自有一份拷贝存在于每</span></span><br><span class="line"><span class="string">个进程中，互不影响，而多线程中，所有变量都由所有线程共享，所以，任何一个变</span></span><br><span class="line"><span class="string">量都可以被任何一个线程修改，因此，线程之间共享数据最大的危险在于多个线程同</span></span><br><span class="line"><span class="string">时改一个变量，把内容给改乱了。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 来看看多个线程同时操作一个变量怎么把内容给改乱了</span></span><br><span class="line"><span class="keyword">import</span> time, threading</span><br><span class="line"></span><br><span class="line"><span class="comment"># 假定这是你的银行存款:</span></span><br><span class="line">balance = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">change_it</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="comment"># 先存后取，结果应该为0:</span></span><br><span class="line">    <span class="keyword">global</span> balance</span><br><span class="line">    balance = balance + n</span><br><span class="line">    balance = balance - n</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run_thread</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2000000</span>):</span><br><span class="line">        change_it(n)</span><br><span class="line"></span><br><span class="line">t1 = threading.Thread(target=run_thread, args=(<span class="number">5</span>,))</span><br><span class="line">t2 = threading.Thread(target=run_thread, args=(<span class="number">8</span>,))</span><br><span class="line">t1.start()</span><br><span class="line">t2.start()</span><br><span class="line">t1.join()</span><br><span class="line">t2.join()</span><br><span class="line"><span class="built_in">print</span>(balance)</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">我们定义了一个共享变量balance，初始值为0，并且启动两个线程，先存后取，理论</span></span><br><span class="line"><span class="string">上结果应该为0，但是，由于线程的调度是由操作系统决定的，当t1、t2交替执行时，</span></span><br><span class="line"><span class="string">只要循环次数足够多，balance的结果就不一定是0了。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">原因是因为高级语言的一条语句在CPU执行时是若干条语句，即使一个简单的计算：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">balance = balance + n</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">也分两步：</span></span><br><span class="line"><span class="string">1. 计算balance + n，存入临时变量中；</span></span><br><span class="line"><span class="string">2. 将临时变量的值赋给balance。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">也就是可以看成：</span></span><br><span class="line"><span class="string">x = balance + n</span></span><br><span class="line"><span class="string">balance = x</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">由于x是局部变量，两个线程各自都有自己的x，当代码正常执行时：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">初始值 balance = 0</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">t1: x1 = balance + 5 # x1 = 0 + 5 = 5</span></span><br><span class="line"><span class="string">t1: balance = x1     # balance = 5</span></span><br><span class="line"><span class="string">t1: x1 = balance - 5 # x1 = 5 - 5 = 0</span></span><br><span class="line"><span class="string">t1: balance = x1     # balance = 0</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">t2: x2 = balance + 8 # x2 = 0 + 8 = 8</span></span><br><span class="line"><span class="string">t2: balance = x2     # balance = 8</span></span><br><span class="line"><span class="string">t2: x2 = balance - 8 # x2 = 8 - 8 = 0</span></span><br><span class="line"><span class="string">t2: balance = x2     # balance = 0</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">结果 balance = 0</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">但是t1和t2是交替运行的，如果操作系统以下面的顺序执行t1、t2：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">初始值 balance = 0</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">t1: x1 = balance + 5  # x1 = 0 + 5 = 5</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">t2: x2 = balance + 8  # x2 = 0 + 8 = 8</span></span><br><span class="line"><span class="string">t2: balance = x2      # balance = 8</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">t1: balance = x1      # balance = 5</span></span><br><span class="line"><span class="string">t1: x1 = balance - 5  # x1 = 5 - 5 = 0</span></span><br><span class="line"><span class="string">t1: balance = x1      # balance = 0</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">t2: x2 = balance - 8  # x2 = 0 - 8 = -8</span></span><br><span class="line"><span class="string">t2: balance = x2      # balance = -8</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">结果 balance = -8</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">究其原因，是因为修改balance需要多条语句，而执行这几条语句时，线程可能中断，</span></span><br><span class="line"><span class="string">从而导致多个线程把同一个对象的内容改乱了。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">两个线程同时一存一取，就可能导致余额不对，你肯定不希望你的银行存款莫名其妙</span></span><br><span class="line"><span class="string">地变成了负数，所以，我们必须确保一个线程在修改balance的时候，别的线程一定不</span></span><br><span class="line"><span class="string">能改。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 上锁</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">如果我们要确保balance计算正确，就要给change_it()上一把锁，当某个线程开始执</span></span><br><span class="line"><span class="string">行change_it()时，我们说，该线程因为获得了锁，因此其他线程不能同时执行</span></span><br><span class="line"><span class="string">change_it()，只能等待，直到锁被释放后，获得该锁以后才能改。由于锁只有一</span></span><br><span class="line"><span class="string">个，无论多少线程，同一时刻最多只有一个线程持有该锁，所以，不会造成修改的冲</span></span><br><span class="line"><span class="string">突。创建一个锁就是通过threading.Lock()来实现：</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">balance = <span class="number">0</span></span><br><span class="line">lock = threading.Lock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run_thread</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100000</span>):</span><br><span class="line">        <span class="comment"># 先要获取锁:</span></span><br><span class="line">        lock.acquire()</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="comment"># 放心地改吧:</span></span><br><span class="line">            change_it(n)</span><br><span class="line">        <span class="keyword">finally</span>:</span><br><span class="line">            <span class="comment"># 改完了一定要释放锁:</span></span><br><span class="line">            lock.release()</span><br><span class="line">            </span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">当多个线程同时执行lock.acquire()时，只有一个线程能成功地获取锁，然后继续执</span></span><br><span class="line"><span class="string">行代码，其他线程就继续等待直到获得锁为止。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">获得锁的线程用完后一定要释放锁，否则那些苦苦等待锁的线程将永远等待下去，成</span></span><br><span class="line"><span class="string">为死线程。所以我们用try...finally来确保锁一定会被释放。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">锁的好处就是确保了某段关键代码只能由一个线程从头到尾完整地执行，坏处当然也</span></span><br><span class="line"><span class="string">很多，首先是阻止了多线程并发执行，包含锁的某段代码实际上只能以单线程模式执</span></span><br><span class="line"><span class="string">行，效率就大大地下降了。其次，由于可以存在多个锁，不同的线程持有不同的锁，</span></span><br><span class="line"><span class="string">并试图获取对方持有的锁时，可能会造成死锁，导致多个线程全部挂起，既不能执</span></span><br><span class="line"><span class="string">行，也无法结束，只能靠操作系统强制终止。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 多核CPU</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">如果你不幸拥有一个多核CPU，你肯定在想，多核应该可以同时执行多个线程。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">如果写一个死循环的话，会出现什么情况呢？</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">打开Mac OS X的Activity Monitor，或者Windows的Task Manager，都可以监控某</span></span><br><span class="line"><span class="string">个进程的CPU使用率。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">我们可以监控到一个死循环线程会100%占用一个CPU。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">如果有两个死循环线程，在多核CPU中，可以监控到会占用200%的CPU，也就是占用两</span></span><br><span class="line"><span class="string">个CPU核心。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">要想把N核CPU的核心全部跑满，就必须启动N个死循环线程。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">试试用Python写个死循环：</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">import</span> threading, multiprocessing</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">loop</span>():</span><br><span class="line">    x = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        x = x ^ <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(multiprocessing.cpu_count()):</span><br><span class="line">    t = threading.Thread(target=loop)</span><br><span class="line">    t.start()</span><br><span class="line">    </span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">启动与CPU核心数量相同的N个线程，在4核CPU上可以监控到CPU占用率仅有102%，也</span></span><br><span class="line"><span class="string">就是仅使用了一核。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">但是用C、C++或Java来改写相同的死循环，直接可以把全部核心跑满，4核就跑到</span></span><br><span class="line"><span class="string">400%，8核就跑到800%，为什么Python不行呢？</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">因为Python的线程虽然是真正的线程，但解释器执行代码时，有一个GIL锁：Global </span></span><br><span class="line"><span class="string">Interpreter Lock，任何Python线程执行前，必须先获得GIL锁，然后，每执行100</span></span><br><span class="line"><span class="string">条字节码，解释器就自动释放GIL锁，让别的线程有机会执行。这个GIL全局锁实际上</span></span><br><span class="line"><span class="string">把所有线程的执行代码都给上了锁，所以，多线程在Python中只能交替执行，即使</span></span><br><span class="line"><span class="string">100个线程跑在100核CPU上，也只能用到1个核。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">GIL是Python解释器设计的历史遗留问题，通常我们用的解释器是官方实现的</span></span><br><span class="line"><span class="string">CPython，要真正利用多核，除非重写一个不带GIL的解释器。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">所以，在Python中，可以使用多线程，但不要指望能有效利用多核。如果一定要通过</span></span><br><span class="line"><span class="string">多线程利用多核，那只能通过C扩展来实现，不过这样就失去了Python简单易用的特</span></span><br><span class="line"><span class="string">点。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">不过，也不用过于担心，Python虽然不能利用多线程实现多核任务，但可以通过多进</span></span><br><span class="line"><span class="string">程实现多核任务。多个Python进程有各自独立的GIL锁，互不影响。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">小结</span></span><br><span class="line"><span class="string">多线程编程，模型复杂，容易发生冲突，必须用锁加以隔离，同时，又要小心死锁的</span></span><br><span class="line"><span class="string">发生。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Python解释器由于设计时有GIL全局锁，导致了多线程无法利用多核。多线程的并发</span></span><br><span class="line"><span class="string">在Python中就是一个美丽的梦。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 多线程+UDP实现p2p聊天</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">目前采用udp发送数据，各个用户p2p对等聊天，不经过服务器转发</span></span><br><span class="line"><span class="string">实现与指定对象发起聊天，接收任意对象的消息</span></span><br><span class="line"><span class="string">在本地保存与各个对象的聊天记录</span></span><br><span class="line"><span class="string">该客户端修改本地绑定地址与文件保存地址后可复用</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">addr_split</span>(<span class="params">addr: <span class="built_in">str</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;将输入的地址字符串解析为IP地址和端口号&quot;&quot;&quot;</span></span><br><span class="line">    ip, port = addr.rsplit(<span class="string">&#x27;,&#x27;</span>, maxsplit=<span class="number">1</span>)</span><br><span class="line">    <span class="comment"># ip是字符串，端口号是整数，返回它俩的元组</span></span><br><span class="line">    <span class="keyword">return</span> ip, <span class="built_in">int</span>(port)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">rec_msg</span>(<span class="params">sk, save_path</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;循环监听，接收消息&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        data, addr = sk.recvfrom(<span class="number">1024</span>)</span><br><span class="line">        utf8_data = data.decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;来自&#123;0&#125;：\n&#123;1&#125;&#x27;</span>.<span class="built_in">format</span>(addr, utf8_data))</span><br><span class="line">        filename = <span class="string">&quot;(&#123;0&#125;_&#123;1&#125;).txt&quot;</span>.<span class="built_in">format</span>(addr[<span class="number">0</span>], addr[<span class="number">1</span>])</span><br><span class="line">        <span class="comment"># 写入我收到的内容至与对应发送者的聊天记录</span></span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(save_path + filename, <span class="string">&#x27;a&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            <span class="comment"># 获取当前时间的字符串，只精确到秒</span></span><br><span class="line">            t_now = <span class="built_in">str</span>(datetime.now()).rsplit(<span class="string">&#x27;.&#x27;</span>, maxsplit=<span class="number">1</span>)[<span class="number">0</span>]</span><br><span class="line">            <span class="comment"># 写入发送时间+发送者地址+内容</span></span><br><span class="line">            f.write(<span class="string">f&#x27;<span class="subst">&#123;t_now&#125;</span> from [<span class="subst">&#123;addr[<span class="number">0</span>]&#125;</span>:<span class="subst">&#123;addr[<span class="number">1</span>]&#125;</span>]\n&#x27;</span> + utf8_data + <span class="string">&#x27;\n\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">send_msg</span>(<span class="params">sk, ip_port, target_addr, save_path</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;发送消息到目标对象&quot;&quot;&quot;</span></span><br><span class="line">    filename = <span class="string">&quot;(&#123;0&#125;_&#123;1&#125;).txt&quot;</span>.<span class="built_in">format</span>(target_addr[<span class="number">0</span>], target_addr[<span class="number">1</span>])</span><br><span class="line">    <span class="comment"># 写入我发送的内容到与对应接收者的聊天记录</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(save_path + filename, <span class="string">&#x27;a&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="comment"># 循环发送消息</span></span><br><span class="line">            msg = <span class="built_in">input</span>(<span class="string">&#x27;发送消息：\n&#x27;</span>)</span><br><span class="line">            <span class="keyword">if</span> msg == <span class="string">&#x27;q&#x27;</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;结束聊天&#x27;</span>)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            t_now = <span class="built_in">str</span>(datetime.now()).rsplit(<span class="string">&#x27;.&#x27;</span>, maxsplit=<span class="number">1</span>)[<span class="number">0</span>]</span><br><span class="line">            f.write(<span class="string">f&#x27;<span class="subst">&#123;t_now&#125;</span> from [<span class="subst">&#123;ip_port[<span class="number">0</span>]&#125;</span>:<span class="subst">&#123;ip_port[<span class="number">1</span>]&#125;</span>]\n&#x27;</span> + msg + <span class="string">&#x27;\n\n&#x27;</span>)</span><br><span class="line">            <span class="comment"># 用flush刷新缓存</span></span><br><span class="line">            f.flush()</span><br><span class="line">            <span class="comment"># 也可以用print语句输出到指定文件，参数flush置为True刷新缓存</span></span><br><span class="line">            <span class="comment"># print(f&#x27;&#123;t_now&#125; from [&#123;local_ip_port[0]&#125;:&#123;local_ip_port[1]&#125;]\n&#x27; + msg + &#x27;\n\n&#x27;, file=f, flush=True)</span></span><br><span class="line">            <span class="comment"># 发送内容到到目标地址</span></span><br><span class="line">            sk.sendto(msg.encode(<span class="string">&#x27;utf-8&#x27;</span>), target_addr)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">chat</span>(<span class="params">local_addr=<span class="string">&#x27;192.168.3.7,9070&#x27;</span>, save_path=<span class="string">r&#x27;chat_record/&#x27;</span></span>):</span><br><span class="line">    <span class="comment"># 解析ip与端口号</span></span><br><span class="line">    ip_port = addr_split(local_addr)</span><br><span class="line">    target_addr = addr_split(<span class="built_in">input</span>(<span class="string">&quot;请输入好友地址，如 192.168.3.7,9080 ：&quot;</span>))</span><br><span class="line">    <span class="keyword">with</span> socket.socket(socket.AF_INET, socket.SOCK_DGRAM) <span class="keyword">as</span> sk:</span><br><span class="line">        sk.bind(ip_port)</span><br><span class="line">        <span class="comment"># 创建接收信息与发送信息两个子线程</span></span><br><span class="line">        t_rec = threading.Thread(target=rec_msg, args=(sk, save_path))</span><br><span class="line">        t_rec.start()</span><br><span class="line">        t_send = threading.Thread(target=send_msg, args=(sk, ip_port, target_addr, save_path))</span><br><span class="line">        t_send.start()</span><br><span class="line">        <span class="comment"># join方法在子线程结束后才能执行</span></span><br><span class="line">        <span class="comment"># 若不加join方法，执行完上述代码会跳出with语句执行函数剩余代码</span></span><br><span class="line">        <span class="comment"># 导致子线程的内容还没执行完就被with自动关闭了socket</span></span><br><span class="line">        t_rec.join()</span><br><span class="line">        t_send.join()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    chat()</span><br></pre></td></tr></table></figure>



<br/>



<h5 id="【3】ThreadLocal"><a href="#【3】ThreadLocal" class="headerlink" title="【3】ThreadLocal"></a>【3】ThreadLocal</h5><p>在多线程环境下，每个线程都有自己的数据。一个线程使用自己的局部变量比使用全局变量好，因为局部变量只有线程自己能看见，不会影响其他线程，而全局变量的修改必须加锁。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 但是局部变量也有问题，就是在函数调用的时候，传递起来很麻烦。</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">process_student</span>(<span class="params">name</span>):</span><br><span class="line">    std = Student(name)</span><br><span class="line">    <span class="comment"># std是局部变量，但是每个函数都要用它，因此必须传进去</span></span><br><span class="line">    do_task_1(std)</span><br><span class="line">    do_task_2(std)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">do_task_1</span>(<span class="params">std</span>):</span><br><span class="line">    do_subtask_1(std)</span><br><span class="line">    do_subtask_2(std)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">do_task_2</span>(<span class="params">std</span>):</span><br><span class="line">    do_subtask_2(std)</span><br><span class="line">    do_subtask_2(std)</span><br><span class="line">    </span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">每个函数一层一层调用都这么传参还得了，用全局变量也不行，因为每个线程处理不同的Student对象，</span></span><br><span class="line"><span class="string">不能共享。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">如果用一个全局dict存放所有的Student对象，然后以thread自身作为key获得线程对应的Student对</span></span><br><span class="line"><span class="string">象如何？</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">global_dict = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">std_thread</span>(<span class="params">name</span>):</span><br><span class="line">    std = Student(name)</span><br><span class="line">    <span class="comment"># 把std放到全局变量global_dict中</span></span><br><span class="line">    global_dict[threading.current_thread()] = std</span><br><span class="line">    do_task_1()</span><br><span class="line">    do_task_2()</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">do_task_1</span>():</span><br><span class="line">    <span class="comment"># 不传入std，而是根据当前线程查找</span></span><br><span class="line">    std = golbal_dict[threading.current_thread()]</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">do_task_2</span>():</span><br><span class="line">    <span class="comment"># 任何函数都可以查找出当前线程的std变量</span></span><br><span class="line">    std = global_dict[threading.current_thread()]</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">上面这种方法理论上是可行的，它最大的优点是消除了std对象在每层函数中的传递问题，但是，每个函</span></span><br><span class="line"><span class="string">数获取std的代码有点丑。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span>    </span><br><span class="line"></span><br><span class="line"><span class="comment"># ThreadLocal应运而生，不用查找dict，ThreadLocal帮你自动做这件事。</span></span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;创建全局ThreadLocal对象&quot;&quot;&quot;</span></span><br><span class="line">local_school = threading.local()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">process_student</span>():</span><br><span class="line">    <span class="comment"># 获取当前线程关联的student</span></span><br><span class="line">    std = local_school.student</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello, %s (in %s)&quot;</span> % (std, threading.current_thread().name))</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">process_thread</span>(<span class="params">name</span>):</span><br><span class="line">    <span class="comment"># 绑定ThreadLocal的student</span></span><br><span class="line">    local_school.student = name</span><br><span class="line">	process_student()    </span><br><span class="line"></span><br><span class="line">t1 = threading.Thread(target = process_thread, args = (<span class="string">&quot;Alice&quot;</span>,), name = <span class="string">&quot;Thread-A&quot;</span>)</span><br><span class="line">t2 = threading.Thread(target = process_thread, args = (<span class="string">&quot;Bob&quot;</span>,), name = <span class="string">&quot;Thread-A&quot;</span>)</span><br><span class="line">t1.start()</span><br><span class="line">t2.start()</span><br><span class="line">t1.join()</span><br><span class="line">t2.join()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行结果</span></span><br><span class="line">Hello, Alice (<span class="keyword">in</span> Thread-A)</span><br><span class="line">Hello, Bob (<span class="keyword">in</span> Thread-B)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">全局变量 local_school 就是一个 ThreadLocal 对象，每个 Thread 对它都可以读写 student </span></span><br><span class="line"><span class="string">属性，但互不影响。你可以把 local_school 看成全局变量，但每个属性如 local_school.student</span></span><br><span class="line"><span class="string">都是线程的局部变量，可以任意读写而互不干扰，也不用管理锁的问题，ThreadLocal内部会处理。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">可以理解为全局变量local_school是一个dict，不但可以用 local_school.student，还可以绑定</span></span><br><span class="line"><span class="string">其他变量，如local_school.teacher等等。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">ThreadLocal最常用的地方就是为每个线程绑定一个数据库连接，Http请求，用户身份信息等，这样一</span></span><br><span class="line"><span class="string">个线程的所有调用到的处理函数都可以非常方便地访问这些资源。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 小结</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">一个ThreadLocal变量虽然是全局变量，但每个线程都只能读写自己线程的独立副本，互不干扰。</span></span><br><span class="line"><span class="string">ThreadLocal解决了参数在一个线程中各个函数之间互相传递的问题。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>



<br/>



<h5 id="【4】进程VS线程"><a href="#【4】进程VS线程" class="headerlink" title="【4】进程VS线程"></a>【4】进程VS线程</h5><p>首先，要实现多任务，通常我们会设计Master-Worker模式，Master负责分配任务，Worker负责执行任务，因此，多任务环境下，通常是一个Master，多个Worker。</p>
<p>如果用多进程实现Master-Worker，主进程就是Master，其他进程就是Worker。</p>
<p>如果用多线程实现Master-Worker，主线程就是Master，其他线程就是Worker。</p>
<p>多进程模式最大的优点就是稳定性高，因为一个子进程崩溃了，不会影响主进程和其他子进程。（当然主进程挂了所有进程就全挂了，但是Master进程只负责分配任务，挂掉的概率低）著名的Apache最早就是采用多进程模式。</p>
<p>多进程模式的缺点是创建进程的代价大，在Unix/Linux系统下，用fork调用还行，在Windows下创建进程开销巨大。另外，操作系统能同时运行的进程数也是有限的，在内存和CPU的限制下，如果有几千个进程同时运行，操作系统连调度都会成问题。</p>
<p>多线程模式通常比多进程快一点，但是也快不到哪去，而且，多线程模式致命的缺点就是任何一个线程挂掉都可能造成整个进程崩溃，因为所有线程共享进程的内存。在Windows上，如果一个线程执行的代码出了问题，你经常可以看到这样的提示：”该程序执行了非法操作，即将关闭”，其实往往是某个线程出了问题，但是操作系统会强制结束整个进程。</p>
<p>在Windows下，多线程的效率比多进程要高，所以微软的IIS服务器默认采用多线程模式。由于多线程存在稳定性的问题，IIS的稳定性就不如Apache。为了缓解这个问题，IIS和Apache现在又有了多进程+多线程的混合模式，问题越来越复杂了。</p>
<br/>



<p><strong>线程切换</strong></p>
<p>无论是多进程还是多线程，只要数量一多，效率肯定上不去，为什么？</p>
<p>我们打个比方，假设你正在准备中考，每天要做语文、数学、英语、物理、化学这5门作业，每项作业耗时1小时。</p>
<p>如果你先花1小时做语文作业，做完了，再花1小时做数学作业，这样依次全部做完，一共花5小时，这种方式称为单任务模型，或者批处理任务模型。</p>
<p>假如你打算切换到多任务模型，可以先做1分钟语文，再切换到数学作业，做1分钟，再切换到英语，以此类推，只要切换速度足够快，这种方式就和单核CPU执行多任务是一样了。</p>
<p>但是切换作业是有代价的，比如从语文切换到数学，要先收拾桌子上的文具（这叫保存现场），然后，打开数学课本、找出圆规直尺（这叫准备新环境），才能开始做数学作业。操作系统在切换进程或者线程时也是一样，它需要先保存当前执行的现场环境（CPU寄存器状态、内存页等），然后把新任务的执行环境准备好（恢复上次的寄存器状态，切换内存页等），才能开始执行。这个切换过程虽然快，但是也需要耗费时间。如果有几千个任务同时执行，操作系统可能就主要忙着切换任务，根本没有多少时间去执行任务了，这种情况最常见的就是硬盘狂响，点窗口无反应，系统处于假死状态。</p>
<p>所以，多任务一旦多到一个限度，就会消耗掉系统所有的资源，结果效率急剧下降，所有任务都做不好。</p>
<br/>



<p><strong>计算密集型和IO密集型</strong></p>
<p>是否采用多任务的第二个考虑是任务的类型，我们可以把任务分为计算密集型和IO密集型。</p>
<p>计算密集型任务的特点是要进行大量的计算，消耗CPU资源，比如计算圆周率、对视频进行高清解码等等，全靠CPU的运算能力。这种计算密集型任务虽然也可以用多任务完成，但是任务越多，花在任务切换的时间就越多，CPU执行任务的效率就越低，所以，要最高效地利用CPU，计算密集型任务同时进行的数量应当等于CPU的核心数。</p>
<p>计算密集型任务由于主要消耗CPU资源，因此，代码运行效率至关重要。Python这样的脚本语言运行效率很低，完全不适合计算密集型任务。对于计算密集型任务，最好用C语言写。</p>
<p>第二种任务的类型是IO密集型，涉及到网络、磁盘IO的任务都是IO密集型任务，这类任务的特点是CPU消耗很少，任务的大部分时间都在等待IO操作完成（因为IO的速度远远低于CPU和内存的速度）。对于IO密集型任务，任务越多，CPU效率越高，但也有一个限度。常见的大部分任务都是IO密集型任务，比如Web应用。</p>
<p>IO密集型任务执行期间，99%的时间都花在IO上，花在CPU上的时间很少，因此，用运行速度极快的C语言替换用Python这样运行速度极低的脚本语言，完全无法提升运行效率。对于IO密集型任务，最合适的语言就是开发效率高（代码量最少）的语言，脚本语言是首选，C语言最差。</p>
<br/>



<p><strong>异步IO</strong></p>
<p>考虑到CPU和IO之间巨大的速度差异，一个任务在执行的过程中大部分时间都在等待IO操作，单进程单线程模型会导致别的任务无法并行执行，因此，我们才需要多进程模型或者多线程来支持多任务并发执行。</p>
<p>现代操作系统对IO模型已经做了巨大的改进，最大的特点就是支持异步IO。如果充分利用操作系统提供的异步IO支持，就可以用单进程单线程模型来执行多任务，这种全新的模型称为事件驱动模型，Nginx就是支持异步IO的Web服务器，他在单核CPU上采用单进程模型就可以高效地支持多任务。在多核CPU上，可以运行多个进程（数量与CPU核心数相同），充分利用多核CPU。由于系统总的进程数量十分有限，因此操作系统调度非常高效。用异步IO模型来实现多任务是一个主要的趋势。</p>
<p>对应到Python语言，单线程的异步编程模型称为协程，有了协程的支持，就可以基于事件驱动编写高效的多任务程序。我们会在后面讨论如何编写协程。</p>
<br/>



<h5 id="【5】分布式进程"><a href="#【5】分布式进程" class="headerlink" title="【5】分布式进程"></a>【5】分布式进程</h5><p>在Thread和Process中，应当优选Process，因为Process更稳定，而且，Process可以分布到多台机器上，而Thread最多只能分布到同一台机器的多个CPU上。</p>
<p>Python的multiprocessing模块不但支持多进程，其中managers子模块还支持把多进程分布到多台机器上。一个服务进程可以作为调度者，将任务分布到其他多个进程中，依靠网络通信。由于managers模块封装很好，不必了解网络通信的细节，就可以很容易编写分布式多进程程序。</p>
<p>举个例子：如果我们已经有一个通过Queue通信的多进程程序在同一台机器上运行，现在，由于处理任务的进程任务繁重，希望把发送任务的进程和处理任务的进程分布到两台机器上。怎么用分布式进程实现？</p>
<p>原有的Queue可以继续使用，但是，通过managers模块把Queue通过网络暴露出去，就可以让其他机器的进程访问Queue了。</p>
<p>我们先看服务进程，服务进程负责启动Queue，把Queue注册到网络上，然后往Queue里面写入任务：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># task_master.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> random, time, queue</span><br><span class="line"><span class="keyword">from</span> multiprocessing.managers <span class="keyword">import</span> BaseManager</span><br><span class="line"></span><br><span class="line"><span class="comment"># 发送任务的队列:</span></span><br><span class="line">task_queue = queue.Queue()</span><br><span class="line"><span class="comment"># 接收结果的队列:</span></span><br><span class="line">result_queue = queue.Queue()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从BaseManager继承的QueueManager:</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">QueueManager</span>(<span class="title class_ inherited__">BaseManager</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">r_task_queue</span>():</span><br><span class="line">    <span class="keyword">return</span> task_queue</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">r_result_queue</span>():</span><br><span class="line">    <span class="keyword">return</span> result_queue</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 把两个Queue都注册到网络上, callable参数关联了Queue对象:</span></span><br><span class="line">    QueueManager.register(<span class="string">&#x27;get_task_queue&#x27;</span>, <span class="built_in">callable</span>=r_task_queue)</span><br><span class="line">    QueueManager.register(<span class="string">&#x27;get_result_queue&#x27;</span>, <span class="built_in">callable</span>=r_result_queue)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 绑定端口5000, 设置验证码&#x27;abc&#x27;:</span></span><br><span class="line">    manager = QueueManager(address=(<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">6000</span>), authkey=<span class="string">b&#x27;abc&#x27;</span>)</span><br><span class="line">    <span class="comment"># 启动Queue:</span></span><br><span class="line">    manager.start()</span><br><span class="line">    <span class="comment"># 获得通过网络访问的Queue对象:</span></span><br><span class="line">    task = manager.get_task_queue()</span><br><span class="line">    result = manager.get_result_queue()</span><br><span class="line">    <span class="comment"># 放几个任务进去:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        n = random.randint(<span class="number">0</span>, <span class="number">10000</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Put task %d...&#x27;</span> % n)</span><br><span class="line">        task.put(n)</span><br><span class="line">    <span class="comment"># 从result队列读取结果:</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Try get results...&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">        	r = result.get(timeout=<span class="number">10</span>)</span><br><span class="line">        	<span class="built_in">print</span>(<span class="string">&#x27;Result: %s&#x27;</span> % r)</span><br><span class="line">        <span class="keyword">except</span> queue.Empty:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;The queue is empty...&#x27;</span>)</span><br><span class="line">    <span class="comment"># 关闭:</span></span><br><span class="line">    manager.shutdown()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;master exit.&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">请注意，当我们在一台机器上写多进程程序时，创建的Queue可以直接拿来用，但是，在分布式多进程环</span></span><br><span class="line"><span class="string">境下，添加任务到Queue不可以直接对原始的task_queue进行操作，那样就绕过了QueueManager的封</span></span><br><span class="line"><span class="string">装，必须通过manager.get_task_queue()获得的Queue接口添加。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 然后在另外一台机器上启动任务进程（本机上启动也可以）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># task_worker.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> time, sys, queue</span><br><span class="line"><span class="keyword">from</span> multiprocessing.managers <span class="keyword">import</span> BaseManager</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建类似的QueueManager:</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">QueueManager</span>(<span class="title class_ inherited__">BaseManager</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment"># 由于这个QueueManager只从网络上获取Queue，所以注册时只提供名字:</span></span><br><span class="line">    QueueManager.register(<span class="string">&#x27;get_task_queue&#x27;</span>)</span><br><span class="line">    QueueManager.register(<span class="string">&#x27;get_result_queue&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 连接到服务器，也就是运行task_master.py的机器:</span></span><br><span class="line">    server_addr = <span class="string">&#x27;127.0.0.1&#x27;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Connect to server %s...&#x27;</span> % server_addr)</span><br><span class="line">    <span class="comment"># 端口和验证码注意保持与task_master.py设置的完全一致:</span></span><br><span class="line">    m = QueueManager(address=(server_addr, <span class="number">6000</span>), authkey=<span class="string">b&#x27;abc&#x27;</span>)</span><br><span class="line">    <span class="comment"># 从网络连接:</span></span><br><span class="line">    m.connect()</span><br><span class="line">    <span class="comment"># 获取Queue的对象:</span></span><br><span class="line">    task = m.get_task_queue()</span><br><span class="line">    result = m.get_result_queue()</span><br><span class="line">    <span class="comment"># 从task队列取任务,并把结果写入result队列:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            n = task.get(timeout=<span class="number">1</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;run task %d * %d...&#x27;</span> % (n, n))</span><br><span class="line">            r = <span class="string">&#x27;%d * %d = %d&#x27;</span> % (n, n, n*n)</span><br><span class="line">            time.sleep(<span class="number">1</span>)</span><br><span class="line">            result.put(r)</span><br><span class="line">        <span class="keyword">except</span> queue.Empty:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;task queue is empty.&#x27;</span>)</span><br><span class="line">    <span class="comment"># 处理结束:</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;worker exit.&#x27;</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 现在可以试试分布式进程的工作效果了，先启动 task_master.py服务进程</span></span><br><span class="line">$ python3 task_master.py</span><br><span class="line">Put task <span class="number">6783.</span>..</span><br><span class="line">Put task <span class="number">4474.</span>..</span><br><span class="line">Put task <span class="number">6776.</span>..</span><br><span class="line">Put task <span class="number">5939.</span>..</span><br><span class="line">Put task <span class="number">9098.</span>..</span><br><span class="line">Put task <span class="number">9871.</span>..</span><br><span class="line">Put task <span class="number">6989.</span>..</span><br><span class="line">Put task <span class="number">8487.</span>..</span><br><span class="line">Put task <span class="number">3779.</span>..</span><br><span class="line">Put task <span class="number">6367.</span>..</span><br><span class="line">Try get results...</span><br><span class="line">Result: <span class="number">6783</span> * <span class="number">6783</span> = <span class="number">46009089</span></span><br><span class="line">Result: <span class="number">4474</span> * <span class="number">4474</span> = <span class="number">20016676</span></span><br><span class="line">Result: <span class="number">6776</span> * <span class="number">6776</span> = <span class="number">45914176</span></span><br><span class="line">Result: <span class="number">5939</span> * <span class="number">5939</span> = <span class="number">35271721</span></span><br><span class="line">Result: <span class="number">9098</span> * <span class="number">9098</span> = <span class="number">82773604</span></span><br><span class="line">Result: <span class="number">9871</span> * <span class="number">9871</span> = <span class="number">97436641</span></span><br><span class="line">Result: <span class="number">6989</span> * <span class="number">6989</span> = <span class="number">48846121</span></span><br><span class="line">Result: <span class="number">8487</span> * <span class="number">8487</span> = <span class="number">72029169</span></span><br><span class="line">Result: <span class="number">3779</span> * <span class="number">3779</span> = <span class="number">14280841</span></span><br><span class="line">Result: <span class="number">6367</span> * <span class="number">6367</span> = <span class="number">40538689</span></span><br><span class="line">master exit.</span><br><span class="line"></span><br><span class="line">$ python3 task_worker.py</span><br><span class="line">Connect to server <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>...</span><br><span class="line">run task <span class="number">6783</span> * <span class="number">6783.</span>..</span><br><span class="line">run task <span class="number">4474</span> * <span class="number">4474.</span>..</span><br><span class="line">run task <span class="number">6776</span> * <span class="number">6776.</span>..</span><br><span class="line">run task <span class="number">5939</span> * <span class="number">5939.</span>..</span><br><span class="line">run task <span class="number">9098</span> * <span class="number">9098.</span>..</span><br><span class="line">run task <span class="number">9871</span> * <span class="number">9871.</span>..</span><br><span class="line">run task <span class="number">6989</span> * <span class="number">6989.</span>..</span><br><span class="line">run task <span class="number">8487</span> * <span class="number">8487.</span>..</span><br><span class="line">run task <span class="number">3779</span> * <span class="number">3779.</span>..</span><br><span class="line">run task <span class="number">6367</span> * <span class="number">6367.</span>..</span><br><span class="line">worker exit.</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这个简单的Master/Worker模型有什么作用？</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">其实这就是一个简单但真正的分布式计算，把代码稍加改造，启动多个worker，就可以把任务分布到几</span></span><br><span class="line"><span class="string">台甚至几十台机器上，比如把计算n*n的代码换成发送邮件，就实现了邮件队列的异步发送。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Queue对象存储在哪？注意到task_worker.py中根本没有创建Queue到代码，所以，Queue对象存</span></span><br><span class="line"><span class="comment"># 储在task_master.py进程中</span></span><br><span class="line"></span><br><span class="line">                                             │</span><br><span class="line">┌─────────────────────────────────────────┐     ┌──────────────────────────────────────┐</span><br><span class="line">│task_master.py                           │  │  │task_worker.py                        │</span><br><span class="line">│                                         │     │                                      │</span><br><span class="line">│  task = manager.get_task_queue()        │  │  │  task = manager.get_task_queue()     │</span><br><span class="line">│  result = manager.get_result_queue()    │     │  result = manager.get_result_queue() │</span><br><span class="line">│              │                          │  │  │              │                       │</span><br><span class="line">│              │                          │     │              │                       │</span><br><span class="line">│              ▼                          │  │  │              │                       │</span><br><span class="line">│  ┌─────────────────────────────────┐    │     │              │                       │</span><br><span class="line">│  │QueueManager                     │    │  │  │              │                       │</span><br><span class="line">│  │ ┌────────────┐ ┌──────────────┐ │    │     │              │                       │</span><br><span class="line">│  │ │ task_queue │ │ result_queue │ │&lt;───┼──┼──┼──────────────┘                       │</span><br><span class="line">│  │ └────────────┘ └──────────────┘ │    │     │                                      │</span><br><span class="line">│  └─────────────────────────────────┘    │  │  │                                      │</span><br><span class="line">└─────────────────────────────────────────┘     └──────────────────────────────────────┘</span><br><span class="line">                                             │</span><br><span class="line"></span><br><span class="line">                                          Network</span><br></pre></td></tr></table></figure>



<p>而<code>Queue</code>之所以能通过网络访问，就是通过<code>QueueManager</code>实现的。由于<code>QueueManager</code>管理的不止一个<code>Queue</code>，所以，要给每个<code>Queue</code>的网络调用接口起个名字，比如<code>get_task_queue</code>。</p>
<p><code>authkey</code>有什么用？这是为了保证两台机器正常通信，不被其他机器恶意干扰。如果<code>task_worker.py</code>的<code>authkey</code>和<code>task_master.py</code>的<code>authkey</code>不一致，肯定连接不上。</p>
<br/>



<h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>Python的分布式进程接口简单，封装良好，适合需要把繁重任务分布到多台机器的环境下。</p>
<p>注意Queue的作用是用来传递任务和接收结果，每个任务的描述数据量要尽量小。比如发送一个处理日志文件的任务，就不要发送几百兆的日志文件本身，而是发送日志文件存放的完整路径，由Worker进程再去共享的磁盘上读取文件。</p>
<br/>



<h2 id="11、异步IO"><a href="#11、异步IO" class="headerlink" title="11、异步IO"></a>11、异步IO</h2><p>多线程和多进程只是解决CPU高速执行能力和IO设备的龟速不匹配的一种方法，但是系统并不能无上限地增加线程。</p>
<p>另一种解决IO问题的方法是异步IO，当代码需要执行一个耗时的IO操作时，它只发出IO指令，并不等待IO结果，然后就去执行其他代码了。一段时间后，当IO返回结果时，再通知CPU进行处理。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">do_some_code()</span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&#x27;/path/to/file&#x27;</span>, <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">r = f.read() <span class="comment"># &lt;== 线程停在此处等待IO操作结果</span></span><br><span class="line"><span class="comment"># IO操作完成后线程才能继续执行:</span></span><br><span class="line">do_some_code(r)</span><br></pre></td></tr></table></figure>

<p>所以，同步IO模型的代码是无法实现异步IO模型的。</p>
<p>异步IO模型需要一个消息循环，在消息循环中，主线程不断地重复”读取消息-处理消息”这个过程。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">loop = get_event_loop()</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    event = loop.get_event()</span><br><span class="line">    process_event(event)</span><br></pre></td></tr></table></figure>

<p>对于大多数IO密集型应用程序，使用异步IO将大大提升系统的多任务处理能力。</p>
<h5 id="【1】协程"><a href="#【1】协程" class="headerlink" title="【1】协程"></a>【1】协程</h5><p>子程序，或者称为函数，在所有语言中都是层级调用，比如A调用B，B在执行过程中又调用了C，C执行完毕返回，B执行完毕返回，最后是A执行完毕。</p>
<p>子程序调用总是一个入口，一次返回，调用顺序是明确的。而协程的调用和子程序不同。</p>
<p>协程看上去也是子程序，但执行过程中，在子程序内部可中断，然后转而执行别的子程序，在适当的时候再返回来接着执行。</p>
<p>注意，在一个子程序中中断，去执行其他子程序，不是函数调用，有点类似CPU的中断。比如子程序A、B</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">A</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">B</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;y&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;z&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>假设由协程执行，在执行A的过程中，可以随时中断（但是在A中是没有调用B的），去执行B，B也可能在执行过程中中断再去执行A，结果可能是：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line">x</span><br><span class="line">y</span><br><span class="line"><span class="number">3</span></span><br><span class="line">z</span><br></pre></td></tr></table></figure>

<p>看起来A、B的执行有点像多线程，但协程的特点在于是一个线程执行，那和多线程比，协程有何优势？</p>
<p>最大的优势就是协程极高的执行效率。因为子程序切换不是线程切换，而是由程序自身控制，因此，没有线程切换的开销，和多线程比，线程数量越多，协程的性能优势就越明显。</p>
<p>第二大优势就是不需要多线程的锁机制，因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多。</p>
<p>因为协程是一个线程执行，那怎么利用多核CPU呢？最简单的方法是多进程+协程，既充分利用多核，又充分发挥协程的高效率，可获得极高的性能。</p>
<p>Python对协程的支持是通过generator实现的。</p>
<p>在generator中，我们不但可以通过<code>for</code>循环来迭代，还可以不断调用<code>next()</code>函数获取由<code>yield</code>语句返回的下一个值。</p>
<p>但是Python的<code>yield</code>不但可以返回一个值，它还可以接收调用者发出的参数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 传统的生产者-消费者模型是一个线程写消息，一个线程取消息，通过锁机制控制队列和等待，但一不小心就可能死锁。</span></span><br><span class="line"><span class="comment"># 如果改用协程，生产者生产消息后，直接通过yield跳转到消费者开始执行，待消费者执行完毕后，切换回生产者继续生产，效率极高</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">分成两部分： </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	yield r 是将r 返回给外部调用程序，交出控制权，暂停；</span></span><br><span class="line"><span class="string">	n = yield 可以接收外部程序通过send()发送的信息，并赋值给n</span></span><br><span class="line"><span class="string">	</span></span><br><span class="line"><span class="string">当生成器第一次调用c.send(None)时，作用是预激，即启动生成器，效果等同于next(c)，consumer函数执行到yield r后停止，生成第一个值&#x27;&#x27;，只有在生成器启动之后，调用send方法才会赋值给n；</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">当生成器第二次及以后调用c.send(None)时，作用是终止生成器，效果等同于c.close()，但有所不同的是，c.send(None)会抛出StopIteration异常，且异常中包含返回值，而c.close()方法则不会抛出异常。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">consumer</span>():</span><br><span class="line">    r = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        n = <span class="keyword">yield</span> r</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> n:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;[CONSUMER] Consuming %s...&#x27;</span> % n)</span><br><span class="line">        r = <span class="string">&#x27;200 OK&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">produce</span>(<span class="params">c</span>):</span><br><span class="line">    c.send(<span class="literal">None</span>)</span><br><span class="line">    n = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> n &lt; <span class="number">5</span>:</span><br><span class="line">        n = n + <span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;[PRODUCER] Producing %s...&#x27;</span> % n)</span><br><span class="line">        r = c.send(n)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;[PRODUCER] Consumer return: %s&#x27;</span> % r)</span><br><span class="line">    c.close()</span><br><span class="line"></span><br><span class="line">c = consumer()</span><br><span class="line">produce(c)</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[PRODUCER] Producing 1...</span><br><span class="line">[CONSUMER] Consuming 1...</span><br><span class="line">[PRODUCER] Consumer return: 200 OK</span><br><span class="line">[PRODUCER] Producing 2...</span><br><span class="line">[CONSUMER] Consuming 2...</span><br><span class="line">[PRODUCER] Consumer return: 200 OK</span><br><span class="line">[PRODUCER] Producing 3...</span><br><span class="line">[CONSUMER] Consuming 3...</span><br><span class="line">[PRODUCER] Consumer return: 200 OK</span><br><span class="line">[PRODUCER] Producing 4...</span><br><span class="line">[CONSUMER] Consuming 4...</span><br><span class="line">[PRODUCER] Consumer return: 200 OK</span><br><span class="line">[PRODUCER] Producing 5...</span><br><span class="line">[CONSUMER] Consuming 5...</span><br><span class="line">[PRODUCER] Consumer return: 200 OK</span><br></pre></td></tr></table></figure>

<p>注意到<code>consumer</code>函数是一个<code>generator</code>，把一个<code>consumer</code>传入<code>produce</code>后：</p>
<ol>
<li>首先调用<code>c.send(None)</code>启动生成器；</li>
<li>然后，一旦生产了东西，通过<code>c.send(n)</code>切换到<code>consumer</code>执行；</li>
<li><code>consumer</code>通过<code>yield</code>拿到消息，处理，又通过<code>yield</code>把结果传回；</li>
<li><code>produce</code>拿到<code>consumer</code>处理的结果，继续生产下一条消息；</li>
<li><code>produce</code>决定不生产了，通过<code>c.close()</code>关闭<code>consumer</code>，整个过程结束。</li>
</ol>
<p>整个流程无锁，由一个线程执行，<code>produce</code>和<code>consumer</code>协作完成任务，所以称为“协程”，而非线程的抢占式多任务。</p>
<br/>



<h5 id="【2】async-await"><a href="#【2】async-await" class="headerlink" title="【2】async/await"></a>【2】async/await</h5><p>用<code>asyncio</code>提供的<code>@asyncio.coroutine</code>可以把一个generator标记为coroutine类型，然后在coroutine内部用<code>yield from</code>调用另一个coroutine实现异步操作。</p>
<p>为了简化并更好地标识异步IO，从Python 3.5开始引入了新的语法<code>async</code>和<code>await</code>，可以让coroutine的代码更简洁易读。</p>
<p>请注意，<code>async</code>和<code>await</code>是针对coroutine的新语法，要使用新的语法，只需要做两步简单的替换：</p>
<ol>
<li>把<code>@asyncio.coroutine</code>替换为<code>async</code>；</li>
<li>把<code>yield from</code>替换为<code>await</code>。</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">hello</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Hello world! (%s)&#x27;</span> % threading.current_thread())</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Hello again! (%s)&#x27;</span> % threading.current_thread())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="keyword">await</span> asyncio.gather(hello(), hello())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Hello world! (&lt;_MainThread(MainThread, started 20572)&gt;)</span><br><span class="line">Hello world! (&lt;_MainThread(MainThread, started 20572)&gt;)</span><br><span class="line">...中间等待2秒</span><br><span class="line">Hello again! (&lt;_MainThread(MainThread, started 20572)&gt;)</span><br><span class="line">Hello again! (&lt;_MainThread(MainThread, started 20572)&gt;)</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，我们定义了一个 <code>hello()</code> 异步函数，其中包含了两次打印输出和等待 1 秒的操作。然后，我们定义了一个名为 <code>main()</code> 的异步函数，使用 <code>asyncio.gather()</code> 来并发调用两个 <code>hello()</code> 函数，并且通过 <code>asyncio.run()</code> 在主程序中运行异步任务。</p>
<p>从输出结果可以看出，在两次 <code>hello()</code> 被调用之间，程序会等待 1 秒钟，而不会阻塞其他任务的进行。这就展示了异步效果，通过使用 <code>await asyncio.sleep(2)</code> 来模拟耗时操作，在等待期间可以执行其他任务，从而提高程序的并发性能。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># async def main():</span></span><br><span class="line"><span class="comment">#     await asyncio.gather(hello(), hello())</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># asyncio.run(main())</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">wget</span>(<span class="params">host</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;wget %s...&#x27;</span> % host)</span><br><span class="line">    connect = asyncio.open_connection(host, <span class="number">80</span>)</span><br><span class="line">    reader, writer = <span class="keyword">await</span> connect</span><br><span class="line">    header = <span class="string">&#x27;GET / HTTP/1.0\r\nHost: %s\r\n\r\n&#x27;</span> % host</span><br><span class="line">    writer.write(header.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">    <span class="keyword">await</span> writer.drain()</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        line = <span class="keyword">await</span> reader.readline()</span><br><span class="line">        <span class="keyword">if</span> line == <span class="string">b&#x27;\r\n&#x27;</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;%s header &gt; %s&#x27;</span> % (host, line.decode(<span class="string">&#x27;utf-8&#x27;</span>).rstrip()))</span><br><span class="line">    <span class="comment"># Ignore the body, close the socket</span></span><br><span class="line">    writer.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="keyword">await</span> asyncio.gather(*[wget(host) <span class="keyword">for</span> host <span class="keyword">in</span> [<span class="string">&#x27;www.sina.com.cn&#x27;</span>, <span class="string">&#x27;www.sohu.com&#x27;</span>, <span class="string">&#x27;www.163.com&#x27;</span>]])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<br/>



<h5 id="【3】aiohttp"><a href="#【3】aiohttp" class="headerlink" title="【3】aiohttp"></a>【3】aiohttp</h5><p><code>asyncio</code>可以实现单线程并发IO操作。如果仅用在客户端，发挥的威力不大。如果把<code>asyncio</code>用在服务器端，例如Web服务器，由于HTTP连接就是IO操作，因此可以用单线程+<code>coroutine</code>实现多用户的高并发支持。</p>
<p><code>asyncio</code>可以实现单线程并发IO操作。如果仅用在客户端，发挥的威力不大。如果把<code>asyncio</code>用在服务器端，例如Web服务器，由于HTTP连接就是IO操作，因此可以用单线程+<code>coroutine</code>实现多用户的高并发支持。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install aiohttp</span><br></pre></td></tr></table></figure>

<p>然后编写一个HTTP服务器，分别处理以下URL：</p>
<ul>
<li><code>/</code> - 首页返回<code>b&#39;&lt;h1&gt;Index&lt;/h1&gt;&#39;</code>；</li>
<li><code>/hello/&#123;name&#125;</code> - 根据URL参数返回文本<code>hello, %s!</code>。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> aiohttp <span class="keyword">import</span> web</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">index</span>(<span class="params">request</span>):</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">0.5</span>)</span><br><span class="line">    <span class="keyword">return</span> web.Response(body=<span class="string">b&#x27;&lt;h1&gt;Index&lt;/h1&gt;&#x27;</span>, content_type=<span class="string">&#x27;text/html&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">hello</span>(<span class="params">request</span>):</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">0.5</span>)</span><br><span class="line">    text = <span class="string">&#x27;&lt;h1&gt;hello, %s!&lt;/h1&gt;&#x27;</span> % request.match_info[<span class="string">&#x27;name&#x27;</span>]</span><br><span class="line">    <span class="keyword">return</span> web.Response(body=text.encode(<span class="string">&#x27;utf-8&#x27;</span>), content_type=<span class="string">&#x27;text/html&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">init</span>(<span class="params">loop</span>):</span><br><span class="line">    app = web.Application(loop=loop)</span><br><span class="line">    app.router.add_route(<span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;/&#x27;</span>, index)</span><br><span class="line">    app.router.add_route(<span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;/hello/&#123;name&#125;&#x27;</span>, hello)</span><br><span class="line">    srv = <span class="keyword">await</span> loop.create_server(app.make_handler(), <span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">8000</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Server started at http://127.0.0.1:8000...&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> srv</span><br><span class="line"></span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">loop.run_until_complete(init(loop))</span><br><span class="line">loop.run_forever()</span><br></pre></td></tr></table></figure>

<p>注意<code>aiohttp</code>的初始化函数<code>init()</code>也是一个<code>coroutine</code>，<code>loop.create_server()</code>则利用<code>asyncio</code>创建TCP服务。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> aiohttp <span class="keyword">import</span> web</span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line">routes = web.RouteTableDef()</span><br><span class="line"></span><br><span class="line"><span class="meta">@routes.get(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">index</span>(<span class="params">request</span>):</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> web.Response(body=<span class="string">&#x27;&lt;h1&gt;Index&lt;/h1&gt;&#x27;</span>.encode(), content_type=<span class="string">&#x27;text/html&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@routes.get(<span class="params"><span class="string">&#x27;/hello/&#123;name&#125;&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">hello</span>(<span class="params">request</span>):</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">0.5</span>)</span><br><span class="line">    text = <span class="string">&#x27;&lt;h1&gt;hello, %s!&lt;/h1&gt;&#x27;</span> % request.match_info[<span class="string">&#x27;name&#x27;</span>]</span><br><span class="line">    <span class="keyword">return</span> web.Response(body=text.encode(<span class="string">&#x27;utf-8&#x27;</span>), content_type=<span class="string">&#x27;text/html&#x27;</span>)</span><br><span class="line"></span><br><span class="line">app = web.Application()</span><br><span class="line">app.add_routes(routes)</span><br><span class="line">web.run_app(app,host=<span class="string">&#x27;127.0.0.1&#x27;</span>,port=<span class="number">8081</span>)</span><br></pre></td></tr></table></figure>

</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://www.kazama.top">KAZAMA</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://www.kazama.top/2022/12/21/Python%E6%A0%B8%E5%BF%83%E8%A6%81%E7%82%B9/2022-12-21-Python%E6%A0%B8%E5%BF%83%E8%A6%81%E7%82%B9/">http://www.kazama.top/2022/12/21/Python%E6%A0%B8%E5%BF%83%E8%A6%81%E7%82%B9/2022-12-21-Python%E6%A0%B8%E5%BF%83%E8%A6%81%E7%82%B9/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://www.kazama.top" target="_blank">KAZAMAのBlog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Python/">Python</a></div><div class="post_share"><div class="social-share" data-image="https://api.r10086.com/樱道随机图片api接口.php?图片系列=风景系列5" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/wechat.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/alipay.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/12/21/Python%E6%A0%B8%E5%BF%83%E6%8B%93%E5%B1%95/2022-12-21-Python%E6%A0%B8%E5%BF%83%E6%8B%93%E5%B1%95/" title="Python核心拓展"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://api.r10086.com/樱道随机图片api接口.php?图片系列=风景系列6" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Python核心拓展</div></div></a></div><div class="next-post pull-right"><a href="/2022/12/08/C++%E4%B8%AD%E4%B8%BA%E4%BB%80%E4%B9%88static%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E4%B8%80%E5%AE%9A%E8%A6%81%E5%9C%A8%E7%B1%BB%E5%A4%96%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%9F/C++%E4%B8%AD%E4%B8%BA%E4%BB%80%E4%B9%88static%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E4%B8%80%E5%AE%9A%E8%A6%81%E5%9C%A8%E7%B1%BB%E5%A4%96%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%9F/" title=""><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://api.r10086.com/樱道随机图片api接口.php?图片系列=风景系列5" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info"></div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/12/21/Python%E6%A0%B8%E5%BF%83%E6%8B%93%E5%B1%95/2022-12-21-Python%E6%A0%B8%E5%BF%83%E6%8B%93%E5%B1%95/" title="Python核心拓展"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://api.r10086.com/樱道随机图片api接口.php?图片系列=风景系列6" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-12-21</div><div class="title">Python核心拓展</div></div></a></div><div><a href="/2022/11/03/Python3%E5%88%9D%E7%BA%A7%E6%95%99%E7%A8%8B/2022-12-20-Python3%E5%88%9D%E7%BA%A7%E6%95%99%E7%A8%8B/" title="Python3初级教程"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://api.r10086.com/樱道随机图片api接口.php?图片系列=风景系列10" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-11-03</div><div class="title">Python3初级教程</div></div></a></div><div><a href="/2023/10/07/Python%E6%BA%90%E7%A0%81%E3%80%81%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/2023-10-07-Python%E6%BA%90%E7%A0%81%E3%80%81%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/" title="Python源码、实现原理分析"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://api.r10086.com/樱道随机图片api接口.php?图片系列=风景系列2" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-10-07</div><div class="title">Python源码、实现原理分析</div></div></a></div><div><a href="/2023/09/18/CentOS7%E4%B8%8B%E5%AE%8C%E7%BE%8E%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2python%E9%AB%98%E7%89%88%E6%9C%AC/2023-09-18-CentOS7%E4%B8%8B%E5%AE%8C%E7%BE%8E%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2python%E9%AB%98%E7%89%88%E6%9C%AC/" title="CentOS7下完美安装部署Python高版本"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://api.r10086.com/樱道随机图片api接口.php?图片系列=风景系列10" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-09-18</div><div class="title">CentOS7下完美安装部署Python高版本</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://api.r10086.com/樱道随机图片api接口.php?图片系列=风景系列3" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">KAZAMA</div><div class="author-info__description">技术记录,个人分享,学习备忘</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">341</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">19</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/KAZAMA-DREAM"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/KAZAMA-DREAM" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="/wyy1778789301@163.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Python%E6%A0%B8%E5%BF%83%E8%A6%81%E7%82%B9"><span class="toc-text">Python核心要点</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81python%E5%9F%BA%E7%A1%80"><span class="toc-text">1、python基础</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E3%80%901%E3%80%91%E7%9B%B4%E6%8E%A5%E8%BF%90%E8%A1%8Cpy%E6%96%87%E4%BB%B6"><span class="toc-text">【1】直接运行py文件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E3%80%902%E3%80%91%E6%B5%AE%E7%82%B9%E6%95%B0"><span class="toc-text">【2】浮点数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E3%80%903%E3%80%91%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">【3】字符串</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E5%87%BD%E6%95%B0"><span class="toc-text">2、函数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E3%80%901%E3%80%91%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0"><span class="toc-text">【1】函数的参数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7"><span class="toc-text">3、高级特性</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E3%80%901%E3%80%91%E5%88%87%E7%89%87"><span class="toc-text">【1】切片</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E3%80%902%E3%80%91%E8%BF%AD%E4%BB%A3"><span class="toc-text">【2】迭代</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E3%80%903%E3%80%91%E5%88%97%E8%A1%A8%E7%94%9F%E6%88%90%E5%BC%8F"><span class="toc-text">【3】列表生成式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E3%80%904%E3%80%91%E7%94%9F%E6%88%90%E5%99%A8"><span class="toc-text">【4】生成器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E3%80%905%E3%80%91%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-text">【5】迭代器</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B"><span class="toc-text">4、函数式编程</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E3%80%901%E3%80%91%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0"><span class="toc-text">【1】高阶函数</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%EF%BC%881%EF%BC%89map-reduce"><span class="toc-text">（1）map&#x2F;reduce</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%EF%BC%882%EF%BC%89filter"><span class="toc-text">（2）filter</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%EF%BC%883%EF%BC%89sorted%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95"><span class="toc-text">（3）sorted排序算法</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E3%80%902%E3%80%91%E5%87%BD%E6%95%B0%E4%BD%9C%E4%B8%BA%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-text">【2】函数作为返回值</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E3%80%903%E3%80%91%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0"><span class="toc-text">【3】匿名函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E3%80%904%E3%80%91%E8%A3%85%E9%A5%B0%E5%99%A8"><span class="toc-text">【4】装饰器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E3%80%905%E3%80%91%E5%81%8F%E5%87%BD%E6%95%B0"><span class="toc-text">【5】偏函数</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81%E6%A8%A1%E5%9D%97"><span class="toc-text">5、模块</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E3%80%901%E3%80%91%E4%BD%BF%E7%94%A8%E6%A8%A1%E5%9D%97"><span class="toc-text">【1】使用模块</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E3%80%902%E3%80%91%E5%AE%89%E8%A3%85%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A8%A1%E5%9D%97"><span class="toc-text">【2】安装第三方模块</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E3%80%81%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B"><span class="toc-text">6、面向对象编程</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E3%80%901%E3%80%91%E7%B1%BB%E5%86%85%E9%83%A8%E8%AE%BF%E9%97%AE%E9%99%90%E5%88%B6"><span class="toc-text">【1】类内部访问限制</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E3%80%902%E3%80%91%E7%BB%A7%E6%89%BF%E5%92%8C%E5%A4%9A%E6%80%81"><span class="toc-text">【2】继承和多态</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E3%80%903%E3%80%91%E8%8E%B7%E5%8F%96%E5%AF%B9%E8%B1%A1%E4%BF%A1%E6%81%AF"><span class="toc-text">【3】获取对象信息</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E3%80%904%E3%80%91%E5%AE%9E%E4%BE%8B%E5%B1%9E%E6%80%A7%E5%92%8C%E7%B1%BB%E5%B1%9E%E6%80%A7"><span class="toc-text">【4】实例属性和类属性</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7%E3%80%81%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B"><span class="toc-text">7、面向对象高级编程</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E3%80%901%E3%80%91%E4%BD%BF%E7%94%A8-slots"><span class="toc-text">【1】使用  __slots__  </span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E3%80%902%E3%80%91%E4%BD%BF%E7%94%A8-property"><span class="toc-text">【2】使用@property</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E3%80%903%E3%80%91%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF"><span class="toc-text">【3】多重继承</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E3%80%904%E3%80%91%E5%AE%9A%E5%88%B6%E7%B1%BB"><span class="toc-text">【4】定制类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E3%80%905%E3%80%91%E4%BD%BF%E7%94%A8%E6%9E%9A%E4%B8%BE%E7%B1%BB"><span class="toc-text">【5】使用枚举类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E3%80%906%E3%80%91%E4%BD%BF%E7%94%A8%E5%85%83%E7%B1%BB"><span class="toc-text">【6】使用元类</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8%E3%80%81%E9%94%99%E8%AF%AF%E3%80%81%E8%B0%83%E8%AF%95%E5%92%8C%E6%B5%8B%E8%AF%95"><span class="toc-text">8、错误、调试和测试</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E3%80%901%E3%80%91%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86"><span class="toc-text">【1】错误处理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E3%80%902%E3%80%91%E8%B0%83%E8%AF%95"><span class="toc-text">【2】调试</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E3%80%903%E3%80%91%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95"><span class="toc-text">【3】单元测试</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E3%80%904%E3%80%91%E6%96%87%E6%A1%A3%E6%B5%8B%E8%AF%95"><span class="toc-text">【4】文档测试</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9%E3%80%81IO%E7%BC%96%E7%A8%8B"><span class="toc-text">9、IO编程</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E3%80%901%E3%80%91%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99"><span class="toc-text">【1】文件读写</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E3%80%902%E3%80%91StringIO%E5%92%8CBytesIO"><span class="toc-text">【2】StringIO和BytesIO</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E3%80%903%E3%80%91%E6%93%8D%E4%BD%9C%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95"><span class="toc-text">【3】操作文件和目录</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E3%80%904%E3%80%91%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-text">【4】序列化</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10%E3%80%81%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B"><span class="toc-text">10、进程与线程</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E3%80%901%E3%80%91%E5%A4%9A%E8%BF%9B%E7%A8%8B"><span class="toc-text">【1】多进程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E3%80%902%E3%80%91%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-text">【2】多线程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E3%80%903%E3%80%91ThreadLocal"><span class="toc-text">【3】ThreadLocal</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E3%80%904%E3%80%91%E8%BF%9B%E7%A8%8BVS%E7%BA%BF%E7%A8%8B"><span class="toc-text">【4】进程VS线程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E3%80%905%E3%80%91%E5%88%86%E5%B8%83%E5%BC%8F%E8%BF%9B%E7%A8%8B"><span class="toc-text">【5】分布式进程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-1"><span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11%E3%80%81%E5%BC%82%E6%AD%A5IO"><span class="toc-text">11、异步IO</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E3%80%901%E3%80%91%E5%8D%8F%E7%A8%8B"><span class="toc-text">【1】协程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E3%80%902%E3%80%91async-await"><span class="toc-text">【2】async&#x2F;await</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E3%80%903%E3%80%91aiohttp"><span class="toc-text">【3】aiohttp</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/10/21/Docker%E5%85%A5%E9%97%A8/2023-10-21-Docker%E5%85%A5%E9%97%A8/" title="Docker入门"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://api.r10086.com/樱道随机图片api接口.php?图片系列=风景系列3" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Docker入门"/></a><div class="content"><a class="title" href="/2023/10/21/Docker%E5%85%A5%E9%97%A8/2023-10-21-Docker%E5%85%A5%E9%97%A8/" title="Docker入门">Docker入门</a><time datetime="2023-10-21T12:17:07.000Z" title="发表于 2023-10-21 20:17:07">2023-10-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/10/07/Python%E6%BA%90%E7%A0%81%E3%80%81%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/2023-10-07-Python%E6%BA%90%E7%A0%81%E3%80%81%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/" title="Python源码、实现原理分析"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://api.r10086.com/樱道随机图片api接口.php?图片系列=风景系列2" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Python源码、实现原理分析"/></a><div class="content"><a class="title" href="/2023/10/07/Python%E6%BA%90%E7%A0%81%E3%80%81%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/2023-10-07-Python%E6%BA%90%E7%A0%81%E3%80%81%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/" title="Python源码、实现原理分析">Python源码、实现原理分析</a><time datetime="2023-10-07T12:17:07.000Z" title="发表于 2023-10-07 20:17:07">2023-10-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/10/06/%E3%80%90%E5%BC%80%E6%BA%90%E7%A4%BE%E5%8C%BA%E3%80%91%E5%A6%82%E4%BD%95%E6%8F%90%E4%BA%A4%E4%BD%A0%E7%9A%84Pull%20Request/2023-10-06-%E3%80%90%E5%BC%80%E6%BA%90%E7%A4%BE%E5%8C%BA%E3%80%91%E5%A6%82%E4%BD%95%E6%8F%90%E4%BA%A4%E4%BD%A0%E7%9A%84Pull%20Request/" title="【开源社区】如何提交你的Pull Request"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://api.r10086.com/樱道随机图片api接口.php?图片系列=风景系列1" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【开源社区】如何提交你的Pull Request"/></a><div class="content"><a class="title" href="/2023/10/06/%E3%80%90%E5%BC%80%E6%BA%90%E7%A4%BE%E5%8C%BA%E3%80%91%E5%A6%82%E4%BD%95%E6%8F%90%E4%BA%A4%E4%BD%A0%E7%9A%84Pull%20Request/2023-10-06-%E3%80%90%E5%BC%80%E6%BA%90%E7%A4%BE%E5%8C%BA%E3%80%91%E5%A6%82%E4%BD%95%E6%8F%90%E4%BA%A4%E4%BD%A0%E7%9A%84Pull%20Request/" title="【开源社区】如何提交你的Pull Request">【开源社区】如何提交你的Pull Request</a><time datetime="2023-10-06T12:17:07.000Z" title="发表于 2023-10-06 20:17:07">2023-10-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/09/18/CentOS7%E4%B8%8B%E5%AE%8C%E7%BE%8E%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2python%E9%AB%98%E7%89%88%E6%9C%AC/2023-09-18-CentOS7%E4%B8%8B%E5%AE%8C%E7%BE%8E%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2python%E9%AB%98%E7%89%88%E6%9C%AC/" title="CentOS7下完美安装部署Python高版本"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://api.r10086.com/樱道随机图片api接口.php?图片系列=风景系列10" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CentOS7下完美安装部署Python高版本"/></a><div class="content"><a class="title" href="/2023/09/18/CentOS7%E4%B8%8B%E5%AE%8C%E7%BE%8E%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2python%E9%AB%98%E7%89%88%E6%9C%AC/2023-09-18-CentOS7%E4%B8%8B%E5%AE%8C%E7%BE%8E%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2python%E9%AB%98%E7%89%88%E6%9C%AC/" title="CentOS7下完美安装部署Python高版本">CentOS7下完美安装部署Python高版本</a><time datetime="2023-09-18T12:17:07.000Z" title="发表于 2023-09-18 20:17:07">2023-09-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/09/17/Linux%E4%B9%8Byum%E5%91%BD%E4%BB%A4%E5%A4%B1%E6%95%88/2023-09-17-Linux%E4%B9%8Byum%E5%91%BD%E4%BB%A4%E5%A4%B1%E6%95%88/" title="Linux之yum命令失效"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://api.r10086.com/樱道随机图片api接口.php?图片系列=风景系列9" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Linux之yum命令失效"/></a><div class="content"><a class="title" href="/2023/09/17/Linux%E4%B9%8Byum%E5%91%BD%E4%BB%A4%E5%A4%B1%E6%95%88/2023-09-17-Linux%E4%B9%8Byum%E5%91%BD%E4%BB%A4%E5%A4%B1%E6%95%88/" title="Linux之yum命令失效">Linux之yum命令失效</a><time datetime="2023-09-17T12:17:07.000Z" title="发表于 2023-09-17 20:17:07">2023-09-17</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://api.r10086.com/樱道随机图片api接口.php?图片系列=风景系列5')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By KAZAMA</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"></div><canvas class="fireworks" mobile="true"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = true;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>