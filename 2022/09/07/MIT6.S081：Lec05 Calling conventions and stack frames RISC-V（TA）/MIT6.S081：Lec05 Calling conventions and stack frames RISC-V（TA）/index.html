<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>KAZAMA的个人博客 | KAZAMA的个人博客</title><meta name="author" content="KAZAMA,wyy1778789301@163.com"><meta name="copyright" content="KAZAMA"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="MIT6.S081：Lec05 Calling conventions and stack frames RISC-V（TA）5.1 C程序到汇编程序到转换今天的课程，我们会稍微讨论C语言转换到汇编语言的过程，以及处理器相关的内容。今天的课程更多偏向的是实际应用，或者至少我们的目标是这样的。所以这节课的目标是让你们熟悉RISC-V处理器，汇编语言，以及RISC-V的calling conventi">
<meta property="og:type" content="article">
<meta property="og:title" content="KAZAMA的个人博客">
<meta property="og:url" content="http://njuni.online/2022/09/07/MIT6.S081%EF%BC%9ALec05%20Calling%20conventions%20and%20stack%20frames%20RISC-V%EF%BC%88TA%EF%BC%89/MIT6.S081%EF%BC%9ALec05%20Calling%20conventions%20and%20stack%20frames%20RISC-V%EF%BC%88TA%EF%BC%89/index.html">
<meta property="og:site_name" content="KAZAMA的个人博客">
<meta property="og:description" content="MIT6.S081：Lec05 Calling conventions and stack frames RISC-V（TA）5.1 C程序到汇编程序到转换今天的课程，我们会稍微讨论C语言转换到汇编语言的过程，以及处理器相关的内容。今天的课程更多偏向的是实际应用，或者至少我们的目标是这样的。所以这节课的目标是让你们熟悉RISC-V处理器，汇编语言，以及RISC-V的calling conventi">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png">
<meta property="article:published_time" content="2022-09-06T16:00:00.000Z">
<meta property="article:modified_time" content="2023-02-04T07:30:00.028Z">
<meta property="article:author" content="KAZAMA">
<meta property="article:tag" content="技术分享 学习备忘">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://njuni.online/2022/09/07/MIT6.S081%EF%BC%9ALec05%20Calling%20conventions%20and%20stack%20frames%20RISC-V%EF%BC%88TA%EF%BC%89/MIT6.S081%EF%BC%9ALec05%20Calling%20conventions%20and%20stack%20frames%20RISC-V%EF%BC%88TA%EF%BC%89/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'KAZAMA的个人博客',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-02-04 15:30:00'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = url => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      link.onload = () => resolve()
      link.onerror = () => reject()
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.2"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">300</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">1</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="KAZAMA的个人博客"><span class="site-name">KAZAMA的个人博客</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">无题</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-09-06T16:00:00.000Z" title="发表于 2022-09-07 00:00:00">2022-09-07</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-02-04T07:30:00.028Z" title="更新于 2023-02-04 15:30:00">2023-02-04</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="MIT6-S081：Lec05-Calling-conventions-and-stack-frames-RISC-V（TA）"><a href="#MIT6-S081：Lec05-Calling-conventions-and-stack-frames-RISC-V（TA）" class="headerlink" title="MIT6.S081：Lec05 Calling conventions and stack frames RISC-V（TA）"></a>MIT6.S081：Lec05 Calling conventions and stack frames RISC-V（TA）</h1><h2 id="5-1-C程序到汇编程序到转换"><a href="#5-1-C程序到汇编程序到转换" class="headerlink" title="5.1 C程序到汇编程序到转换"></a>5.1 C程序到汇编程序到转换</h2><p><strong>今天的课程，我们会稍微讨论C语言转换到汇编语言的过程，以及处理器相关的内容。今天的课程更多偏向的是实际应用，或者至少我们的目标是这样的。所以这节课的目标是让你们熟悉RISC-V处理器，汇编语言，以及RISC-V的calling convention。对于page table来说这些内容不太重要，但是对于这周要发布的traps lab来说，这些内容至关重要，因为在这个实验中你们将会频繁用到trapframe（注，XV6中用来实现trap的一个内存page，lecture 6有详细内容）和栈。这些就是今天这节课的主要内容。</strong></p>
<p><img src="https://906337931-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHZoT2b_bcLghjAOPsJ%2Fsync%2Fef121bbc91e1e50578433b8e4ea1ff125ab1cfa2.png?generation=1603275149561505&alt=media" alt="img"></p>
<br/>



<p><strong>我们首先来简单看一下C语言是如何转换成汇编语言的。这部分内容有点像是你们之前学过的6.004或者任意其他计算机架构课程的简单回顾。</strong></p>
<p><strong>通常来说，我们的C语言程序会有一个main函数，假设在这个函数内你执行了一些打印然后退出了。</strong></p>
<p><img src="https://906337931-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHZoT2b_bcLghjAOPsJ%2F-MLx7CfaUsd9tWT_xTHR%2F-MLz8XNzUZnYmk6MryBE%2Fimage.png?alt=media&token=7775c35e-8ced-41e7-a291-1a2a4469b3e5" alt="img"></p>
<br/>



<p><strong>目前看起来都还不错。但是如果你学过了6.004的话，你应该知道，处理器并不能理解C语言。处理器能够理解的是汇编语言，或者更具体的说，处理器能够理解的是二进制编码之后的汇编代码。</strong></p>
<p><strong>下面这张图中，我从一个SiFive（注，一家基于RISC-V处理器的厂商）主板上圈出了一个实际的RISC-V处理器。</strong></p>
<p><img src="https://906337931-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHZoT2b_bcLghjAOPsJ%2F-MLx7CfaUsd9tWT_xTHR%2F-MLz9U_hdW8z9hXBY8Xn%2Fimage.png?alt=media&token=95f9c5af-46d8-4b3a-81c5-092677229bd9" alt="img"></p>
<br/>



<p><strong>当我们说到一个RISC-V处理器时，意味着这个处理器能够理解RISC-V的指令集。所以，任何一个处理器都有一个关联的ISA（Instruction Sets Architecture），ISA就是处理器能够理解的指令集。每一条指令都有一个对应的二进制编码或者一个Opcode。当处理器在运行时，如果看见了这些编码，那么处理器就知道该做什么样的操作。上图中的处理器正好能理解RISC-V汇编语言。</strong></p>
<p><strong>所以通常来说，要让C语言能够运行在你的处理器之上。我们首先要写出C程序，之后这个C程序需要被编译成汇编语言。这个过程中有一些链接和其他的步骤，但是因为这门课不是一个编译器的课程，所以我们忽略这些步骤。之后汇编语言会被翻译成二进制文件也就是.obj或者.o文件。</strong></p>
<p><img src="https://906337931-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHZoT2b_bcLghjAOPsJ%2F-MLx7CfaUsd9tWT_xTHR%2F-MLzHadiOcRt3WrEzrOS%2Fimage.png?alt=media&token=35df9be7-05e8-4fe0-a112-9e381000ee30" alt="img"></p>
<br/>



<p><strong>如果你们曾经注意过你们的lab目录，在运行完make qemu之后你会看到一些.o文件，这些就是处理器能够理解的文件。虽然你还没有写任何汇编程序，你们也可以在目录中看到一些.asm文件，这是由C语言编译生成的。如果你们学过了6.004，那么你们必然已经看过一些汇编语言。</strong></p>
<p><strong>汇编语言不具备C语言的组织结构，在汇编语言中你只能看到一行行的指令，比如add，mult等等。汇编语言中没有很好的控制流程，没有循环（注，但是有基于lable的跳转），虽然有函数但是与你们知道的C语言函数不太一样，汇编语言中的函数是以label的形式存在而不是真正的函数定义。汇编语言是一门非常底层的语言，许多其他语言，比如C++，都会编译成汇编语言。运行任何编译型语言之前都需要先生成汇编语言。</strong></p>
<br/>

<br/>



<h2 id="5-2-RISC-V-vs-x86"><a href="#5-2-RISC-V-vs-x86" class="headerlink" title="5.2 RISC-V vs x86"></a>5.2 RISC-V vs x86</h2><p><strong>你们将会注意到，我们在这节课中反复会提到RISC-V汇编。这一点很重要，因为汇编语言有很多种（注，因为不同的处理器指令集不一样，而汇编语言中都是一条条指令，所以不同处理器对应的汇编语言必然不一样）。如果你使用RISC-V，你不太能将Linux运行在上面。相应的，大多数现代计算机都运行在x86和x86-64处理器上。x86拥有一套不同的指令集，看起来与RISC-V非常相似。通常你们的个人电脑上运行的处理器是x86，Intel和AMD的CPU都实现了x86。</strong></p>
<p><img src="https://906337931-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHZoT2b_bcLghjAOPsJ%2F-MLx7CfaUsd9tWT_xTHR%2F-MLzNWFVE_W7LLDZjKfM%2Fimage.png?alt=media&token=2c75ae04-cdce-4e74-834d-f444156bbd38" alt="img"></p>
<p><strong>RISC-V和x86并没有它们第一眼看起来那么相似。RISC-V中的RISC是精简指令集（Reduced Instruction Set Computer）的意思，而x86通常被称为CISC，复杂指令集（Complex Instruction Set Computer）。这两者之间有一些关键的区别：</strong></p>
<ul>
<li><strong>首先是指令的数量。实际上，创造RISC-V的一个非常大的初衷就是因为Intel手册中指令数量太多了。x86-64指令介绍由3个文档组成，并且新的指令以每个月3条的速度在增加。因为x86-64是在1970年代发布的，所以我认为现在有多于15000条指令。RISC-V指令介绍由两个文档组成。在这节课中，不需要你们记住每一个RISC-V指令，但是如果你感兴趣或者你发现你不能理解某个具体的指令的话，在课程网站的参考页面有RISC-V指令的两个文档链接。这两个文档包含了RISC-V的指令集的所有信息，分别是240页和135页，相比x86的指令集文档要小得多。这是有关RISC-V比较好的一方面。所以在RISC-V中，我们有更少的指令数量。</strong></li>
<li><strong>除此之外，RISC-V指令也更加简单。在x86-64中，很多指令都做了不止一件事情。这些指令中的每一条都执行了一系列复杂的操作并返回结果。但是RISC-V不会这样做，RISC-V的指令趋于完成更简单的工作，相应的也消耗更少的CPU执行时间。这其实是设计人员在底层设计时的取舍。并没有一些非常确定的原因说RISC比CISC更好。它们各自有各自的使用场景。</strong></li>
<li><strong>相比x86来说，RISC另一件有意思的事情是它是开源的。这是市场上唯一的一款开源指令集，这意味着任何人都可以为RISC-V开发主板。RISC-V是来自于UC-Berkly的一个研究项目，之后被大量的公司选中并做了支持，网上有这些公司的名单，许多大公司对于支持一个开源指令集都感兴趣。</strong></li>
</ul>
<br/>



<p><strong>我记得最近，作为主要的RISC-V处理器生产商，SiFive宣称会发布一款基于RISC-V的主板，用来在个人计算机上运行Linux系统。如果你好奇或者想要使用RISC-V，在你学完了6.S081之后，大概率你可以在你的个人电脑上通过RISC-V处理器运行Linux。</strong></p>
<p><strong>在你们的日常生活中，你们可能已经在完全不知情的情况下使用了精简指令集。比如说ARM也是一个精简指令集，高通的Snapdragon处理器就是基于ARM。如果你使用了一个Android手机，那么大概率你的手机运行在精简指令集上。如果你使用IOS，苹果公司也实现某种版本的ARM处理器，这些处理器运行在iPad，iPhone和大多数苹果移动设备上，甚至对于Mac，苹果公司也在尝试向ARM做迁移（注，刚刚发布的Macbook）。所以精简指令集出现在各种各样的地方。如果你想在现实世界中找到RISC-V处理器，你可以在一些嵌入式设备中找到。所以RISC-V也是有应用的，当然它可能没有x86那么流行。</strong></p>
<p><img src="https://906337931-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHZoT2b_bcLghjAOPsJ%2F-MLx7CfaUsd9tWT_xTHR%2F-MM-Ogz9rmB3fq42DxKG%2Fimage.png?alt=media&token=89396eef-3cb5-4a01-b73b-050cc702ffc2" alt="img"></p>
<br/>



<p><strong>在最近几年，由于Intel的指令集实在是太大了，精简指令集的使用越来越多。Intel的指令集之所以这么大，是因为Intel对于向后兼容非常看重。所以一个现代的Intel处理器还可以运行30/40年前的指令。Intel并没有下线任何指令。而RISC-V提出的更晚，所以不存在历史包袱问题。</strong></p>
<blockquote>
<p><strong><code>学生提问：</code>为什么x86会有15000条指令？</strong></p>
<p><strong><code>TA：</code>如我刚刚所说的，我们需要许多指令来实现向后兼容，向后兼容是否重要因人而异。另一方面，我认为这里许多指令都是cmd指令，用来完成一些特殊的操作。我从来没有见过一个Intel的汇编代码使用了所有的15000个指令。大多数这些指令都是为了向后兼容和cmd的需求创建。</strong></p>
</blockquote>
<br/>



<p><strong>如果查看RISC-V的文档，可以发现RISC-V的特殊之处在于：它区分了Base Integer Instruction Set和Standard Extension Instruction Set。Base Integer Instruction Set包含了所有的常用指令，比如add，mult。除此之外，处理器还可以选择性的支持Standard Extension Instruction Set。例如，一个处理器可以选择支持Standard Extension for Single-Precision Float-Point。这种模式使得RISC-V更容易支持向后兼容。每一个RISC-V处理器可以声明支持了哪些扩展指令集，然后编译器可以根据支持的指令集来编译代码。</strong></p>
<blockquote>
<p><strong><code>学生提问：</code>看起来使用x86而不是RISC-V的唯一优势就是能得到性能的提升，但是这里的性能是以复杂度和潜在的安全为代价的，我的问题是为什么我们还在使用x86，而不是使用RISC-V处理器？</strong></p>
<p><strong><code>TA：</code>我并没有一个很好的答案来回答。现在整个世界都运行在x86上，如果你突然将处理器转变成RISC-V，那么你就失去了很多重要的软件支持。同时，Intel在它的处理器里面做了一些有意思的事情，例如安全相关的enclave，这是Intel最近加到处理器中来提升安全性的功能。此外，Intel还实现了一些非常具体的指令，这些指令可以非常高效的进行一些特定的运算。所以Intel有非常多的指令，通常来说对于一个场景都会有一个完美的指令，它的执行效率要高于RISC-V中的同等指令。但是这个问题更实际的答案是，RISC-V相对来说更新一些，目前还没有人基于RISC-V来制造个人计算机，SiFive也就是最近才称为第一批将RISC-V应用到个人计算机的公司。所以，从实际的角度来说，因为不能在RISC-V上运行所有为Intel设计的软件，是我对这个问题的最好的答案。</strong></p>
</blockquote>
<br/>

<br/>



<h2 id="5-3-gdb和汇编代码执行"><a href="#5-3-gdb和汇编代码执行" class="headerlink" title="5.3 gdb和汇编代码执行"></a>5.3 gdb和汇编代码执行</h2><p><strong>图中代码，上半部分的注释是对应的C代码，这是个简单的函数，它累加了从1到n的所有数字，并返回结果。下半部分是可以编译出的最简单的汇编代码。如果你在你自己的计算机编写同样的C代码并编译，你得到的极有可能是差别较大的汇编代码。这里有很多原因，有一些原因我们之后会讲，有一些原因是因为编译器。当C代码编译成汇编代码时，现代的编译器会执行各种各样的优化，所以你们自己编译得到的汇编代码可能看起来是不一样的。例如，当你在gdb中做debug的时候，有时候你会看到gdb提示你说某些变量被优化掉了，这意味着编译器决定了自己不再需要那个变量，变量以及相关的信息会在某个时间点删掉。</strong></p>
<p><strong>下图的代码很直观，首先将寄存器a0中的值保存在寄存器t0中。之后将寄存器a0设置为0，之后在每个循环中将t0中的数据加到a0中，直到t0变成0。这就是代码的所有内容。</strong></p>
<p><img src="https://906337931-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHZoT2b_bcLghjAOPsJ%2F-MM-XjiGboAFe-3YvZfT%2F-MM0O7F87I4yrfDs2tnM%2Fimage.png?alt=media&token=7b7d91bd-566d-4f03-9bbb-09ac5b3c7926" alt="img"></p>
<blockquote>
<p><strong><code>学生提问：</code>这里面.secion，.global，.text分别是什么意思？</strong></p>
<p><strong><code>TA：</code>global表示你可以在其他文件中调用这个函数。text表明这里的是代码，如果你还记得XV6中的图3.4</strong></p>
<p><strong><code>TA：</code>每个进程的page table中有一个区域是text，汇编代码中的text表明这部分是代码，并且位于page table的text区域中。text中保存的就是代码。</strong></p>
<p><img src="https://906337931-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHZoT2b_bcLghjAOPsJ%2F-MM-XjiGboAFe-3YvZfT%2F-MM0X_s13Uk2By7Qk_gJ%2Fimage.png?alt=media&token=330471b3-8a48-44d0-ab38-d582b526bca8" alt="img"></p>
</blockquote>
<br/>



<p><strong>如果你对内核比较感兴趣，在编译完之后，你可以查看kernel.asm文件，你可以看到XV6完整内核的汇编版本。文件中每一行左边的数字表明的是这条指令会在内存中的哪个位置，这个信息非常有用。在汇编代码中还可以看到函数对应的label，以及它们是在哪里定义的。这些信息在我们调试代码的时候可能会非常有用，我稍后会展示这部分。</strong></p>
<blockquote>
<p><strong><code>学生提问：</code>.asm文件和.s文件有什么区别？</strong></p>
<p><strong><code>TA：</code>我并不是百分百确定。这两类文件都是汇编代码，.asm文件中包含大量额外的标注，而.s文件中没有。所以通常来说当你编译你的C代码，你得到的是.s文件。如果你好奇我们是如何得到.asm文件，makefile里面包含了具体的步骤。</strong></p>
</blockquote>
<br/>



<p><strong>现在回到函数sum_to，我们看一下如何在gdb中检查这个函数。首先要启动QEMU，</strong></p>
<p><img src="https://906337931-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHZoT2b_bcLghjAOPsJ%2F-MM-XjiGboAFe-3YvZfT%2F-MM0dRLzKlv9Pgjb7i3C%2Fimage.png?alt=media&token=0ec25721-286a-4a51-97ff-eba7492ab7ee" alt="img"></p>
<br/>



<p><strong>在另一个窗口打开gdb，</strong></p>
<p><img src="https://906337931-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHZoT2b_bcLghjAOPsJ%2F-MM-XjiGboAFe-3YvZfT%2F-MM0dhzmT1sIf7EgwRx9%2Fimage.png?alt=media&token=a30f235f-f415-460f-81a6-11f4511d8bfb" alt="img"></p>
<br/>



<p><strong>gdb中输入tui enable可以打开源代码展示窗口。</strong></p>
<p><strong>sum_to的代码现在都位于内核中，我在sum_to中设置一个断点。然后继续代码的执行，代码在断点处停住。</strong></p>
<p><img src="https://906337931-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHZoT2b_bcLghjAOPsJ%2F-MM-XjiGboAFe-3YvZfT%2F-MM0iOV59oR1qy2YHyWQ%2Fimage.png?alt=media&token=27f415bb-276f-4cdd-afe4-aef33d81b87e" alt="img"></p>
<br/>



<p><strong>gdb窗口的左上角是程序计数器，我们可以看到当前的值是0x800065e2。如果我们去kernel.asm中，查找这个地址，我们可以看到这个地址就是sum_to函数的起始地址。</strong></p>
<p><img src="https://906337931-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHZoT2b_bcLghjAOPsJ%2F-MM-XjiGboAFe-3YvZfT%2F-MM0ix3GIZvCLp3F64QT%2Fimage.png?alt=media&token=f252c827-0c08-478f-9c7d-15275943c776" alt="img"></p>
<br/>



<p><strong>如果代码出现了问题，在gdb中看到的地址，你可以直接在kernel.asm找到具体的行，分析问题的原因，然后再向相应的地址设置断点。</strong></p>
<p><strong>在gdb中输入layout asm，可以在tui窗口看到所有的汇编指令。再输入layout reg可以看到所有的寄存器信息。</strong></p>
<p><img src="https://906337931-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHZoT2b_bcLghjAOPsJ%2F-MM-XjiGboAFe-3YvZfT%2F-MM0kg6lrwTwvEvi3DGW%2Fimage.png?alt=media&token=94db1394-9fd7-4b5d-b1c3-6df16efe6051" alt="img"></p>
<br/>



<p><strong>在寄存器窗口，可以看到t0，a0寄存器的值。在执行完一条汇编指令之后，t0寄存器拥有了a0寄存器的内容，也就是5。在寄存器窗口，更新了的寄存器会被高亮出来。</strong></p>
<p><strong>之后持续的单步执行代码，直到函数返回。</strong></p>
<p><img src="https://906337931-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHZoT2b_bcLghjAOPsJ%2F-MM-XjiGboAFe-3YvZfT%2F-MM0ljIcOgoZ2JsdB3Sp%2Fimage.png?alt=media&token=6e7654c9-82ea-4f6d-b1db-8ead504591b1" alt="img"></p>
<br/>



<p><strong>如果你关心你设置了哪些断点，或者你跟踪代码的时候迷糊了，你可以在gdb中输入info breakpoints，你可以看到所有设置了的断点。你甚至可以看到这个断点已经被命中了几次。</strong></p>
<p><img src="https://906337931-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHZoT2b_bcLghjAOPsJ%2F-MM-XjiGboAFe-3YvZfT%2F-MM0oGlP-Go7kovjzc5e%2Fimage.png?alt=media&token=5dcff5c7-80d0-443f-a4b3-42b841ae45d9" alt="img"></p>
<br/>



<p><strong>类似的，你也可以通过输入info reg查看寄存器的信息。</strong></p>
<blockquote>
<p><strong><code>学生提问：</code>你是怎么打开多个terminal窗口的？</strong></p>
<p><strong><code>TA：</code>我是通过tmux打开的。（30:27-31:45在介绍tmux，与课程无关故跳过）</strong></p>
<br/>

<p><strong><code>学生提问：</code>为什么这里展示的是汇编代码而不是C代码？</strong></p>
<p><strong><code>TA：</code>从最初的代码可以看出，这里的程序完全是汇编代码实现的，所以自然也没有关联的C程序。如果我将断点设置在C代码中，在命中断点之后输入layout split或者layout source，就可以看到相应的C代码了。</strong></p>
<p><strong>layout split会同时展现C代码和汇编，而layout source只会展示C代码。</strong></p>
<br/>

<p><strong><code>学生提问：</code>在C代码中，断点设置在某一行，如果这一行有多个语句的话，断点会设置在哪个语句？</strong></p>
<p><strong><code>TA：</code>断点会设置在第一个语句。</strong></p>
</blockquote>
<p><strong>gdb和tmux有上百个快捷指令，可以通过google去查找，对于gdb，也可以使用apropos指令查看帮助。</strong></p>
<br/>

<br/>



<h2 id="5-4-RISC-V寄存器"><a href="#5-4-RISC-V寄存器" class="headerlink" title="5.4 RISC-V寄存器"></a>5.4 RISC-V寄存器</h2><p><strong>我们之前看过了汇编语言和RISC-V的介绍。接下来我们看一下之后lab相关的内容。这部分的内容其实就是本节课的<a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.828/2020/readings/riscv-calling.pdf">准备材料</a>中的内容。</strong></p>
<p><img src="https://906337931-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHZoT2b_bcLghjAOPsJ%2F-MM-XjiGboAFe-3YvZfT%2F-MM0rYc4eVnR9nOesAAv%2Fimage.png?alt=media&token=f30ebac8-8dc0-4b5d-8aa7-b241a10b43b3" alt="img"></p>
<br/>



<p><strong>你们现在对于这个表达应该都很熟悉了，这个表里面是RISC-V寄存器。寄存器是CPU或者处理器上预先定义的可以用来存储数据的位置。寄存器之所以重要是因为汇编代码并不是在内存上执行，而是在寄存器上执行，也就是说，当我们在做add，sub时，我们是对寄存器进行操作。所以你们通常看到的汇编代码中的模式是，我们通过load将数据存放在寄存器中，这里的数据源可以是来自内存，也可以来自另一个寄存器。之后我们在寄存器上执行一些操作。如果我们对操作的结果关心的话，我们会将操作的结果store在某个地方。这里的目的地可能是内存中的某个地址，也可能是另一个寄存器。这就是通常使用寄存器的方法。</strong></p>
<p><img src="https://906337931-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHZoT2b_bcLghjAOPsJ%2F-MM0rzw4rSDoFrxtpmMx%2F-MM3AtxpPfJe3nrCV0P7%2Fimage.png?alt=media&token=080d4449-cdc5-4782-9af3-ccf06225323c" alt="img"></p>
<br/>



<p><strong>寄存器是用来进行任何运算和数据读取的最快方式，这就是为什么使用它们很重要，也是为什么我们更喜欢使用寄存器而不是内存。当我们调用函数时，你可以看到这里有a0-a7寄存器。通常我们在谈到寄存器的时候，我们会用它们的ABI名字。不仅是因为这样描述更清晰和标准，同时也因为在写汇编代码的时候使用的也是ABI名字。第一列中的寄存器名字并不是超级重要，它唯一重要的场景是在RISC-V的Compressed Instruction中。基本上来说，RISC-V中通常的指令是64bit，但是在Compressed Instruction中指令是16bit。在Compressed Instruction中我们使用更少的寄存器，也就是x8-x15寄存器。我猜你们可能会有疑问，为什么s1寄存器和其他的s寄存器是分开的，因为s1在Compressed Instruction是有效的，而s2-11却不是。除了Compressed Instruction，寄存器都是通过它们的ABI名字来引用。</strong></p>
<p><strong>a0到a7寄存器是用来作为函数的参数。如果一个函数有超过8个参数，我们就需要用内存了。从这里也可以看出，当可以使用寄存器的时候，我们不会使用内存，我们只在不得不使用内存的场景才使用它。</strong></p>
<p><strong>表单中的第4列，Saver列，当我们在讨论寄存器的时候也非常重要。它有两个可能的值Caller，Callee。我经常混淆这两个值，因为它们只差一个字母。我发现最简单的记住它们的方法是：</strong></p>
<ul>
<li><strong>Caller Saved寄存器在函数调用的时候不会保存</strong></li>
<li><strong>Callee Saved寄存器在函数调用的时候会保存</strong></li>
</ul>
<p><img src="https://906337931-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHZoT2b_bcLghjAOPsJ%2F-MM0rzw4rSDoFrxtpmMx%2F-MM3HWikWzqDx3IbqlWM%2Fimage.png?alt=media&token=ed366a7f-25b5-4474-95d8-47688c8b4864" alt="img"></p>
<br/>



<p><strong>这里的意思是，一个Caller Saved寄存器可能被其他函数重写。假设我们在函数a中调用函数b，任何被函数a使用的并且是Caller Saved寄存器，调用函数b可能重写这些寄存器。我认为一个比较好的例子就是Return address寄存器（注，保存的是函数返回的地址），你可以看到ra寄存器是Caller Saved，这一点很重要，它导致了当函数a调用函数b的时候，b会重写Return address。所以基本上来说，任何一个Caller Saved寄存器，作为调用方的函数要小心可能的数据可能的变化；任何一个Callee Saved寄存器，作为被调用方的函数要小心寄存器的值不会相应的变化。我经常会弄混这两者的区别，然后会到这张表来回顾它们。</strong></p>
<p><strong>如果你们还记得的话，所有的寄存器都是64bit，各种各样的数据类型都会被改造的可以放进这64bit中。比如说我们有一个32bit的整数，取决于整数是不是有符号的，会通过在前面补32个0或1来使得这个整数变成64bit并存在这些寄存器中。</strong></p>
<blockquote>
<p><strong><code>学生提问：</code>返回值可以放在a1寄存器吗？</strong></p>
<p><strong><code>TA：</code>这是个好问题。我认为理论上是可以的，如果一个函数的返回值是long long类型，也就是128bit，我们可以把它放到一对寄存器中。这也同样适用于函数的参数。所以，如果返回值超过了一个寄存器的长度，也就是64bit，我们可以将返回值保存在a0和a1。但是如果你只将返回值放在a1寄存器，我认为会出错。</strong></p>
<br/>

<p><strong><code>学生提问：</code>为什么寄存器不是连续的？比如为什么s1与其他的s寄存器是分开的？</strong></p>
<p><strong><code>TA：</code>我之前提到过，但是也只是我的猜想，我并不十分确定。因为s1寄存器在RISC-V的Compressed Instruction是可用的，所以它才被分开。</strong></p>
<br/>

<p><strong><code>学生提问：</code>除了Stack Pointer和Frame Pointer，我不认为我们需要更多的Callee Saved寄存器。</strong></p>
<p><strong><code>TA：</code>s0～s11都是Callee寄存器，我认为它们是提供给编译成而不是程序员使用的。在一些特定的场景下，你会想到确保一些数据在函数调用之后仍然能够保存，这个时候编译器可以选择使用s寄存器。</strong></p>
</blockquote>
<br/>

<br/>



<h2 id="5-5-Stack"><a href="#5-5-Stack" class="headerlink" title="5.5 Stack"></a>5.5 Stack</h2><p><strong>接下来我们讨论一下栈，stack。栈之所以很重要的原因是，它使得我们的函数变得有组织，且能够正常返回。</strong></p>
<p><strong>下面是一个非常简单的栈的结构图，其中每一个区域都是一个Stack Frame，每执行一次函数调用就会产生一个Stack Frame。</strong></p>
<p><img src="https://906337931-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHZoT2b_bcLghjAOPsJ%2F-MM3Hk7Gv6ibvM2lxjCc%2F-MM4D2J3t3ajqkngxRPC%2Fimage.png?alt=media&token=1f78ffd1-9322-4666-85f2-8aa831ced49e" alt="img"></p>
<br/>



<p><strong>每一次我们调用一个函数，函数都会为自己创建一个Stack Frame，并且只给自己用。函数通过移动Stack Pointer来完成Stack Frame的空间分配。</strong></p>
<p><strong>对于Stack来说，是从高地址开始向低地址使用。所以栈总是向下增长。当我们想要创建一个新的Stack Frame的时候，总是对当前的Stack Pointer做减法。一个函数的Stack Frame包含了保存的寄存器，本地变量，并且，如果函数的参数多于8个，额外的参数会出现在Stack中。所以Stack Frame大小并不总是一样，即使在这个图里面看起来是一样大的。不同的函数有不同数量的本地变量，不同的寄存器，所以Stack Frame的大小是不一样的。但是有关Stack Frame有两件事是确定的：</strong></p>
<ul>
<li><strong>Return address 总是会出现在Stack Frame的第一位</strong></li>
<li><strong>指向前一个Stack Frame的指针也会出现在栈中的固定位置</strong></li>
</ul>
<br/>



<p><strong>有关Stack Frame中有两个重要的寄存器，第一个是SP（Stack Pointer），它指向Stack的底部并代表了当前Stack Frame的位置。第二个是FP（Frame Pointer），它指向当前Stack Frame的顶部。因为Return address和指向前一个Stack Frame的指针都在当前Stack Frame的固定位置，所以可以通过当前的FP寄存器寻址到这两个数据。</strong></p>
<p><strong>我们保存前一个Stack Frame的指针的原因是为了让我们能跳转回去。所以当前函数返回时，我们可以将前一个Frame Pointer存储到FP寄存器中。所以我们使用Frame Pointer来操纵我们的Stack Frames，并确保我们总是指向正确的函数。</strong></p>
<p><strong>Stack Frame必须要被汇编代码创建，所以是编译器生成了汇编代码，进而创建了Stack Frame。所以通常在汇编代码中，函数的最开始你们可以看到Function prologue，之后是函数的本体，最后是Epollgue。这就是一个汇编函数通常的样子。</strong></p>
<p><img src="https://906337931-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHZoT2b_bcLghjAOPsJ%2F-MM4GlTfQa57FRIbUhP2%2F-MM51g2yien9HyEOP6mn%2Fimage.png?alt=media&token=a82e4f70-5ed8-49b4-ae9e-864dabc29174" alt="img"></p>
<p><strong>我们从汇编代码中来看一下这里的操作。</strong></p>
<p><strong>在我们之前的sum_to函数中，只有函数主体，并没有Stack Frame的内容。它这里能正常工作的原因是它足够简单，并且它是一个leaf函数。leaf函数是指不调用别的函数的函数，它的特别之处在于它不用担心保存自己的Return address或者任何其他的Caller Saved寄存器，因为它不会调用别的函数。</strong></p>
<p><img src="https://906337931-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHZoT2b_bcLghjAOPsJ%2F-MM4GlTfQa57FRIbUhP2%2F-MM55NSH1I42_YJ8PUnO%2Fimage.png?alt=media&token=39a6aafe-0698-4a06-bb9f-e734861cdaf1" alt="img"></p>
<br/>



<p><strong>而另一个函数sum_then_double就不是一个leaf函数了，这里你可以看到它调用了sum_to。</strong></p>
<p><img src="https://906337931-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHZoT2b_bcLghjAOPsJ%2F-MM4GlTfQa57FRIbUhP2%2F-MM57BrzXVm-ij0-dwh-%2Fimage.png?alt=media&token=793ce260-2af4-4625-9334-bbea4651f222" alt="img"></p>
<br/>



<p><strong>所以在这个函数中，需要包含prologue。</strong></p>
<p><img src="https://906337931-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHZoT2b_bcLghjAOPsJ%2F-MM4GlTfQa57FRIbUhP2%2F-MM57e54ANIFdXpVubXH%2Fimage.png?alt=media&token=e9b9b85d-5862-4825-8b7c-7be342636a77" alt="img"></p>
<br/>



<p><strong>这里我们对Stack Pointer减16，这样我们为新的Stack Frame创建了16字节的空间。之后我们将Return address保存在Stack Pointer位置。之后就是调用sum_to并对结果乘以2，最后是Epllogue。</strong></p>
<p><strong>这里首先将Return address加载回ra寄存器，通过对Stack Pointer加16来删除刚刚创建的Stack Frame，最后ret从函数中退出。</strong></p>
<p><img src="https://906337931-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHZoT2b_bcLghjAOPsJ%2F-MM4GlTfQa57FRIbUhP2%2F-MM58TOs_9kQtfl4bVPw%2Fimage.png?alt=media&token=9fd14608-4f97-4fef-9ef7-4df05502fd5a" alt="img"></p>
<p><strong>这里我替大家问一个问题，如果我们删除掉Prologue和Epllogue，然后只剩下函数主体会发生什么？有人可以猜一下吗？</strong></p>
<blockquote>
<p><strong><code>学生提问：</code>sum_then_double将不知道它应该返回的Return address。所以调用sum_to的时候，Return address被覆盖了，最终sum_to函数不能返回到它原本的调用位置。</strong></p>
</blockquote>
<p><strong>是的，完全正确，我们可以看一下具体会发生什么。先在修改过的sum_then_double设置断点，然后指向sum_then_double。</strong></p>
<p><strong>我们可以看到现在的ra寄存器是0x80006392，它指向demo2函数，也就是sum_then_double的调用函数。之后我们执行代码，调用了sum_to。</strong></p>
<p><img src="https://906337931-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHZoT2b_bcLghjAOPsJ%2F-MM4GlTfQa57FRIbUhP2%2F-MM5FKgM14gj9VrgebcG%2Fimage.png?alt=media&token=a2f109d3-b7b6-4ca0-a485-7ed2ff87d4bd" alt="img"></p>
<br/>



<p><strong>我们可以看到ra寄存器的值被sum_to重写成了0x800065f4，指向sum_then_double，这也合理，符合我们的预期。我们在函数sum_then_double中调用了sum_to，那么sum_to就应该要返回到sum_then_double。</strong></p>
<p><strong>之后执行代码直到sum_then_double返回。如前面那位同学说的，因为没有恢复sum_then_double自己的Return address，现在的Return address仍然是sum_to对应的值，现在我们就会进入到一个无限循环中。</strong></p>
<p><strong>我认为这是一个很好的例子用来展示为什么跟踪Caller和Callee寄存器是重要的。</strong></p>
<p><img src="https://906337931-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHZoT2b_bcLghjAOPsJ%2F-MM4GlTfQa57FRIbUhP2%2F-MM5Fs1G_y-4BlwL3RXf%2Fimage.png?alt=media&token=69dc6ec6-fdf5-445d-823a-6953c95a16e4" alt="img"></p>
<br/>



<blockquote>
<p><strong><code>学生提问：</code>为什么在最开始要对sp寄存器减16？</strong></p>
<p><strong><code>TA：</code>是为了Stack Frame创建空间。减16相当于内存地址向前移16，这样对于我们自己的Stack Frame就有了空间，我们可以在哪个空间存数据。我们并不想覆盖原来在Stack Pointer位置的数据。</strong></p>
<br/>

<p><strong><code>学生提问：</code>为什么不减4呢？</strong></p>
<p><strong><code>TA：</code>我认为我们不需要减16那么多，但是4个也太少了，你至少需要减8，因为接下来要存的ra寄存器是64bit（8字节）。这里的习惯是用16字节，因为我们要存Return address和指向上一个Stack Frame的地址，只不过我们这里没有指向上一个Stack Frame的地址。如果你看kernel.asm，你可以发现16个字节通常就是编译器给的值。</strong></p>
</blockquote>
<br/>



<p><strong>接下来我们来看一些C代码</strong></p>
<p><img src="https://906337931-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHZoT2b_bcLghjAOPsJ%2F-MM4GlTfQa57FRIbUhP2%2F-MM8AM8rqcOaYozyza3b%2Fimage.png?alt=media&token=92ba0438-492f-405c-9a78-20bb7df76b7c" alt="img"></p>
<br/>



<p><strong>demo4函数里面调用了dummymain函数。我们在dummymain函数中设置一个断点，</strong></p>
<p><img src="https://906337931-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHZoT2b_bcLghjAOPsJ%2F-MM4GlTfQa57FRIbUhP2%2F-MM8B3-AbW3Onhnzb77l%2Fimage.png?alt=media&token=8f6a623e-dcf4-460a-a8a5-f39a58c99308" alt="img"></p>
<br/>



<p><strong>现在我们在dummymain函数中。如果我们在gdb中输入info frame，可以看到有关当前Stack Frame许多有用的信息。</strong></p>
<p><img src="https://906337931-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHZoT2b_bcLghjAOPsJ%2F-MM4GlTfQa57FRIbUhP2%2F-MM8BtVIjSM5xZ3lL4fn%2Fimage.png?alt=media&token=51309333-5768-41de-9f33-646bc219e263" alt="img"></p>
<ul>
<li><strong>Stack level 0，表明这是调用栈的最底层</strong></li>
<li><strong>pc，当前的程序计数器</strong></li>
<li><strong>saved pc，demo4的位置，表明当前函数要返回的位置</strong></li>
<li><strong>source language c，表明这是C代码</strong></li>
<li><strong>Arglist at，表明参数的起始地址。当前的参数都在寄存器中，可以看到argc=3，argv是一个地址</strong></li>
</ul>
<br/>



<p><strong>如果输入backtrace（简写bt）可以看到从当前调用栈开始的所有Stack Frame。</strong></p>
<p><img src="https://906337931-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHZoT2b_bcLghjAOPsJ%2F-MM4GlTfQa57FRIbUhP2%2F-MM8FCpKDwxRqZQDjua0%2Fimage.png?alt=media&token=b3d0a405-02f2-45c1-a08c-0182799b6860" alt="img"></p>
<br/>



<p><strong>如果对某一个Stack Frame感兴趣，可以先定位到那个frame再输入info frame，假设对syscall的Stack Frame感兴趣。</strong></p>
<p><strong>在这个Stack Frame中有更多的信息，有一堆的Saved Registers，有一些本地变量等等。这些信息对于调试代码来说超级重要。</strong></p>
<p><img src="https://906337931-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHZoT2b_bcLghjAOPsJ%2F-MM4GlTfQa57FRIbUhP2%2F-MM8GApvnQ0OqMJGrX_2%2Fimage.png?alt=media&token=f5dbb29d-e386-49ed-8d62-5ecf6866ae59" alt="img"></p>
<blockquote>
<p><strong><code>学生提问：</code>为什么有的时候编译器会优化掉argc或者argv？这个以前发生过。</strong></p>
<p><strong><code>TA：</code>这意味着编译器发现了一种更有效的方法，不使用这些变量，而是通过寄存器来完成所有的操作。如果一个变量不是百分百必要的话，这种优化还是很常见的。我们并没有给你编译器的控制能力，但是在你们的日常使用中，你可以尝试设置编译器的optimization flag为0，不过就算这样，编译器也会做某些程度的优化。</strong></p>
</blockquote>
<p>（1:04:08-1:09:46在介绍一些gdb技巧，conditional breakpoint，watchpoint等，与课程内容无关，故跳过）</p>
<br/>

<br/>



<h2 id="5-6-Struct"><a href="#5-6-Struct" class="headerlink" title="5.6 Struct"></a>5.6 Struct</h2><p><strong>今天我想讨论的最后一个话题是struct，struct非常重要并且在课程的实验中会经常出现。我会稍微介绍一下struct在内存中的结构是怎么样的。基本上来说，struct在内存中是一段连续的地址，如果我们有一个struct，并且有f1，f2，f3三个字段。</strong></p>
<p><img src="https://906337931-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHZoT2b_bcLghjAOPsJ%2F-MM4GlTfQa57FRIbUhP2%2F-MM8LCRNuvyydmmGuXOR%2Fimage.png?alt=media&token=42519273-f9f6-4e61-8800-4e10a67a992a" alt="img"></p>
<br/>



<p><strong>当我们创建这样一个struct时，内存中相应的字段会彼此相邻。你可以认为struct像是一个数组，但是里面的不同字段的类型可以不一样。（注，这应该是这一节课中最有用的一句话了。。。）</strong></p>
<p><strong>我们可以将struct作为参数传递给函数。</strong></p>
<p><strong>这里有一个名字是Person的struct，它有两个字段。我将这个struct作为参数传递给printPerson并打印相关的信息。我们在printPerson中设置一个断点，当程序运行到函数内部时打印当前的Stack Frame。</strong></p>
<p><img src="https://906337931-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHZoT2b_bcLghjAOPsJ%2F-MM4GlTfQa57FRIbUhP2%2F-MM8LYQZbzmPyj44rlOO%2Fimage.png?alt=media&token=babfc0e6-9414-4d55-a70c-814b8a9d8ae8" alt="img"></p>
<p><img src="https://906337931-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHZoT2b_bcLghjAOPsJ%2F-MM4GlTfQa57FRIbUhP2%2F-MM8MLjSn1BwV8ZJJCik%2Fimage.png?alt=media&token=b9ef627e-6f3a-4d2d-93fe-4d31405052cb" alt="img"></p>
<br/>



<p><strong>我们可以看到当前函数有一个参数p。打印p可以看到这是struct Person的指针，打印p的反引用可以看到struct的具体内容。</strong></p>
<p><img src="https://906337931-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHZoT2b_bcLghjAOPsJ%2F-MM4GlTfQa57FRIbUhP2%2F-MM8Mpx3qmdIFbBbEtwS%2Fimage.png?alt=media&token=5306899d-49c8-4d49-9d21-ea2b5b790ae3" alt="img"></p>
<blockquote>
<p><strong><code>学生提问：</code>是谁创建了编译器来将C代码转换成各种各样的汇编代码，是不同的指令集创建者，还是第三方？</strong></p>
<p><strong><code>Ta：</code>我认为不是指令集的创建者，通常是第三方创建的。你们常见的两大编译器，一个是gcc，这是由GNU基金会维护的；一个是llvm，这个是开源的，你可以查到相应的代码。当一个新的指令集，例如RISC-V，发布之后，我认为指令集的创建者和编译器的设计者之间会有一些高度合作。简单来说我认为是第三方配合指令集的创建者完成的编译器。RISC-V或许是个例外，因为它是来自于一个研究项目，相应的团队或许自己写了编译器，但是我不认为Intel对于gcc或者llvn有任何输入。</strong></p>
</blockquote>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://njuni.online">KAZAMA</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://njuni.online/2022/09/07/MIT6.S081%EF%BC%9ALec05%20Calling%20conventions%20and%20stack%20frames%20RISC-V%EF%BC%88TA%EF%BC%89/MIT6.S081%EF%BC%9ALec05%20Calling%20conventions%20and%20stack%20frames%20RISC-V%EF%BC%88TA%EF%BC%89/">http://njuni.online/2022/09/07/MIT6.S081%EF%BC%9ALec05%20Calling%20conventions%20and%20stack%20frames%20RISC-V%EF%BC%88TA%EF%BC%89/MIT6.S081%EF%BC%9ALec05%20Calling%20conventions%20and%20stack%20frames%20RISC-V%EF%BC%88TA%EF%BC%89/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://njuni.online" target="_blank">KAZAMA的个人博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechat.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/09/08/20.%20%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/20.%20%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/" title=""><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info"></div></div></a></div><div class="next-post pull-right"><a href="/2022/09/05/MIT6.S081%EF%BC%9ALec04%20Page%20tables%EF%BC%88Frans%EF%BC%89/MIT6.S081%EF%BC%9ALec04%20Page%20tables%EF%BC%88Frans%EF%BC%89/" title=""><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info"></div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">KAZAMA</div><div class="author-info__description">技术记录,个人分享,学习备忘</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">300</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">1</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/KAZAMA-DREAM"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/KAZAMA-DREAM" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="/wyy1778789301@163.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#MIT6-S081%EF%BC%9ALec05-Calling-conventions-and-stack-frames-RISC-V%EF%BC%88TA%EF%BC%89"><span class="toc-number">1.</span> <span class="toc-text">MIT6.S081：Lec05 Calling conventions and stack frames RISC-V（TA）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-C%E7%A8%8B%E5%BA%8F%E5%88%B0%E6%B1%87%E7%BC%96%E7%A8%8B%E5%BA%8F%E5%88%B0%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.1.</span> <span class="toc-text">5.1 C程序到汇编程序到转换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-RISC-V-vs-x86"><span class="toc-number">1.2.</span> <span class="toc-text">5.2 RISC-V vs x86</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3-gdb%E5%92%8C%E6%B1%87%E7%BC%96%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C"><span class="toc-number">1.3.</span> <span class="toc-text">5.3 gdb和汇编代码执行</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-4-RISC-V%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">1.4.</span> <span class="toc-text">5.4 RISC-V寄存器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-5-Stack"><span class="toc-number">1.5.</span> <span class="toc-text">5.5 Stack</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-6-Struct"><span class="toc-number">1.6.</span> <span class="toc-text">5.6 Struct</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/02/04/2021-07-30-JS%E4%B8%AD%E7%9A%84innerHTML%EF%BC%8CinnerText%EF%BC%8Cvalue%E7%9A%84%E5%8C%BA%E5%88%AB-JS%E4%B8%AD%E7%9A%84innerHTML%EF%BC%8CinnerText%EF%BC%8Cvalue%E7%9A%84%E5%8C%BA%E5%88%AB/" title="无题">无题</a><time datetime="2023-02-04T07:30:02.522Z" title="发表于 2023-02-04 15:30:02">2023-02-04</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/02/04/2022-07-23-Mac-OS-%E4%B8%8A%E8%AE%BE%E7%BD%AE-JAVA-HOME-Mac-OS-%E4%B8%8A%E8%AE%BE%E7%BD%AE-JAVA-HOME/" title="无题">无题</a><time datetime="2023-02-04T07:29:35.332Z" title="发表于 2023-02-04 15:29:35">2023-02-04</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/01/25/hello-world/" title="Hello World">Hello World</a><time datetime="2023-01-25T09:51:15.064Z" title="发表于 2023-01-25 17:51:15">2023-01-25</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/12/30/JDK%E4%BD%BF%E7%94%A8IDEA%EF%BC%8C%E9%85%8D%E7%BD%AEJavaFX/JDK%E4%BD%BF%E7%94%A8IDEA%EF%BC%8C%E9%85%8D%E7%BD%AEJavaFX/" title="无题">无题</a><time datetime="2022-12-29T16:00:00.000Z" title="发表于 2022-12-30 00:00:00">2022-12-30</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/12/30/Mac%E4%B8%8B%E5%AE%89%E8%A3%85%E5%A4%9A%E4%B8%AAjdk%E3%80%81%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E7%81%B5%E6%B4%BB%E5%88%87%E6%8D%A2/Mac%E4%B8%8B%E5%AE%89%E8%A3%85%E5%A4%9A%E4%B8%AAjdk%E3%80%81%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E7%81%B5%E6%B4%BB%E5%88%87%E6%8D%A2/" title="无题">无题</a><time datetime="2022-12-29T16:00:00.000Z" title="发表于 2022-12-30 00:00:00">2022-12-30</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By KAZAMA</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><canvas class="fireworks" mobile="true"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = true;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>